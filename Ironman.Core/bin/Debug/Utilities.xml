<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Utilities</name>
  </assembly>
  <members>
    <member name="T:Utilities.Configuration.ConfigurationManager">
      <summary>
            Configuration manager
            </summary>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.Get``1(Utilities.Configuration.ConfigurationSystem,System.String)">
      <summary>
            Gets the config file specified
            </summary>
      <typeparam name="T">The config type</typeparam>
      <param name="Name">
            Name of the config file (Defaults to "Default" which is the web.config/app.config file
            if using the default config system)
            </param>
      <param name="System">Configuration system to pull from</param>
      <returns>The config file specified</returns>
      <requires description="The config system can not be null." exception="T:System.ArgumentNullException" csharp="System != null" vb="System &lt;&gt; Nothing">System != null</requires>
      <exception cref="T:System.ArgumentNullException">System == null</exception>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.Get``1(System.String)">
      <summary>
            Gets the config file specified
            </summary>
      <typeparam name="T">The config type</typeparam>
      <param name="Name">
            Name of the config file (Defaults to "Default" which is the web.config/app.config file
            if using the default config system)
            </param>
      <returns>The config file specified</returns>
    </member>
    <member name="T:Utilities.Configuration.ConfigurationSystem">
      <summary>
            Configuration system enum
            </summary>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationSystem.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationSystem.op_Implicit(Utilities.Configuration.ConfigurationSystem)~System.String">
      <summary>
            Converts the object to a string implicitly
            </summary>
      <param name="Object">Object to convert</param>
      <returns>The string version of the configuration system type</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationSystem.ToString">
      <summary>
            Returns the name of the serialization type
            </summary>
      <returns>Name</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Configuration.ConfigurationSystem.Default">
      <summary>
            Default
            </summary>
    </member>
    <member name="T:Utilities.Configuration.JSONConfig`1">
      <summary>
            JSON config base class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
    </member>
    <member name="T:Utilities.Configuration.Manager.BaseClasses.Config`1">
      <summary>
            Default config base class
            </summary>
      <typeparam name="ConfigClassType">Config class type</typeparam>
    </member>
    <member name="T:Utilities.DataTypes.Dynamo`1">
      <summary>
            Dynamic object implementation (used when inheriting)
            </summary>
      <typeparam name="T">Child object type</typeparam>
    </member>
    <member name="T:Utilities.DataTypes.Dynamo">
      <summary>
            Dynamic object implementation
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.#ctor(System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="Item">Item to copy values from</param>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object})">
      <summary>
            Constructor
            </summary>
      <param name="Dictionary">Dictionary to copy</param>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor
            </summary>
      <param name="info">Serialization info</param>
      <param name="context">Streaming context</param>
      <requires description="info" exception="T:System.ArgumentNullException" csharp="info != null" vb="info &lt;&gt; Nothing">info != null</requires>
      <exception cref="T:System.ArgumentNullException">info == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.Add(System.String,System.Object)">
      <summary>
            Adds a key/value pair to the object
            </summary>
      <param name="key">key</param>
      <param name="value">value</param>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Adds a key/value pair
            </summary>
      <param name="item">Item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.Clear">
      <summary>
            Clears the key/value pairs
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Does the object contain the key/value pair
            </summary>
      <param name="item">Item to check</param>
      <returns>True if it is found, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.ContainsKey(System.String)">
      <summary>
            Determines if the object contains a key
            </summary>
      <param name="key">Key to check</param>
      <returns>True if it is found, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result ⇒ this.Count &gt; 0; })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result Implies Me.Count &gt; 0; })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return !result || this.Count &gt; 0; })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
      <summary>
            Copies the key/value pairs to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Array index</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.CopyTo(System.Object)">
      <summary>
            Copies data from here to another object
            </summary>
      <param name="result">Result</param>
      <requires description="result" exception="T:System.ArgumentNullException" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</requires>
      <exception cref="T:System.ArgumentNullException">result == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.Equals(System.Object)">
      <summary>
            Determines if two objects are equal
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they're equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.GetDynamicMemberNames">
      <summary>
            Gets the dynamic member names
            </summary>
      <returns>The keys used internally</returns>
      <ensures inheritedFrom="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" inheritedFromTypeName="DynamicObject" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.GetEnumerator">
      <summary>
            Gets the enumerator for the object
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.GetHashCode">
      <summary>
            Gets the hash code
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Gets the object data and serializes it
            </summary>
      <param name="info">Serialization info object</param>
      <param name="context">Streaming context object</param>
      <requires inheritedFrom="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" inheritedFromTypeName="ISerializable" csharp="info != null" vb="info &lt;&gt; Nothing">info != null</requires>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.GetSchema">
      <summary>
            Not used
            </summary>
      <returns>Null</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.ReadXml(System.Xml.XmlReader)">
      <summary>
            Reads the data from an XML doc
            </summary>
      <param name="reader">XML reader</param>
      <requires inheritedFrom="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" inheritedFromTypeName="IXmlSerializable" csharp="reader != null" vb="reader &lt;&gt; Nothing">reader != null</requires>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.Remove(System.String)">
      <summary>
            Removes the value associated with the key
            </summary>
      <param name="key">Key to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Removes a key/value pair
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.SubSet(System.String[])">
      <summary>
            Returns a subset of the current Dynamo object
            </summary>
      <param name="Keys">Property keys to return</param>
      <returns>A new Dynamo object containing only the keys specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the object
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.ToString">
      <summary>
            Outputs the object graph
            </summary>
      <returns>The string version of the object</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary>
            Attempts to convert the object
            </summary>
      <param name="binder">Convert binder</param>
      <param name="result">Result</param>
      <returns>True if it is converted, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary>
            Attempts to get a member
            </summary>
      <param name="binder">GetMemberBinder object</param>
      <param name="result">Result</param>
      <returns>True if it gets the member, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.TryGetValue(System.String,System.Object@)">
      <summary>
            Attempts to get a value
            </summary>
      <param name="key">Key to get</param>
      <param name="value">Value object</param>
      <returns>True if it the key is found, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result == this.ContainsKey(key); })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result = Me.ContainsKey(key); })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return result == this.ContainsKey(key); })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary>
            Attempts to invoke a function
            </summary>
      <param name="binder">Invoke binder</param>
      <param name="args">Function args</param>
      <param name="result">Result</param>
      <returns>True if it invokes, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary>
            Attempts to invoke a member
            </summary>
      <param name="binder">Invoke binder</param>
      <param name="args">Function args</param>
      <param name="result">Result</param>
      <returns>True if it invokes, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary>
            Attempts to set the member
            </summary>
      <param name="binder">Member binder</param>
      <param name="value">Value</param>
      <returns>True if it is set, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.WriteXml(System.Xml.XmlWriter)">
      <summary>
            Writes the data to an XML doc
            </summary>
      <param name="writer">XML writer</param>
      <requires inheritedFrom="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" inheritedFromTypeName="IXmlSerializable" csharp="writer != null" vb="writer &lt;&gt; Nothing">writer != null</requires>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.GetValue(System.String,System.Type)">
      <summary>
            Gets a value
            </summary>
      <param name="Name">Name of the item</param>
      <param name="ReturnType">Return value type</param>
      <returns>The returned value</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.SetValue(System.String,System.Object)">
      <summary>
            Sets a value
            </summary>
      <param name="key">Name of the item</param>
      <param name="value">Value to set</param>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.RaiseGetValueEnd(System.String,System.Object)">
      <summary>
            Raises the get value end event
            </summary>
      <param name="PropertyName">Property name</param>
      <param name="Value">Value initially being returned</param>
      <returns>
            Returns null if the function should continue, any other value should be immediately
            returned to the user
            </returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.RaiseGetValueStart(System.String)">
      <summary>
            Raises the get value start event
            </summary>
      <param name="PropertyName">Property name</param>
      <returns>
            Returns null if the function should continue, any other value should be immediately
            returned to the user
            </returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo.RaisePropertyChanged(System.String,System.Object)">
      <summary>
            Raises the property changed event
            </summary>
      <param name="PropertyName">Property name</param>
      <param name="NewValue">New value for the property</param>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo.ChangeLog">
      <summary>
            Change log
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo.Count">
      <summary>
            Number of items
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo.IsReadOnly">
      <summary>
            Is this read only?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo.Keys">
      <summary>
            Keys
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo.Values">
      <summary>
            Values
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo.ChildValues">
      <summary>
            Child class key/value dictionary
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo.InternalValues">
      <summary>
            Internal key/value dictionary
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo.Extensions">
      <summary>
            Extensions for the class
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo.Item(System.String)">
      <summary>
            Gets the value associated with the key specified
            </summary>
      <param name="key">Key to get</param>
      <returns>The object associated with the key</returns>
    </member>
    <member name="E:Utilities.DataTypes.Dynamo.GetValueEnd">
      <summary>
            Called when the value/property is found but before it is returned to the caller Sends
            (this, PropertyName, EventArgs) to items attached to the event
            </summary>
    </member>
    <member name="E:Utilities.DataTypes.Dynamo.GetValueStart">
      <summary>
            Called when beginning to get a value/property Sends (this, EventArgs) to items attached
            to the event
            </summary>
    </member>
    <member name="E:Utilities.DataTypes.Dynamo.PropertyChanged">
      <summary>
            Property changed event
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo`1.#ctor(System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="Item">Item to copy values from</param>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo`1.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object})">
      <summary>
            Constructor
            </summary>
      <param name="Dictionary">Dictionary to copy</param>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor
            </summary>
      <param name="info">Serialization info</param>
      <param name="context">Streaming context</param>
      <requires description="info" exception="T:System.ArgumentNullException" csharp="info != null" vb="info &lt;&gt; Nothing">info != null</requires>
      <exception cref="T:System.ArgumentNullException">info == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo`1.GetValue(System.String,System.Type)">
      <summary>
            Gets a value
            </summary>
      <param name="Name">Name of the item</param>
      <param name="ReturnType">Return value type</param>
      <returns>The returned value</returns>
    </member>
    <member name="M:Utilities.DataTypes.Dynamo`1.SetValue(System.String,System.Object)">
      <summary>
            Sets a value
            </summary>
      <param name="key">Name of the item</param>
      <param name="value">Value associated with the key</param>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo`1.Keys">
      <summary>
            Keys to the dynamic type
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Dynamo`1.Values">
      <summary>
            Gets the Values
            </summary>
    </member>
    <member name="T:Utilities.Configuration.Manager.Interfaces.IConfig">
      <summary>
            Interface for the Config object
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Interfaces.IConfig.Load">
      <summary>
            Loads the config file
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Interfaces.IConfig.Save">
      <summary>
            Saves the config file
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.Interfaces.IConfig.Name">
      <summary>
            Name of the Config object
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.BaseClasses.Config`1.#ctor(System.Func{System.String,`0},System.Func{`0,System.String})">
      <summary>
            Constructor
            </summary>
      <param name="StringToObject">String to object</param>
      <param name="ObjectToString">Object to string</param>
    </member>
    <member name="M:Utilities.Configuration.Manager.BaseClasses.Config`1.Load">
      <summary>
            Loads the config
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.BaseClasses.Config`1.Save">
      <summary>
            Saves the config
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.BaseClasses.Config`1.Name">
      <summary>
            Name of the Config object
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.BaseClasses.Config`1.ConfigFileLocation">
      <summary>
            Location to save/load the config file from. If blank, it does not save/load but uses any
            defaults specified.
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.BaseClasses.Config`1.EncryptionPassword">
      <summary>
            Encryption password for properties/fields. Used only if set.
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.BaseClasses.Config`1.ObjectToString">
      <summary>
            Gets a string representation of the object
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.BaseClasses.Config`1.StringToObject">
      <summary>
            Gets the object
            </summary>
    </member>
    <member name="M:Utilities.Configuration.JSONConfig`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:Utilities.Configuration.Manager.Default.ConfigSystem">
      <summary>
            Default config system
            </summary>
    </member>
    <member name="T:Utilities.Configuration.Manager.Interfaces.IConfigSystem">
      <summary>
            Interface for the Config system
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Interfaces.IConfigSystem.Config``1(System.String)">
      <summary>
            Gets the config object specified
            </summary>
      <param name="Name">Name of the config object</param>
      <returns>The config object</returns>
    </member>
    <member name="P:Utilities.Configuration.Manager.Interfaces.IConfigSystem.Name">
      <summary>
            Name of the Config system
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Default.ConfigSystem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Default.ConfigSystem.Config``1(System.String)">
      <summary>
            Gets the config object specified
            </summary>
      <param name="Name">Name of the config object</param>
      <returns>The config object</returns>
    </member>
    <member name="M:Utilities.Configuration.Manager.Default.ConfigSystem.ContainsConfigFile``1(System.String)">
      <summary>
            Determines if a specified config file is registered
            </summary>
      <typeparam name="T">Type of the config object</typeparam>
      <param name="Name">Name of the config object</param>
      <returns>The config object specified</returns>
    </member>
    <member name="P:Utilities.Configuration.Manager.Default.ConfigSystem.Name">
      <summary>
            Name of the Config system
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.Default.ConfigSystem.ConfigFiles">
      <summary>
            Config files
            </summary>
    </member>
    <member name="T:Utilities.Configuration.Manager.Default.SystemConfig">
      <summary>
            Default config class for web.config and app.config
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Default.SystemConfig.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Default.SystemConfig.Load">
      <summary>
            Loads the config
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Default.SystemConfig.Save">
      <summary>
            Saves the config
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.Default.SystemConfig.AppSettings">
      <summary>
            Application settings
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.Default.SystemConfig.ConnectionStrings">
      <summary>
            Connection strings
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.Default.SystemConfig.Name">
      <summary>
            Name of the Config object
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.Default.SystemConfig.Item(System.String)">
      <summary>
            Gets the configuration section based on the name specified
            </summary>
      <param name="SectionName">Section name</param>
      <returns>The configuration section specified</returns>
    </member>
    <member name="T:Utilities.Configuration.Manager.Default.ConnectionString">
      <summary>
            Connection string class
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.Default.ConnectionString.Connection">
      <summary>
            Actual connection string
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.Default.ConnectionString.ProviderName">
      <summary>
            Provider name
            </summary>
    </member>
    <member name="T:Utilities.Configuration.Manager.Manager">
      <summary>
            Config manager
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass">
      <summary>
            Base class used for disposable objects
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass.#ctor">
      <summary>
            Construct
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass.Dispose">
      <summary>
            Dispose function
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass.Dispose(System.Boolean)">
      <summary>
            Function to override in order to dispose objects
            </summary>
      <param name="Managed">
            If true, managed and unmanaged objects should be disposed. Otherwise unmanaged objects only.
            </param>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Manager.Get(System.String)">
      <summary>
            Gets the config system specified
            </summary>
      <param name="Name">Name of the config system</param>
      <returns>The config system specified</returns>
      <requires description="The config system was not found." exception="T:System.ArgumentException" csharp="this.ConfigSystems.ContainsKey(Name)" vb="Me.ConfigSystems.ContainsKey(Name)">this.ConfigSystems.ContainsKey(Name)</requires>
      <exception cref="T:System.ArgumentException">!this.ConfigSystems.ContainsKey(Name)</exception>
    </member>
    <member name="M:Utilities.Configuration.Manager.Manager.ToString">
      <summary>
            Outputs the config system information in string format
            </summary>
      <returns>The list of config systems that are available</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Configuration.Manager.Manager.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">
            Determines if all objects should be disposed or just managed objects
            </param>
    </member>
    <member name="P:Utilities.Configuration.Manager.Manager.ConfigSystems">
      <summary>
            Config systems that the library can use
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Manager.Manager.Item(System.String)">
      <summary>
            Gets the config system by name
            </summary>
      <param name="Name">Name of the config system</param>
      <returns>The config system specified</returns>
    </member>
    <member name="T:Utilities.Configuration.Manager.Module.ConfigSystemModule">
      <summary>
            Config system module
            </summary>
    </member>
    <member name="T:Utilities.IoC.Interfaces.IModule">
      <summary>
            IoC module base class
            </summary>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module using the bootstrapper
            </summary>
      <param name="Bootstrapper">Bootstrapper used to register various objects</param>
    </member>
    <member name="P:Utilities.IoC.Interfaces.IModule.Order">
      <summary>
            Order to run this in
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Manager.Module.ConfigSystemModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.Configuration.Manager.Module.ConfigSystemModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.Configuration.XMLConfig`1">
      <summary>
            XML config base class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
    </member>
    <member name="M:Utilities.Configuration.XMLConfig`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Caching.Default.Cache">
      <summary>
            Built in cache
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Caching.Interfaces.ICache">
      <summary>
            Cache interface
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Interfaces.ICache.Name">
      <summary>
            Cache name
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.Add(System.String,System.Object)">
      <summary>
            Add item to the cache
            </summary>
      <param name="key">Key of the item</param>
      <param name="value">Value to add</param>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Adds an item to the cache
            </summary>
      <param name="item">item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.Clear">
      <summary>
            Clears the cache
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Determines if the item is in the cache
            </summary>
      <param name="item">item to check for</param>
      <returns />
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.ContainsKey(System.String)">
      <summary>
            Checks if the cache contains the key
            </summary>
      <param name="key">Key to check</param>
      <returns>True if it is there, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result ⇒ this.Count &gt; 0; })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result Implies Me.Count &gt; 0; })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return !result || this.Count &gt; 0; })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
      <summary>
            Copies to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.Dispose">
      <summary>
            Disposes the cache
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.Remove(System.String)">
      <summary>
            Removes an item from the cache
            </summary>
      <param name="key">key to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Removes an item from an array
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.Cache.TryGetValue(System.String,System.Object@)">
      <summary>
            Attempt to get a value
            </summary>
      <param name="key">Key to get</param>
      <param name="value">Value of the item</param>
      <returns>True if it is found, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result == this.ContainsKey(key); })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result = Me.ContainsKey(key); })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return result == this.ContainsKey(key); })()</ensures>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.Cache.Count">
      <summary>
            The number of items in the cache
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.Cache.IsReadOnly">
      <summary>
            Read only
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.Cache.Keys">
      <summary>
            Keys
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.Cache.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.Cache.Values">
      <summary>
            Values
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.Cache.InternalCache">
      <summary>
            Internal cache
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.Cache.Item(System.String)">
      <summary>
            Indexer
            </summary>
      <param name="key">Key</param>
      <returns>The object specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.Caching.Default.CacheCache">
      <summary>
            Cache used in ASP.Net for cache level cache
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.Add(System.String,System.Object)">
      <summary>
            Add item to the cache
            </summary>
      <param name="key">Key of the item</param>
      <param name="value">Value to add</param>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Adds an item to the cache
            </summary>
      <param name="item">item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.Clear">
      <summary>
            Clears the cache
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Determines if the item is in the cache
            </summary>
      <param name="item">item to check for</param>
      <returns />
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.ContainsKey(System.String)">
      <summary>
            Checks if the cache contains the key
            </summary>
      <param name="key">Key to check</param>
      <returns>True if it is there, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result ⇒ this.Count &gt; 0; })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result Implies Me.Count &gt; 0; })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return !result || this.Count &gt; 0; })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
      <summary>
            Copies to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.Remove(System.String)">
      <summary>
            Removes an item from the cache
            </summary>
      <param name="key">key to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Removes an item from an array
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.TryGetValue(System.String,System.Object@)">
      <summary>
            Attempt to get a value
            </summary>
      <param name="key">Key to get</param>
      <param name="value">Value of the item</param>
      <returns>True if it is found, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result == this.ContainsKey(key); })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result = Me.ContainsKey(key); })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return result == this.ContainsKey(key); })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.CacheCache.Dispose(System.Boolean)">
      <summary>
            Disposes of the cache
            </summary>
      <param name="Managed">Managed or not</param>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.CacheCache.Count">
      <summary>
            The number of items in the cache
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.CacheCache.IsReadOnly">
      <summary>
            Read only
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.CacheCache.Keys">
      <summary>
            Keys
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.CacheCache.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.CacheCache.Values">
      <summary>
            Values
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.CacheCache.InternalKeys">
      <summary>
            Internal keys
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.CacheCache.Item(System.String)">
      <summary>
            Indexer
            </summary>
      <param name="key">Key</param>
      <returns>The object specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.Caching.Default.ItemCache">
      <summary>
            Cache used in ASP.Net for item level cache
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.Add(System.String,System.Object)">
      <summary>
            Add item to the cache
            </summary>
      <param name="key">Key of the item</param>
      <param name="value">Value to add</param>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Adds an item to the cache
            </summary>
      <param name="item">item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.Clear">
      <summary>
            Clears the cache
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Determines if the item is in the cache
            </summary>
      <param name="item">item to check for</param>
      <returns />
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.ContainsKey(System.String)">
      <summary>
            Checks if the cache contains the key
            </summary>
      <param name="key">Key to check</param>
      <returns>True if it is there, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result ⇒ this.Count &gt; 0; })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result Implies Me.Count &gt; 0; })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return !result || this.Count &gt; 0; })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
      <summary>
            Copies to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.Remove(System.String)">
      <summary>
            Removes an item from the cache
            </summary>
      <param name="key">key to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Removes an item from an array
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.TryGetValue(System.String,System.Object@)">
      <summary>
            Attempt to get a value
            </summary>
      <param name="key">Key to get</param>
      <param name="value">Value of the item</param>
      <returns>True if it is found, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result == this.ContainsKey(key); })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result = Me.ContainsKey(key); })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return result == this.ContainsKey(key); })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.ItemCache.Dispose(System.Boolean)">
      <summary>
            Disposes of the cache
            </summary>
      <param name="Managed">Managed or not</param>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.ItemCache.Count">
      <summary>
            The number of items in the cache
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.ItemCache.IsReadOnly">
      <summary>
            Read only
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.ItemCache.Keys">
      <summary>
            Keys
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.ItemCache.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.ItemCache.Values">
      <summary>
            Values
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.ItemCache.Item(System.String)">
      <summary>
            Indexer
            </summary>
      <param name="key">Key</param>
      <returns>The object specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.Caching.Default.SessionCache">
      <summary>
            Cache used in ASP.Net for session level cache
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.Add(System.String,System.Object)">
      <summary>
            Add item to the cache
            </summary>
      <param name="key">Key of the item</param>
      <param name="value">Value to add</param>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Adds an item to the cache
            </summary>
      <param name="item">item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.Clear">
      <summary>
            Clears the cache
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Determines if the item is in the cache
            </summary>
      <param name="item">item to check for</param>
      <returns />
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.ContainsKey(System.String)">
      <summary>
            Checks if the cache contains the key
            </summary>
      <param name="key">Key to check</param>
      <returns>True if it is there, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result ⇒ this.Count &gt; 0; })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result Implies Me.Count &gt; 0; })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return !result || this.Count &gt; 0; })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
      <summary>
            Copies to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.Remove(System.String)">
      <summary>
            Removes an item from the cache
            </summary>
      <param name="key">key to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>
            Removes an item from an array
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.TryGetValue(System.String,System.Object@)">
      <summary>
            Attempt to get a value
            </summary>
      <param name="key">Key to get</param>
      <param name="value">Value of the item</param>
      <returns>True if it is found, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result == this.ContainsKey(key); })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = Me;&#xD;&#xA;    return result = Me.ContainsKey(key); })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;string, object&gt; local_0 = this;
    }
    return result == this.ContainsKey(key); })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Default.SessionCache.Dispose(System.Boolean)">
      <summary>
            Disposes of the cache
            </summary>
      <param name="Managed">Managed or not</param>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.SessionCache.Count">
      <summary>
            The number of items in the cache
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.SessionCache.IsReadOnly">
      <summary>
            Read only
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.SessionCache.Keys">
      <summary>
            Keys
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.SessionCache.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.SessionCache.Values">
      <summary>
            Values
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Default.SessionCache.Item(System.String)">
      <summary>
            Indexer
            </summary>
      <param name="key">Key</param>
      <returns>The object specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.Caching.Manager">
      <summary>
            Caching manager class
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Manager.Cache(System.String)">
      <summary>
            Gets the specified cache
            </summary>
      <param name="Name">Name of the cache (defaults to Default)</param>
      <returns>
            Returns the ICache specified if it exists, otherwise creates a default cache and
            associates it with the name
            </returns>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Manager.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">
            Determines if all objects should be disposed or just managed objects
            </param>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Manager.Caches">
      <summary>
            Caches
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Caching.Module.CachingModule">
      <summary>
            Caching module
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Caching.Module.CachingModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.DataTypes.Caching.Module.CachingModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.AI.NaiveBayes`1">
      <summary>
            Naive bayes classifier
            </summary>
      <typeparam name="T">The type of the individual tokens</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.AI.NaiveBayes`1.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="ATokenWeight">Weight of each token in set A</param>
      <param name="BTokenWeight">Weight of each token in set B</param>
      <param name="MaxInterestingTokenCount">
            After sorting, this is the maximum number of tokens that are picked to figure out the
            final probability
            </param>
      <param name="MaxTokenProbability">Maximum token probability</param>
      <param name="MinTokenProbability">Minimum token probability</param>
      <param name="MinCountForInclusion">
            Minimum number of times a token needs to be present for it to be included
            </param>
    </member>
    <member name="M:Utilities.DataTypes.AI.NaiveBayes`1.CalculateProbabilityOfTokens(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Calculates the probability of the list of tokens being in set A
            </summary>
      <param name="Items">List of items</param>
      <returns>The probability that the tokens are from set A</returns>
      <requires description="Items" exception="T:System.ArgumentNullException" csharp="Items != null" vb="Items &lt;&gt; Nothing">Items != null</requires>
      <exception cref="T:System.ArgumentNullException">Items == null</exception>
      <requires description="Probabilities has not been initialized" exception="T:System.InvalidOperationException" csharp="this.Probabilities != null" vb="Me.Probabilities &lt;&gt; Nothing">this.Probabilities != null</requires>
      <exception cref="T:System.InvalidOperationException">this.Probabilities == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.AI.NaiveBayes`1.LoadTokens(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Loads a set of tokens
            </summary>
      <param name="SetATokens">Set A</param>
      <param name="SetBTokens">Set B</param>
      <requires description="SetATokens" exception="T:System.ArgumentNullException" csharp="SetATokens != null" vb="SetATokens &lt;&gt; Nothing">SetATokens != null</requires>
      <exception cref="T:System.ArgumentNullException">SetATokens == null</exception>
      <requires description="SetBTokens" exception="T:System.ArgumentNullException" csharp="SetBTokens != null" vb="SetBTokens &lt;&gt; Nothing">SetBTokens != null</requires>
      <exception cref="T:System.ArgumentNullException">SetBTokens == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.AI.NaiveBayes`1.CalculateProbabilityOfToken(`0)">
      <summary>
            Calculates a single items probability of being in set A
            </summary>
      <param name="Item">Item to calculate</param>
      <returns>The probability that the token is from set A</returns>
      <requires description="Probabilities have not been initialized" exception="T:System.ArgumentNullException" csharp="this.SetA != default(Utilities.DataTypes.Bag&lt;T&gt;) &amp;&amp; this.SetB != null" vb="Me.SetA &lt;&gt; Nothing AndAlso Me.SetB &lt;&gt; Nothing">this.SetA != default(Utilities.DataTypes.Bag&lt;T&gt;) &amp;&amp; this.SetB != null</requires>
      <exception cref="T:System.ArgumentNullException">this.SetA == default(Utilities.DataTypes.Bag&lt;T&gt;) ? !false : this.SetB == null</exception>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.ATokenWeight">
      <summary>
            Weight to give to the probabilities in set A
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.BTokenWeight">
      <summary>
            Weight to give the probabilities in set B
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.MaxInterestingTokenCount">
      <summary>
            After sorting, this is the maximum number of tokens that are picked to figure out the
            final probability
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.MaxTokenProbability">
      <summary>
            Maximum token probability (if greater than this amount, it becomes this amount)
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.MinCountForInclusion">
      <summary>
            Minimum count that an item needs to be found to be included in final probability
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.MinTokenProbability">
      <summary>
            Minimum token probability (if less than this amount, it becomes this amount)
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.SetA">
      <summary>
            Set A
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.SetB">
      <summary>
            Set B
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.Probabilities">
      <summary>
            Dictionary containing probabilities
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.Total">
      <summary>
            Total number of tokens
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.TotalA">
      <summary>
            Total number of tokens in set A
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AI.NaiveBayes`1.TotalB">
      <summary>
            Total number of tokens in set B
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.AOP.Interfaces.IAspect">
      <summary>
            Aspect interface
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Interfaces.IAspect.Setup(System.Object)">
      <summary>
            Used to hook into the object once it has been created
            </summary>
      <param name="Object">Object created by the system</param>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Interfaces.IAspect.SetupDefaultConstructor(System.Type)">
      <summary>
            Used to insert code into the default constructor
            </summary>
      <param name="BaseType">Base type</param>
      <returns>The code to insert</returns>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Interfaces.IAspect.SetupEndMethod(System.Reflection.MethodInfo,System.Type,System.String)">
      <summary>
            Used to insert code at the end of the method
            </summary>
      <param name="Method">Overridding Method</param>
      <param name="BaseType">Base type</param>
      <param name="ReturnValueName">Local holder for the value returned by the function</param>
      <returns>The code to insert</returns>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Interfaces.IAspect.SetupExceptionMethod(System.Reflection.MethodInfo,System.Type)">
      <summary>
            Used to insert code within the catch portion of the try/catch portion of the method
            </summary>
      <param name="Method">Overridding Method</param>
      <param name="BaseType">Base type</param>
      <returns>The code to insert</returns>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Interfaces.IAspect.SetupInterfaces(System.Type)">
      <summary>
            Used to set up any interfaces, extra fields, methods, etc. prior to overridding any methods.
            </summary>
      <param name="Type">Type of the object</param>
      <returns>The code to insert</returns>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Interfaces.IAspect.SetupStartMethod(System.Reflection.MethodInfo,System.Type)">
      <summary>
            Used to insert code at the beginning of the method
            </summary>
      <param name="Method">Overridding Method</param>
      <param name="BaseType">Base type</param>
      <returns>The code to insert</returns>
    </member>
    <member name="P:Utilities.DataTypes.AOP.Interfaces.IAspect.AssembliesUsing">
      <summary>
            Set of assemblies that the aspect requires
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AOP.Interfaces.IAspect.InterfacesUsing">
      <summary>
            List of interfaces that need to be injected by this aspect
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.AOP.Interfaces.IAspect.Usings">
      <summary>
            Using statements that the aspect requires
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.AOP.Manager">
      <summary>
            AOP interface manager
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Manager.#ctor(Utilities.DataTypes.CodeGen.Compiler)">
      <summary>
            Constructor
            </summary>
      <requires description="Compiler" exception="T:System.ArgumentNullException" csharp="Compiler != null" vb="Compiler &lt;&gt; Nothing">Compiler != null</requires>
      <exception cref="T:System.ArgumentNullException">Compiler == null</exception>
    </member>
    <member name="F:Utilities.DataTypes.AOP.Manager.Aspects">
      <summary>
            The list of aspects that are being used
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.AOP.Manager.Classes">
      <summary>
            Dictionary containing generated types and associates it with original type
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Manager.Create``1">
      <summary>
            Creates an object of the specified base type, registering the type if necessary
            </summary>
      <typeparam name="T">The base type</typeparam>
      <returns>Returns an object of the specified base type</returns>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Manager.Create(System.Type)">
      <summary>
            Creates an object of the specified base type, registering the type if necessary
            </summary>
      <param name="BaseType">The base type</param>
      <returns>Returns an object of the specified base type</returns>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Manager.Setup(System.Type)">
      <summary>
            Sets up a type so it can be used in the system later
            </summary>
      <param name="Type">Type to set up</param>
    </member>
    <member name="P:Utilities.DataTypes.AOP.Manager.Compiler">
      <summary>
            Gets the system's compiler
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.AOP.Module.AOPModule">
      <summary>
            AOP module
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.AOP.Module.AOPModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.DataTypes.AOP.Module.AOPModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Bag`1">
      <summary>
            Used to count the number of times something is added to the list
            </summary>
      <typeparam name="T">Type of data within the bag</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.Add(`0)">
      <summary>
            Adds an item to the bag
            </summary>
      <param name="item">Item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.Clear">
      <summary>
            Clears the bag
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.Contains(`0)">
      <summary>
            Determines if the bag contains an item
            </summary>
      <param name="item">Item to check</param>
      <returns>True if it does, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the bag to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.Remove(`0)">
      <summary>
            Removes an item from the bag
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="P:Utilities.DataTypes.Bag`1.Count">
      <summary>
            Number of items in the bag
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Bag`1.IsReadOnly">
      <summary>
            Is this read only?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Bag`1.Items">
      <summary>
            Actual internal container
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Bag`1.Item(`0)">
      <summary>
            Gets a specified item
            </summary>
      <param name="index">Item to get</param>
      <returns>The number of this item in the bag</returns>
    </member>
    <member name="T:Utilities.DataTypes.BinaryTree`1">
      <summary>
            Binary tree
            </summary>
      <typeparam name="T">The type held by the nodes</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.#ctor(Utilities.DataTypes.TreeNode{`0})">
      <summary>
            Constructor
            </summary>
      <param name="Root">Root of the binary tree</param>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Add(`0)">
      <summary>
            Adds an item to a binary tree
            </summary>
      <param name="item">Item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Clear">
      <summary>
            Clears all items from the tree
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Contains(`0)">
      <summary>
            Determines if the tree contains an item
            </summary>
      <param name="item">Item to check</param>
      <returns>True if it is, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the tree to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Remove(`0)">
      <summary>
            Removes an item from the tree
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Find(`0)">
      <summary>
            Finds a specific object
            </summary>
      <param name="item">The item to find</param>
      <returns>The node if it is found</returns>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Insert(`0)">
      <summary>
            Inserts a value
            </summary>
      <param name="item">item to insert</param>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Traversal(Utilities.DataTypes.TreeNode{`0})">
      <summary>
            Traverses the list
            </summary>
      <param name="Node">The node to start the search from</param>
      <returns>The individual items from the tree</returns>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.op_Implicit(Utilities.DataTypes.BinaryTree{`0})~System.String">
      <summary>
            Converts the object to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != null" vb="Value &lt;&gt; Nothing">Value != null</requires>
      <exception cref="T:System.ArgumentNullException">Value == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.ToString">
      <summary>
            Outputs the tree as a string
            </summary>
      <returns>The string representation of the tree</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.IsEmpty">
      <summary>
            Is the tree empty
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.MaxValue">
      <summary>
            Gets the maximum value of the tree
            </summary>
      <getter>
        <requires description="The tree is empty" exception="T:System.InvalidOperationException" csharp="!this.IsEmpty" vb="Not Me.IsEmpty">!this.IsEmpty</requires>
      </getter>
      <exception cref="T:System.InvalidOperationException">this.IsEmpty</exception>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.MinValue">
      <summary>
            Gets the minimum value of the tree
            </summary>
      <getter>
        <requires description="The tree is empty" exception="T:System.InvalidOperationException" csharp="!this.IsEmpty" vb="Not Me.IsEmpty">!this.IsEmpty</requires>
      </getter>
      <exception cref="T:System.InvalidOperationException">this.IsEmpty</exception>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.Root">
      <summary>
            The root value
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.NumberOfNodes">
      <summary>
            The number of nodes in the tree
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.Count">
      <summary>
            Number of items in the tree
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.IsReadOnly">
      <summary>
            Is this read only?
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.TreeNode`1">
      <summary>
            Node class for the Binary tree
            </summary>
      <typeparam name="T">The value type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.TreeNode`1.#ctor(`0,Utilities.DataTypes.TreeNode{`0},Utilities.DataTypes.TreeNode{`0},Utilities.DataTypes.TreeNode{`0})">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the node</param>
      <param name="Parent">Parent node</param>
      <param name="Left">Left node</param>
      <param name="Right">Right node</param>
    </member>
    <member name="M:Utilities.DataTypes.TreeNode`1.ToString">
      <summary>
            Returns the node as a string
            </summary>
      <returns>String representation of the node</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.IsLeaf">
      <summary>
            Is this a leaf
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.IsRoot">
      <summary>
            Is this the root
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Left">
      <summary>
            Left node
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Parent">
      <summary>
            Parent node
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Right">
      <summary>
            Right node
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Value">
      <summary>
            Value of the node
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Visited">
      <summary>
            Visited?
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase">
      <summary>
            Compiler base class
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="AssemblyDirectory">Directory to save the generated types (optional)</param>
      <param name="AssemblyName">Assembly name to save the generated types as</param>
      <param name="Optimize">Should this be optimized (defaults to true)</param>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.Create``1(System.Type,System.Object[])">
      <summary>
            Creates an object using the type specified
            </summary>
      <typeparam name="T">Type to cast to</typeparam>
      <param name="TypeToCreate">Type to create</param>
      <param name="Args">Args to pass to the constructor</param>
      <returns>The created object</returns>
      <requires description="TypeToCreate" exception="T:System.ArgumentNullException" csharp="TypeToCreate != (System.Type)null" vb="TypeToCreate &lt;&gt; ((System.Type)Nothing) ">TypeToCreate != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!TypeToCreate != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.Add(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Reflection.Assembly[])">
      <summary>
            Compiles and adds the item to the module
            </summary>
      <param name="ClassName">Class name</param>
      <param name="Code">Code to compile</param>
      <param name="Usings">Usings for the code</param>
      <param name="References">References to add for the compiler</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.Add(System.String,System.String,System.Reflection.Assembly[])">
      <summary>
            Compiles and adds the item to the module
            </summary>
      <param name="ClassName">Class name</param>
      <param name="Code">Code to compile</param>
      <param name="References">References to add for the compiler</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">Destroy managed</param>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.Save">
      <summary>
            Saves the assembly
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.AssemblyDirectory">
      <summary>
            Assembly directory
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.AssemblyName">
      <summary>
            Assembly name
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.Classes">
      <summary>
            Dictionary containing generated types and associates it with original type
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.Assembly">
      <summary>
            Assembly builder
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.Module">
      <summary>
            Module builder
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.Optimize">
      <summary>
            Should this be optimized?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.CodeGen.BaseClasses.CompilerBase.RegenerateAssembly">
      <summary>
            Determines if the assembly needs to be regenerated
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.CodeGen.Compiler">
      <summary>
            Compiler
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.Compiler.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.Compiler.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="AssemblyName">Assembly name</param>
      <param name="AssemblyDirectory">Assembly directory</param>
      <param name="Optimize">Optimize the assembly?</param>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.Compiler.CreateClass(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Reflection.Assembly[])">
      <summary>
            Creates a class object
            </summary>
      <param name="ClassName">Class name</param>
      <param name="Code">Code</param>
      <param name="References">Assembly references</param>
      <param name="Usings">Namespace usings</param>
      <returns>Type generated</returns>
    </member>
    <member name="T:Utilities.DataTypes.CodeGen.Module.CompilerModule">
      <summary>
            Compiler module
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.CodeGen.Module.CompilerModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.DataTypes.CodeGen.Module.CompilerModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Comparison.GenericComparer`1">
      <summary>
            Generic IComparable class
            </summary>
      <typeparam name="T">Data type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Comparison.GenericComparer`1.Compare(`0,`0)">
      <summary>
            Compares the two objects
            </summary>
      <param name="x">Object 1</param>
      <param name="y">Object 2</param>
      <returns>0 if they're equal, any other value they are not</returns>
    </member>
    <member name="T:Utilities.DataTypes.Comparison.GenericEqualityComparer`1">
      <summary>
            Generic equality comparer
            </summary>
      <typeparam name="T">Data type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Comparison.GenericEqualityComparer`1.Equals(`0,`0)">
      <summary>
            Determines if the two items are equal
            </summary>
      <param name="x">Object 1</param>
      <param name="y">Object 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Comparison.GenericEqualityComparer`1.GetHashCode(`0)">
      <summary>
            Get hash code
            </summary>
      <param name="obj">Object to get the hash code of</param>
      <returns>The object's hash code</returns>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1">
      <summary>
            Type converter base class
            </summary>
      <typeparam name="T">Converter type</typeparam>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Converters.Interfaces.IConverter">
      <summary>
            Converter interface
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.Interfaces.IConverter.AssociatedType">
      <summary>
            Type that the converter is associated with
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
      <summary>
            Can convert from
            </summary>
      <param name="context">Context object</param>
      <param name="sourceType">Source type</param>
      <returns>True if it can convert from it, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
      <summary>
            Can convert to
            </summary>
      <param name="context">Context object</param>
      <param name="destinationType">Destination type</param>
      <returns>True if it can convert from it, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
      <summary>
            Convert from an object to a DbType
            </summary>
      <param name="context">Context object</param>
      <param name="culture">Culture info</param>
      <param name="value">Value</param>
      <returns>The DbType version</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
      <summary>
            Converts the DbType object to another type
            </summary>
      <param name="context">Context type</param>
      <param name="culture">Culture info</param>
      <param name="value" />
      <param name="destinationType" />
      <returns />
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1.AssociatedType">
      <summary>
            Associated type
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1.ConvertFromTypes">
      <summary>
            Types it can convert from and mapped functions
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1.ConvertToTypes">
      <summary>
            Types it can convert to and mapped functions
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.BaseClasses.TypeConverterBase`1.InternalConverter">
      <summary>
            Converter used internally if this can not convert the object
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Converters.DbTypeTypeConverter">
      <summary>
            DbType converter
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.DbTypeTypeConverter.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.DbTypeTypeConverter.InternalConverter">
      <summary>
            Internal converter
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Converters.SqlDbTypeTypeConverter">
      <summary>
            SqlDbType converter
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.SqlDbTypeTypeConverter.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.SqlDbTypeTypeConverter.Conversions">
      <summary>
            Conversions
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.SqlDbTypeTypeConverter.InternalConverter">
      <summary>
            Internal converter
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Manager">
      <summary>
            Conversion manager
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Manager.To``2(``0,``1)">
      <summary>
            Converts item from type T to R
            </summary>
      <typeparam name="T">Incoming type</typeparam>
      <typeparam name="R">Resulting type</typeparam>
      <param name="Item">Incoming object</param>
      <param name="DefaultValue">
            Default return value if the item is null or can not be converted
            </param>
      <returns>The value converted to the specified type</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Manager.To``1(``0,System.Type,System.Object)">
      <summary>
            Converts item from type T to R
            </summary>
      <typeparam name="T">Incoming type</typeparam>
      <param name="Item">Incoming object</param>
      <param name="ResultType">Result type</param>
      <param name="DefaultValue">
            Default return value if the item is null or can not be converted
            </param>
      <returns>The value converted to the specified type</returns>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Module.ConversionModule">
      <summary>
            Conversion module
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Module.ConversionModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Module.ConversionModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.BaseClasses.DataMapperBase">
      <summary>
            Data mapper base class
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Interfaces.IDataMapper">
      <summary>
            Data mapper interface
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.IDataMapper.Map``2">
      <summary>
            Adds or returns a mapping between two types
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.IDataMapper.Map(System.Type,System.Type)">
      <summary>
            Adds or returns a mapping between two types
            </summary>
      <param name="Left">Left type</param>
      <param name="Right">Right type</param>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.DataMapperBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.DataMapperBase.Map``2">
      <summary>
            Adds or returns a mapping between two types
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.DataMapperBase.Map(System.Type,System.Type)">
      <summary>
            Adds or returns a mapping between two types
            </summary>
      <param name="Left">Left type</param>
      <param name="Right">Right type</param>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.DataMapperBase.CreateTypeMapping``2">
      <summary>
            Used internally to create type mappings
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.DataMapperBase.CreateTypeMapping(System.Type,System.Type)">
      <summary>
            Used internally to create type mappings
            </summary>
      <param name="Left">Left type</param>
      <param name="Right">Right type</param>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="P:Utilities.DataTypes.DataMapper.BaseClasses.DataMapperBase.Mappings">
      <summary>
            Mappings
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.BaseClasses.MappingBase`2">
      <summary>
            Mapping base class
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Interfaces.IMapping`2">
      <summary>
            Mapping interface
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Interfaces.IMapping">
      <summary>
            Mapping interface
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.MappingBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2">
      <summary>
            Type mapping base class
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping`2">
      <summary>
            Type mapping interface
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping">
      <summary>
            Type mapping interface
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping.AutoMap">
      <summary>
            Automatically maps properties that are named the same thing
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping.Copy(System.Object,System.Object)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping`2.AddMapping(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightExpression">Right expression</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping`2.AddMapping(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set action</param>
      <param name="RightExpression">Right expression</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping`2.AddMapping(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping`2.AddMapping(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set function</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping`2.Copy(`0,`1)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping`2.Copy(`1,`0)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping`2.CopyLeftToRight(`0,`1)">
      <summary>
            Copies from the source to the destination (used in instances when both Left and Right
            are the same type and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source</param>
      <param name="Destination">Destination</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.ITypeMapping`2.CopyRightToLeft(`1,`0)">
      <summary>
            Copies from the source to the destination (used in instances when both Left and Right
            are the same type and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source</param>
      <param name="Destination">Destination</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.AddMapping(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightExpression">Right expression</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.AddMapping(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set action</param>
      <param name="RightExpression">Right expression</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.AddMapping(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.AddMapping(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set function</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.AutoMap">
      <summary>
            Automatically maps properties that are named the same thing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.Copy(System.Object,System.Object)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.Copy(`0,`1)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.Copy(`1,`0)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.CopyLeftToRight(`0,`1)">
      <summary>
            Copies from the source to the destination (used in instances when both Left and Right
            are the same type and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source</param>
      <param name="Destination">Destination</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.CopyRightToLeft(`1,`0)">
      <summary>
            Copies from the source to the destination (used in instances when both Left and Right
            are the same type and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source</param>
      <param name="Destination">Destination</param>
    </member>
    <member name="P:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.Mappings">
      <summary>
            List of mappings
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Default.DataMapper">
      <summary>
            Default data mapper
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.DataMapper.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.DataMapper.CreateTypeMapping``2">
      <summary>
            Used internally to create type mappings
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.DataMapper.CreateTypeMapping(System.Type,System.Type)">
      <summary>
            Used internally to create type mappings
            </summary>
      <param name="Left">Left type</param>
      <param name="Right">Right type</param>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Default.Mapping`2">
      <summary>
            Mapping class
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.Mapping`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Constructor
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightExpression">Right expression</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.Mapping`2.#ctor(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Constructor
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set action</param>
      <param name="RightExpression">Right expression</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.Mapping`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Constructor
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.Mapping`2.#ctor(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Constructor
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set function</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.Mapping`2.Copy(`0,`1)">
      <summary>
            Copies the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.Mapping`2.Copy(`1,`0)">
      <summary>
            Copies the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.Mapping`2.CopyLeftToRight(`0,`1)">
      <summary>
            Copies from the source to the destination (used in instances when both Left and Right
            are the same type and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.Mapping`2.CopyRightToLeft(`1,`0)">
      <summary>
            Copies from the source to the destination (used in instances when both Left and Right
            are the same type and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="P:Utilities.DataTypes.DataMapper.Default.Mapping`2.LeftGet">
      <summary>
            Left get function
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DataMapper.Default.Mapping`2.LeftSet">
      <summary>
            Left set function
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DataMapper.Default.Mapping`2.RightGet">
      <summary>
            Right get function
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DataMapper.Default.Mapping`2.RightSet">
      <summary>
            Right set function
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Default.TypeMapping`2">
      <summary>
            Type mapping default class
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.TypeMapping`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.TypeMapping`2.AddMapping(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightExpression">Right expression</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.TypeMapping`2.AddMapping(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set action</param>
      <param name="RightExpression">Right expression</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.TypeMapping`2.AddMapping(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.TypeMapping`2.AddMapping(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set function</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.TypeMapping`2.Copy(`0,`1)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.TypeMapping`2.Copy(`1,`0)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.TypeMapping`2.CopyLeftToRight(`0,`1)">
      <summary>
            Copies from the source to the destination (used in instances when both Left and Right
            are the same type and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source</param>
      <param name="Destination">Destination</param>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Default.TypeMapping`2.CopyRightToLeft(`1,`0)">
      <summary>
            Copies from the source to the destination (used in instances when both Left and Right
            are the same type and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source</param>
      <param name="Destination">Destination</param>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Interfaces.IMapperModule">
      <summary>
            Mapping interface
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Interfaces.IMapperModule.Map(Utilities.DataTypes.DataMapper.Manager)">
      <summary>
            Called when mapping various classes to one another
            </summary>
      <param name="Manager">Mapping manager class</param>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Manager">
      <summary>
            Data mapper manager
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Manager.Map``2">
      <summary>
            Adds or returns a mapping between two types
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Manager.Map(System.Type,System.Type)">
      <summary>
            Adds or returns a mapping between two types
            </summary>
      <param name="Left">Left type</param>
      <param name="Right">Right type</param>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="P:Utilities.DataTypes.DataMapper.Manager.DataMapper">
      <summary>
            Data mapper
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DataMapper.Module.DataMapperModule">
      <summary>
            Data mapper module
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.Module.DataMapperModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.DataTypes.DataMapper.Module.DataMapperModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DateSpan">
      <summary>
            Represents a date span
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.#ctor(System.DateTime,System.DateTime)">
      <summary>
            Constructor
            </summary>
      <param name="Start">Start of the date span</param>
      <param name="End">End of the date span</param>
      <requires description="Start is after End" exception="T:System.ArgumentException" csharp="Start &lt;= End" vb="Start &lt;= End ">Start &lt;= End</requires>
      <exception cref="T:System.ArgumentException">!Start &lt;= End</exception>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.Intersection(Utilities.DataTypes.DateSpan)">
      <summary>
            Returns the intersecting time span between the two values
            </summary>
      <param name="Span">Span to use</param>
      <returns>The intersection of the two time spans</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.Overlap(Utilities.DataTypes.DateSpan)">
      <summary>
            Determines if two DateSpans overlap
            </summary>
      <param name="Span">The span to compare to</param>
      <returns>True if they overlap, false otherwise</returns>
      <requires description="Span" exception="T:System.ArgumentNullException" csharp="Span != (Utilities.DataTypes.DateSpan)null" vb="Span &lt;&gt; ((Utilities.DataTypes.DateSpan)Nothing) ">Span != (Utilities.DataTypes.DateSpan)null</requires>
      <exception cref="T:System.ArgumentNullException">!Span != (Utilities.DataTypes.DateSpan)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.op_Implicit(Utilities.DataTypes.DateSpan)~System.String">
      <summary>
            Converts the object to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != (Utilities.DataTypes.DateSpan)null" vb="Value &lt;&gt; ((Utilities.DataTypes.DateSpan)Nothing) ">Value != (Utilities.DataTypes.DateSpan)null</requires>
      <exception cref="T:System.ArgumentNullException">!Value != (Utilities.DataTypes.DateSpan)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.op_Inequality(Utilities.DataTypes.DateSpan,Utilities.DataTypes.DateSpan)">
      <summary>
            Determines if two DateSpans are not equal
            </summary>
      <param name="Span1">Span 1</param>
      <param name="Span2">Span 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.op_Addition(Utilities.DataTypes.DateSpan,Utilities.DataTypes.DateSpan)">
      <summary>
            Addition operator
            </summary>
      <param name="Span1">Span 1</param>
      <param name="Span2">Span 2</param>
      <returns>The combined date span</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.op_Equality(Utilities.DataTypes.DateSpan,Utilities.DataTypes.DateSpan)">
      <summary>
            Determines if two DateSpans are equal
            </summary>
      <param name="Span1">Span 1</param>
      <param name="Span2">Span 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.Equals(System.Object)">
      <summary>
            Determines if two objects are equal
            </summary>
      <param name="obj">Object to check</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.GetHashCode">
      <summary>
            Gets the hash code for the date span
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.ToString">
      <summary>
            Converts the DateSpan to a string
            </summary>
      <returns>The DateSpan as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Days">
      <summary>
            Days between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.End">
      <summary>
            End date
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Hours">
      <summary>
            Hours between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.MilliSeconds">
      <summary>
            Milliseconds between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Minutes">
      <summary>
            Minutes between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Months">
      <summary>
            Months between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Seconds">
      <summary>
            Seconds between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Start">
      <summary>
            Start date
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Years">
      <summary>
            Years between the two dates
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Dynamic.BaseClasses.DynamoExtensionBase">
      <summary>
            Dynamo extension base class
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Dynamic.Interfaces.IDynamoExtension">
      <summary>
            Extension for adding functionality to the Dynamo object
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Dynamic.Interfaces.IDynamoExtension.Extend(Utilities.DataTypes.Dynamo)">
      <summary>
            Called when setting up/extending a dynamo object
            </summary>
      <param name="Object">Object to extend</param>
    </member>
    <member name="M:Utilities.DataTypes.Dynamic.BaseClasses.DynamoExtensionBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Dynamic.BaseClasses.DynamoExtensionBase.Extend(Utilities.DataTypes.Dynamo)">
      <summary>
            Extends the given dynamo object
            </summary>
      <param name="Object">Object to extend</param>
    </member>
    <member name="T:Utilities.Random.Dynamic.Randomization">
      <summary>
            Randomization extension
            </summary>
    </member>
    <member name="M:Utilities.Random.Dynamic.Randomization.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.Dynamic.Randomization.Extend(Utilities.DataTypes.Dynamo)">
      <summary>
            Extends the given dynamo object
            </summary>
      <param name="Object">Object to extend</param>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="new Utilities.Random.Dynamic.Randomization.&lt;&gt;c__DisplayClass3(){&#xD;&#xA;    Object = Object, &#xD;&#xA;}.Object != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Random.Dynamic.Randomization.&lt;&gt;c__DisplayClass3 local_2_prime = New Utilities.Random.Dynamic.Randomization.&lt;&gt;c__DisplayClass3();&#xD;&#xA;    (local_2_prime.Object = Object)&#xD;&#xA;    return local_2_prime; })().Object &lt;&gt; Nothing">new Utilities.Random.Dynamic.Randomization.&lt;&gt;c__DisplayClass3(){
    Object = Object, 
}.Object != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Random.Dynamic.Randomization.&lt;&gt;c__DisplayClass3(){
    Object = Object, 
}.Object == null</exception>
    </member>
    <member name="T:Utilities.DataTypes.Change">
      <summary>
            Change class
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Change.#ctor(System.Object,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="OriginalValue">Original value</param>
      <param name="NewValue">New value</param>
    </member>
    <member name="P:Utilities.DataTypes.Change.NewValue">
      <summary>
            New value
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Change.OriginalValue">
      <summary>
            Original value
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.BaseEventArgs">
      <summary>
            Base event args for the events used in the system
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.EventArgs.BaseEventArgs.Content">
      <summary>
            Content of the event
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.EventArgs.BaseEventArgs.Stop">
      <summary>
            Should the event be stopped?
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.ChangedEventArgs">
      <summary>
            Changed event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.DeletedEventArgs">
      <summary>
            Deleted event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.DeletingEventArgs">
      <summary>
            Deleting event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.LoadedEventArgs">
      <summary>
            Loaded event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.LoadingEventArgs">
      <summary>
            Loading event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.OnEndEventArgs">
      <summary>
            On end event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.OnErrorEventArgs">
      <summary>
            On error event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.OnStartEventArgs">
      <summary>
            On start event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.SavedEventArgs">
      <summary>
            Saved event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.SavingEventArgs">
      <summary>
            Saving event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ArrayExtensions">
      <summary>
            Array extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ArrayExtensions.Clear(System.Array)">
      <summary>
            Clears the array completely
            </summary>
      <param name="Array">Array to clear</param>
      <returns>The final array</returns>
    </member>
    <member name="M:Utilities.DataTypes.ArrayExtensions.Clear``1(``0[])">
      <summary>
            Clears the array completely
            </summary>
      <param name="Array">Array to clear</param>
      <typeparam name="ArrayType">Array type</typeparam>
      <returns>The final array</returns>
    </member>
    <member name="M:Utilities.DataTypes.ArrayExtensions.Concat``1(``0[],``0[][])">
      <summary>
            Combines two arrays and returns a new array containing both values
            </summary>
      <typeparam name="ArrayType">Type of the data in the array</typeparam>
      <param name="Array1">Array 1</param>
      <param name="Additions">Arrays to concat onto the first item</param>
      <returns>A new array containing both arrays' values</returns>
      <requires description="Array1" exception="T:System.ArgumentNullException" csharp="Array1 != null" vb="Array1 &lt;&gt; Nothing">Array1 != null</requires>
      <exception cref="T:System.ArgumentNullException">Array1 == null</exception>
      <requires description="Additions" exception="T:System.ArgumentNullException" csharp="Additions != null" vb="Additions &lt;&gt; Nothing">Additions != null</requires>
      <exception cref="T:System.ArgumentNullException">Additions == null</exception>
      <requires description="Additions" exception="T:System.ArgumentNullException" csharp="for all x in Additions x != null" vb="for all x in Additions x &lt;&gt; Nothing">for all x in Additions x != null</requires>
      <exception cref="T:System.ArgumentNullException">!System.Diagnostics.Contracts.Contract.ForAll&lt;ArrayType[]&gt;(Additions, (ArrayType[] x) =&gt; (x != null))</exception>
    </member>
    <member name="T:Utilities.DataTypes.CacheExtensions">
      <summary>
            Extension methods relating to caching of data
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.CacheExtensions.Cache(System.Object,System.String,System.String)">
      <summary>
            Cacnes the object based on the key and cache specified
            </summary>
      <param name="Object">Object to cache</param>
      <param name="Key">Cache key</param>
      <param name="Cache">Name of the cache to use</param>
    </member>
    <member name="M:Utilities.DataTypes.CacheExtensions.GetFromCache``1(System.String,``0,System.String)">
      <summary>
            Gets the specified object from the cache
            </summary>
      <typeparam name="T">Type to convert the object to</typeparam>
      <param name="Key">Key to the object</param>
      <param name="DefaultValue">Default value if the key is not found</param>
      <param name="Cache">Cache to get the item from</param>
      <returns>The object specified or the default value if it is not found</returns>
    </member>
    <member name="T:Utilities.DataTypes.DateTimeExtensions">
      <summary>
            DateTime extension methods
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.AddWeeks(System.DateTime,System.Int32)">
      <summary>
            Adds the number of weeks to the date
            </summary>
      <param name="Date">Date input</param>
      <param name="NumberOfWeeks">Number of weeks to add</param>
      <returns>The date after the number of weeks are added</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.Age(System.DateTime,System.DateTime)">
      <summary>
            Calculates age based on date supplied
            </summary>
      <param name="Date">Birth date</param>
      <param name="CalculateFrom">Date to calculate from</param>
      <returns>The total age in years</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.BeginningOf(System.DateTime,Utilities.DataTypes.TimeFrame,System.Globalization.CultureInfo)">
      <summary>
            Beginning of a specific time frame
            </summary>
      <param name="Date">Date to base off of</param>
      <param name="TimeFrame">Time frame to use</param>
      <param name="Culture">
            Culture to use for calculating (defaults to the current culture)
            </param>
      <returns>The beginning of a specific time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.BeginningOf(System.DateTime,Utilities.DataTypes.TimeFrame,System.DateTime,System.Globalization.CultureInfo)">
      <summary>
            Beginning of a specific time frame
            </summary>
      <param name="Date">Date to base off of</param>
      <param name="TimeFrame">Time frame to use</param>
      <param name="Culture">
            Culture to use for calculating (defaults to the current culture)
            </param>
      <param name="StartOfQuarter1">Start of the first quarter</param>
      <returns>The beginning of a specific time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.DaysIn(System.DateTime,Utilities.DataTypes.TimeFrame,System.Globalization.CultureInfo)">
      <summary>
            Gets the number of days in the time frame specified based on the date
            </summary>
      <param name="Date">Date</param>
      <param name="TimeFrame">Time frame to calculate the number of days from</param>
      <param name="Culture">
            Culture to use for calculating (defaults to the current culture)
            </param>
      <returns>The number of days in the time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.DaysIn(System.DateTime,Utilities.DataTypes.TimeFrame,System.DateTime,System.Globalization.CultureInfo)">
      <summary>
            Gets the number of days in the time frame specified based on the date
            </summary>
      <param name="Date">Date</param>
      <param name="TimeFrame">Time frame to calculate the number of days from</param>
      <param name="Culture">
            Culture to use for calculating (defaults to the current culture)
            </param>
      <param name="StartOfQuarter1">Start of the first quarter</param>
      <returns>The number of days in the time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.DaysLeftIn(System.DateTime,Utilities.DataTypes.TimeFrame,System.Globalization.CultureInfo)">
      <summary>
            Gets the number of days left in the time frame specified based on the date
            </summary>
      <param name="Date">Date</param>
      <param name="TimeFrame">Time frame to calculate the number of days left</param>
      <param name="Culture">
            Culture to use for calculating (defaults to the current culture)
            </param>
      <returns>The number of days left in the time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.DaysLeftIn(System.DateTime,Utilities.DataTypes.TimeFrame,System.DateTime,System.Globalization.CultureInfo)">
      <summary>
            Gets the number of days left in the time frame specified based on the date
            </summary>
      <param name="Date">Date</param>
      <param name="TimeFrame">Time frame to calculate the number of days left</param>
      <param name="Culture">
            Culture to use for calculating (defaults to the current culture)
            </param>
      <param name="StartOfQuarter1">Start of the first quarter</param>
      <returns>The number of days left in the time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.EndOf(System.DateTime,Utilities.DataTypes.TimeFrame,System.Globalization.CultureInfo)">
      <summary>
            End of a specific time frame
            </summary>
      <param name="Date">Date to base off of</param>
      <param name="TimeFrame">Time frame to use</param>
      <param name="Culture">
            Culture to use for calculating (defaults to the current culture)
            </param>
      <returns>
            The end of a specific time frame (TimeFrame.Day is the only one that sets the time to
            12: 59:59 PM, all else are the beginning of the day)
            </returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.EndOf(System.DateTime,Utilities.DataTypes.TimeFrame,System.DateTime,System.Globalization.CultureInfo)">
      <summary>
            End of a specific time frame
            </summary>
      <param name="Date">Date to base off of</param>
      <param name="TimeFrame">Time frame to use</param>
      <param name="Culture">
            Culture to use for calculating (defaults to the current culture)
            </param>
      <param name="StartOfQuarter1">Start of the first quarter</param>
      <returns>
            The end of a specific time frame (TimeFrame.Day is the only one that sets the time to
            12: 59:59 PM, all else are the beginning of the day)
            </returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.Is(System.DateTime,Utilities.DataTypes.DateCompare)">
      <summary>
            Determines if the date fulfills the comparison
            </summary>
      <param name="Date">Date to check</param>
      <param name="Comparison">
            Comparison type (can be combined, so you can do weekday in the future, etc)
            </param>
      <returns>True if it is, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.LocalTimeZone(System.DateTime)">
      <summary>
            Gets the local time zone
            </summary>
      <param name="Date">Date object</param>
      <returns>The local time zone</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.SetTime(System.DateTime,System.Int32,System.Int32,System.Int32)">
      <summary>
            Sets the time portion of a specific date
            </summary>
      <param name="Date">Date input</param>
      <param name="Hour">Hour to set</param>
      <param name="Minutes">Minutes to set</param>
      <param name="Seconds">Seconds to set</param>
      <returns>Sets the time portion of the specified date</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.SetTime(System.DateTime,System.TimeSpan)">
      <summary>
            Sets the time portion of a specific date
            </summary>
      <param name="Date">Date input</param>
      <param name="Time">Time to set</param>
      <returns>Sets the time portion of the specified date</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.To(System.DateTime,System.TimeZoneInfo)">
      <summary>
            Converts a DateTime to a specific time zone
            </summary>
      <param name="Date">DateTime to convert</param>
      <param name="TimeZone">Time zone to convert to</param>
      <returns>The converted DateTime</returns>
      <requires description="TimeZone" exception="T:System.ArgumentNullException" csharp="TimeZone != null" vb="TimeZone &lt;&gt; Nothing">TimeZone != null</requires>
      <exception cref="T:System.ArgumentNullException">TimeZone == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.To(System.DateTime,System.DateTime)">
      <summary>
            Returns the date in int format based on an Epoch (defaults to unix epoch of 1/1/1970)
            </summary>
      <param name="Date">Date to convert</param>
      <param name="Epoch">Epoch to use (defaults to unix epoch of 1/1/1970)</param>
      <returns>The date in Unix format</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.To(System.Int32,System.DateTime)">
      <summary>
            Returns the date in DateTime format based on an Epoch (defaults to unix epoch of 1/1/1970)
            </summary>
      <param name="Date">Date to convert</param>
      <param name="Epoch">Epoch to use (defaults to unix epoch of 1/1/1970)</param>
      <returns>The Unix Date in DateTime format</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.To(System.Int64,System.DateTime)">
      <summary>
            Returns the date in DateTime format based on an Epoch (defaults to unix epoch of 1/1/1970)
            </summary>
      <param name="Date">Date to convert</param>
      <param name="Epoch">Epoch to use (defaults to unix epoch of 1/1/1970)</param>
      <returns>The Unix Date in DateTime format</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.ToString(System.DateTime,System.DateTime)">
      <summary>
            Converts the DateTime object to string describing, relatively how long ago or how far in
            the future the input is based off of another DateTime object specified.
            ex:
            Input=March 21, 2013 Epoch=March 22, 2013 returns "1 day ago" Input=March 22, 2013
            Epoch=March 21, 2013 returns "1 day from now"
            </summary>
      <param name="Input">Input</param>
      <param name="Epoch">DateTime object that the input is comparred to</param>
      <returns>The difference between the input and epoch expressed as a string</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateTimeExtensions.UTCOffset(System.DateTime)">
      <summary>
            Gets the UTC offset
            </summary>
      <param name="Date">Date to get the offset of</param>
      <returns>UTC offset</returns>
    </member>
    <member name="T:Utilities.DataTypes.DateCompare">
      <summary>
            Date comparison type
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.DateCompare.InFuture">
      <summary>
            In the future
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.DateCompare.InPast">
      <summary>
            In the past
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.DateCompare.Today">
      <summary>
            Today
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.DateCompare.WeekDay">
      <summary>
            Weekday
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.DateCompare.WeekEnd">
      <summary>
            Weekend
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.TimeFrame">
      <summary>
            Time frame
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.TimeFrame.Day">
      <summary>
            Day
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.TimeFrame.Week">
      <summary>
            Week
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.TimeFrame.Month">
      <summary>
            Month
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.TimeFrame.Quarter">
      <summary>
            Quarter
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.TimeFrame.Year">
      <summary>
            Year
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.DelegateExtensions">
      <summary>
            Extensions for Func, Action, and EventHandler
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DelegateExtensions.Async(System.Action)">
      <summary>
            Runs an action async
            </summary>
      <param name="Action">Action to run</param>
    </member>
    <member name="M:Utilities.DataTypes.DelegateExtensions.Raise``1(System.Action{``0},``0)">
      <summary>
            Safely calls the specified action
            </summary>
      <typeparam name="T">The type of the event args</typeparam>
      <param name="Delegate">The delegate</param>
      <param name="EventArgs">The event args</param>
    </member>
    <member name="M:Utilities.DataTypes.DelegateExtensions.Raise``1(System.EventHandler{``0},System.Object,``0)">
      <summary>
            Safely raises the event
            </summary>
      <typeparam name="T">The type of the event args</typeparam>
      <param name="Delegate">The delegate</param>
      <param name="Sender">The sender</param>
      <param name="EventArg">The event args</param>
    </member>
    <member name="M:Utilities.DataTypes.DelegateExtensions.Raise``2(System.Func{``0,``1},``0)">
      <summary>
            Safely calls the Func
            </summary>
      <typeparam name="T1">The event arg type</typeparam>
      <typeparam name="T2">The return type</typeparam>
      <param name="Delegate">The delegate</param>
      <param name="EventArgs">The event args</param>
      <returns>The value returned by the function</returns>
    </member>
    <member name="T:Utilities.DataTypes.ExceptionExtensions">
      <summary>
            Class for housing exception specific extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExceptionExtensions.ToString(System.Exception,System.String,System.String)">
      <summary>
            Converts the exception to a string and appends the specified prefix/suffix (used for logging)
            </summary>
      <param name="Exception">Exception to convert</param>
      <param name="Prefix">Prefix</param>
      <param name="Suffix">Suffix</param>
      <returns>The exception as a string</returns>
    </member>
    <member name="T:Utilities.DataTypes.GenericObjectExtensions">
      <summary>
            Generic extensions dealing with objects
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Chain``1(``0,System.Action{``0},``0)">
      <summary>
            Allows actions to be chained together with the caveat that if Object is null, it is
            replaced with the DefaultObjectValue specified. If the Action or Object (once replaced
            with the default object value) is null, it will return the object.
            </summary>
      <typeparam name="T">The type of the object</typeparam>
      <param name="Object">Object to run the action on</param>
      <param name="Action">Action to run</param>
      <param name="DefaultObjectValue">Default object value</param>
      <returns>The original object</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Chain``2(``0,System.Func{``0,``1},``1,``0)">
      <summary>
            Allows actions to be chained together. It also has a couple of checks in there:
            1) If the function is null, it returns the default return value specified.
            2) If the object is null, it will replace it with the default object value specified.
            3) If the object, once replaced with the default object value specified, is null, it
               will return the default return value specified.
            4) If the return value from the function is null, it returns the default return value specified.
            </summary>
      <typeparam name="T">The type of the object</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="Object">Object to run the action on</param>
      <param name="Function">Function to run</param>
      <param name="DefaultObjectValue">Default object value</param>
      <param name="DefaultReturnValue">Default return value</param>
      <returns>The result from the function</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Execute``1(System.Func{``0},System.Int32,System.Int32,System.Int32)">
      <summary>
            Executes a function, repeating it a number of times in case it fails
            </summary>
      <typeparam name="T">Return type</typeparam>
      <param name="Function">Function to run</param>
      <param name="Attempts">Number of times to attempt it</param>
      <param name="RetryDelay">The amount of milliseconds to wait between tries</param>
      <param name="TimeOut">
            Max amount of time to wait for the function to run (waits for the current attempt to
            finish before checking)
            </param>
      <returns>The returned value from the function</returns>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Execute(System.Action,System.Int32,System.Int32,System.Int32)">
      <summary>
            Executes an action, repeating it a number of times in case it fails
            </summary>
      <param name="Action">Action to run</param>
      <param name="Attempts">Number of times to attempt it</param>
      <param name="RetryDelay">The amount of milliseconds to wait between tries</param>
      <param name="TimeOut">
            Max amount of time to wait for the function to run (waits for the current attempt to
            finish before checking)
            </param>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Check``1(``0,System.Predicate{``0},``0)">
      <summary>
            Checks to see if the object meets all the criteria. If it does, it returns the object.
            If it does not, it returns the default object
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to check</param>
      <param name="DefaultValue">The default value to return</param>
      <param name="Predicate">Predicate to check the object against</param>
      <returns>The default object if it fails the criteria, the object otherwise</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Check``1(``0,System.Predicate{``0},System.Func{``0})">
      <summary>
            Checks to see if the object meets all the criteria. If it does, it returns the object.
            If it does not, it returns the default object
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to check</param>
      <param name="DefaultValue">The default value to return</param>
      <param name="Predicate">Predicate to check the object against</param>
      <returns>The default object if it fails the criteria, the object otherwise</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
      <requires description="DefaultValue" exception="T:System.ArgumentNullException" csharp="DefaultValue != null" vb="DefaultValue &lt;&gt; Nothing">DefaultValue != null</requires>
      <exception cref="T:System.ArgumentNullException">DefaultValue == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Check``1(``0,``0)">
      <summary>
            Checks to see if the object is null. If it is, it returns the default object, otherwise
            the object is returned.
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to check</param>
      <param name="DefaultValue">The default value to return</param>
      <returns>The default object if it is null, the object otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Check``1(``0,System.Func{``0})">
      <summary>
            Checks to see if the object is null. If it is, it returns the default object, otherwise
            the object is returned.
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to check</param>
      <param name="DefaultValue">The default value to return</param>
      <returns>The default object if it is null, the object otherwise</returns>
      <requires description="DefaultValue" exception="T:System.ArgumentNullException" csharp="DefaultValue != null" vb="DefaultValue &lt;&gt; Nothing">DefaultValue != null</requires>
      <exception cref="T:System.ArgumentNullException">DefaultValue == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Is``1(``0,System.Predicate{``0})">
      <summary>
            Determines if the object passes the predicate passed in
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to test</param>
      <param name="Predicate">Predicate to test</param>
      <returns>True if the object passes the predicate, false otherwise</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Is``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is equal to a specific value
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to test</param>
      <param name="ComparisonObject">Comparison object</param>
      <param name="Comparer">Comparer</param>
      <returns>True if the object passes the predicate, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIf``1(``0,System.Predicate{``0},System.Func{System.Exception})">
      <summary>
            Throws the specified exception if the predicate is true for the item
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIf``1(``0,System.Predicate{``0},System.Exception)">
      <summary>
            Throws the specified exception if the predicate is true for the item
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfDefault``1(``0,System.String,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is equal to default value and throws an ArgumentNullException
            if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="EqualityComparer">
            Equality comparer used to determine if the object is equal to default
            </param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfDefault``1(``0,System.Exception,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is equal to default value and throws the exception that is
            passed in if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="EqualityComparer">
            Equality comparer used to determine if the object is equal to default
            </param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNotDefault``1(``0,System.String,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is not equal to default value and throws an ArgumentException
            if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="EqualityComparer">
            Equality comparer used to determine if the object is equal to default
            </param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNotDefault``1(``0,System.Exception,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is not equal to default value and throws the exception that is
            passed in if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="EqualityComparer">
            Equality comparer used to determine if the object is equal to default
            </param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNot``1(``0,System.Predicate{``0},System.Exception)">
      <summary>
            Throws the specified exception if the predicate is false for the item
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is false</param>
      <returns>the original Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNotNull``1(``0,System.String)">
      <summary>
            Determines if the object is not null and throws an ArgumentException if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNotNull``1(``0,System.Exception)">
      <summary>
            Determines if the object is not null and throws the exception passed in if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNull``1(``0,System.String)">
      <summary>
            Determines if the object is null and throws an ArgumentNullException if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNull``1(``0,System.Exception)">
      <summary>
            Determines if the object is null and throws the exception passed in if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNotNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Determines if the IEnumerable is not null or empty and throws an ArgumentException if it is
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The object to check</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNotNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Exception)">
      <summary>
            Determines if the IEnumerable is not null or empty and throws the exception passed in if
            it is
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The object to check</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Determines if the IEnumerable is null or empty and throws an ArgumentNullException if it is
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The object to check</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.ThrowIfNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Exception)">
      <summary>
            Determines if the IEnumerable is null or empty and throws the exception passed in if it is
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The object to check</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Times``1(System.Int32,System.Func{System.Int32,``0})">
      <summary>
            Runs a function based on the number of times specified and returns the results
            </summary>
      <typeparam name="T">Type that gets returned</typeparam>
      <param name="Count">Number of times the function should run</param>
      <param name="Function">The function that should run</param>
      <returns>The results from the function</returns>
    </member>
    <member name="M:Utilities.DataTypes.GenericObjectExtensions.Times(System.Int32,System.Action{System.Int32})">
      <summary>
            Runs an action based on the number of times specified
            </summary>
      <param name="Count">Number of times to run the action</param>
      <param name="Action">Action to run</param>
    </member>
    <member name="T:Utilities.DataTypes.ICollectionExtensions">
      <summary>
            ICollection extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.Add``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds a list of items to the collection
            </summary>
      <typeparam name="T">The type of the items in the collection</typeparam>
      <param name="Collection">Collection</param>
      <param name="Items">Items to add</param>
      <returns>The collection with the added items</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){&#xD;&#xA;    Collection = Collection, &#xD;&#xA;}.Collection != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt; local_0_prime = New Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass1(Of T)();&#xD;&#xA;    (local_0_prime.Collection = Collection)&#xD;&#xA;    return local_0_prime; })().Collection &lt;&gt; Nothing">new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){
    Collection = Collection, 
}.Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){
    Collection = Collection, 
}.Collection == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.Add``1(System.Collections.Generic.ICollection{``0},``0[])">
      <summary>
            Adds a list of items to the collection
            </summary>
      <typeparam name="T">The type of the items in the collection</typeparam>
      <param name="Collection">Collection</param>
      <param name="Items">Items to add</param>
      <returns>The collection with the added items</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){&#xD;&#xA;    Collection = Collection, &#xD;&#xA;}.Collection != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt; local_0_prime = New Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass4(Of T)();&#xD;&#xA;    (local_0_prime.Collection = Collection)&#xD;&#xA;    return local_0_prime; })().Collection &lt;&gt; Nothing">new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){
    Collection = Collection, 
}.Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){
    Collection = Collection, 
}.Collection == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.AddAndReturn``1(System.Collections.Generic.ICollection{``0},``0)">
      <summary>
            Adds an item to a list and returns the item
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Item">Item to add to the collection</param>
      <returns>The original item</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="Collection != null" vb="Collection &lt;&gt; Nothing">Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">Collection == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.AddIf``1(System.Collections.Generic.ICollection{``0},System.Predicate{``0},``0[])">
      <summary>
            Adds items to the collection if it passes the predicate test
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <param name="Predicate">
            Predicate that an item needs to satisfy in order to be added
            </param>
      <returns>True if any are added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="Collection != null" vb="Collection &lt;&gt; Nothing">Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">Collection == null</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.AddIf``1(System.Collections.Generic.ICollection{``0},System.Predicate{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds an item to the collection if it isn't already in the collection
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <param name="Predicate">
            Predicate that an item needs to satisfy in order to be added
            </param>
      <returns>True if it is added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="Collection != null" vb="Collection &lt;&gt; Nothing">Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">Collection == null</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.AddIfUnique``1(System.Collections.Generic.ICollection{``0},``0[])">
      <summary>
            Adds an item to the collection if it isn't already in the collection
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <returns>True if it is added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){&#xD;&#xA;    Collection = Collection, &#xD;&#xA;}.Collection != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt; local_0_prime = New Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass7(Of T)();&#xD;&#xA;    (local_0_prime.Collection = Collection)&#xD;&#xA;    return local_0_prime; })().Collection &lt;&gt; Nothing">new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){
    Collection = Collection, 
}.Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){
    Collection = Collection, 
}.Collection == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.AddIfUnique``1(System.Collections.Generic.ICollection{``0},System.Func{``0,``0,System.Boolean},``0[])">
      <summary>
            Adds an item to the collection if it isn't already in the collection
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <param name="Predicate">
            Predicate used to determine if two values are equal. Return true if they are the same,
            false otherwise
            </param>
      <returns>True if it is added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClassb&lt;T&gt; local_0 = new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClassb&lt;T&gt;();&#xD;&#xA;        local_0.Collection = Collection;&#xD;&#xA;        local_0.Predicate = Predicate;&#xD;&#xA;    }&#xD;&#xA;    return local_0.Collection != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClassb&lt;T&gt; local_0 = New Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClassb(Of T)();&#xD;&#xA;    local_0.Collection = Collection&#xD;&#xA;    local_0.Predicate = Predicate&#xD;&#xA;    return local_0.Collection &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClassb&lt;T&gt; local_0 = new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClassb&lt;T&gt;();
        local_0.Collection = Collection;
        local_0.Predicate = Predicate;
    }
    return local_0.Collection != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClassb&lt;T&gt; local_0 = new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClassb&lt;T&gt;();
        (local_0.Collection = Collection);
        (local_0.Predicate = Predicate);
    }
    return (local_0.Collection != null); })()</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="local_0.Predicate != null" vb="local_0.Predicate &lt;&gt; Nothing">local_0.Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.AddIfUnique``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds an item to the collection if it isn't already in the collection
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <returns>True if it is added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass10&lt;T&gt;(){&#xD;&#xA;    Collection = Collection, &#xD;&#xA;}.Collection != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass10&lt;T&gt; local_0_prime = New Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass10(Of T)();&#xD;&#xA;    (local_0_prime.Collection = Collection)&#xD;&#xA;    return local_0_prime; })().Collection &lt;&gt; Nothing">new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass10&lt;T&gt;(){
    Collection = Collection, 
}.Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass10&lt;T&gt;(){
    Collection = Collection, 
}.Collection == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.AddIfUnique``1(System.Collections.Generic.ICollection{``0},System.Func{``0,``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds an item to the collection if it isn't already in the collection
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <param name="Predicate">
            Predicate used to determine if two values are equal. Return true if they are the same,
            false otherwise
            </param>
      <returns>True if it is added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass14&lt;T&gt; local_0 = new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass14&lt;T&gt;();&#xD;&#xA;        local_0.Collection = Collection;&#xD;&#xA;        local_0.Predicate = Predicate;&#xD;&#xA;    }&#xD;&#xA;    return local_0.Collection != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass14&lt;T&gt; local_0 = New Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass14(Of T)();&#xD;&#xA;    local_0.Collection = Collection&#xD;&#xA;    local_0.Predicate = Predicate&#xD;&#xA;    return local_0.Collection &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass14&lt;T&gt; local_0 = new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass14&lt;T&gt;();
        local_0.Collection = Collection;
        local_0.Predicate = Predicate;
    }
    return local_0.Collection != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass14&lt;T&gt; local_0 = new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass14&lt;T&gt;();
        (local_0.Collection = Collection);
        (local_0.Predicate = Predicate);
    }
    return (local_0.Collection != null); })()</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="local_0.Predicate != null" vb="local_0.Predicate &lt;&gt; Nothing">local_0.Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.Remove``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
      <summary>
            Removes all items that fit the predicate passed in
            </summary>
      <typeparam name="T">The type of the items in the collection</typeparam>
      <param name="Collection">Collection to remove items from</param>
      <param name="Predicate">Predicate used to determine what items to remove</param>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass19&lt;T&gt;().Predicate = Predicate;&#xD;&#xA;    }&#xD;&#xA;    return Collection != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass19(Of T)().Predicate = Predicate&#xD;&#xA;    return Collection &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass19&lt;T&gt;().Predicate = Predicate;
    }
    return Collection != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass19&lt;T&gt;().Predicate = Predicate);
    }
    return (Collection != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ICollectionExtensions.Remove``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Removes all items in the list from the collection
            </summary>
      <typeparam name="T">The type of the items in the collection</typeparam>
      <param name="Collection">Collection</param>
      <param name="Items">Items to remove</param>
      <returns>The collection with the items removed</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass1c&lt;T&gt;().Items = Items;&#xD;&#xA;    }&#xD;&#xA;    return Collection != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass1c(Of T)().Items = Items&#xD;&#xA;    return Collection &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass1c&lt;T&gt;().Items = Items;
    }
    return Collection != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ICollectionExtensions.&lt;&gt;c__DisplayClass1c&lt;T&gt;().Items = Items);
    }
    return (Collection != null); })()</exception>
    </member>
    <member name="T:Utilities.DataTypes.IComparableExtensions">
      <summary>
            IComparable extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.IComparableExtensions.Between``1(``0,``0,``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Checks if an item is between two values
            </summary>
      <typeparam name="T">Type of the value</typeparam>
      <param name="Value">Value to check</param>
      <param name="Min">Minimum value</param>
      <param name="Max">Maximum value</param>
      <param name="Comparer">
            Comparer used to compare the values (defaults to GenericComparer)"
            </param>
      <returns>True if it is between the values, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.IComparableExtensions.Clamp``1(``0,``0,``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Clamps a value between two values
            </summary>
      <param name="Value">Value sent in</param>
      <param name="Max">Max value it can be (inclusive)</param>
      <param name="Min">Min value it can be (inclusive)</param>
      <param name="Comparer">Comparer to use (defaults to GenericComparer)</param>
      <returns>The value set between Min and Max</returns>
    </member>
    <member name="M:Utilities.DataTypes.IComparableExtensions.Max``1(``0,``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns the maximum value between the two
            </summary>
      <param name="InputA">Input A</param>
      <param name="InputB">Input B</param>
      <param name="Comparer">Comparer to use (defaults to GenericComparer)</param>
      <returns>The maximum value</returns>
    </member>
    <member name="M:Utilities.DataTypes.IComparableExtensions.Min``1(``0,``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns the minimum value between the two
            </summary>
      <param name="InputA">Input A</param>
      <param name="InputB">Input B</param>
      <param name="Comparer">Comparer to use (defaults to GenericComparer)</param>
      <returns>The minimum value</returns>
    </member>
    <member name="T:Utilities.DataTypes.IDictionaryExtensions">
      <summary>
            IDictionary extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.IDictionaryExtensions.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Gets the value from a dictionary or the default value if it isn't found
            </summary>
      <typeparam name="TKey">Key type</typeparam>
      <typeparam name="TValue">Value type</typeparam>
      <param name="Dictionary">Dictionary to get the value from</param>
      <param name="Key">Key to look for</param>
      <param name="Default">Default value if the key is not found</param>
      <returns>
            The value associated with the key or the default value if the key is not found
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown if the dictionary is null</exception>
      <requires description="Dictionary" exception="T:System.ArgumentNullException" csharp="Dictionary != null" vb="Dictionary &lt;&gt; Nothing">Dictionary != null</requires>
      <exception cref="T:System.ArgumentNullException">Dictionary == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IDictionaryExtensions.SetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Sets the value in a dictionary
            </summary>
      <typeparam name="TKey">Key type</typeparam>
      <typeparam name="TValue">Value type</typeparam>
      <param name="Dictionary">Dictionary to set the value in</param>
      <param name="Key">Key to look for</param>
      <param name="Value">Value to add</param>
      <returns>The dictionary</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if the dictionary is null</exception>
      <requires description="Dictionary" exception="T:System.ArgumentNullException" csharp="Dictionary != null" vb="Dictionary &lt;&gt; Nothing">Dictionary != null</requires>
      <exception cref="T:System.ArgumentNullException">Dictionary == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IDictionaryExtensions.Sort``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IComparer{``0})">
      <summary>
            Sorts a dictionary
            </summary>
      <typeparam name="T1">Key type</typeparam>
      <typeparam name="T2">Value type</typeparam>
      <param name="Dictionary">Dictionary to sort</param>
      <param name="Comparer">Comparer used to sort (defaults to GenericComparer)</param>
      <returns>The sorted dictionary</returns>
      <requires description="Dictionary" exception="T:System.ArgumentNullException" csharp="Dictionary != null" vb="Dictionary &lt;&gt; Nothing">Dictionary != null</requires>
      <exception cref="T:System.ArgumentNullException">Dictionary == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IDictionaryExtensions.Sort``3(System.Collections.Generic.IDictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},``2},System.Collections.Generic.IComparer{``2})">
      <summary>
            Sorts a dictionary
            </summary>
      <typeparam name="T1">Key type</typeparam>
      <typeparam name="T2">Value type</typeparam>
      <typeparam name="T3">Order by type</typeparam>
      <param name="Dictionary">Dictionary to sort</param>
      <param name="OrderBy">Function used to order the dictionary</param>
      <param name="Comparer">Comparer used to sort (defaults to GenericComparer)</param>
      <returns>The sorted dictionary</returns>
      <requires description="Dictionary" exception="T:System.ArgumentNullException" csharp="Dictionary != null" vb="Dictionary &lt;&gt; Nothing">Dictionary != null</requires>
      <exception cref="T:System.ArgumentNullException">Dictionary == null</exception>
      <requires description="OrderBy" exception="T:System.ArgumentNullException" csharp="OrderBy != null" vb="OrderBy &lt;&gt; Nothing">OrderBy != null</requires>
      <exception cref="T:System.ArgumentNullException">OrderBy == null</exception>
    </member>
    <member name="T:Utilities.DataTypes.IEnumerableExtensions">
      <summary>
            IEnumerable extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Combines multiple IEnumerables together and returns a new IEnumerable containing all of
            the values
            </summary>
      <typeparam name="T">Type of the data in the IEnumerable</typeparam>
      <param name="Enumerable1">IEnumerable 1</param>
      <param name="Additions">IEnumerables to concat onto the first item</param>
      <returns>A new IEnumerable containing all values</returns>
      <example>
        <code>int[] TestObject1 = new int[] { 1, 2, 3 }; int[] TestObject2 = new int[] { 4, 5, 6
            }; int[] TestObject3 = new int[] { 7, 8, 9 }; TestObject1 =
            TestObject1.Concat(TestObject2, TestObject3).ToArray();</code>
      </example>
      <requires description="Enumerable1" exception="T:System.ArgumentNullException" csharp="Enumerable1 != null" vb="Enumerable1 &lt;&gt; Nothing">Enumerable1 != null</requires>
      <exception cref="T:System.ArgumentNullException">Enumerable1 == null</exception>
      <requires description="Additions" exception="T:System.ArgumentNullException" csharp="Additions != null" vb="Additions &lt;&gt; Nothing">Additions != null</requires>
      <exception cref="T:System.ArgumentNullException">Additions == null</exception>
      <requires description="Additions" exception="T:System.ArgumentNullException" csharp="for all x in Additions x != null" vb="for all x in Additions x &lt;&gt; Nothing">for all x in Additions x != null</requires>
      <exception cref="T:System.ArgumentNullException">!System.Diagnostics.Contracts.Contract.ForAll&lt;System.Collections.Generic.IEnumerable&lt;T&gt;&gt;(Additions, (System.Collections.Generic.IEnumerable&lt;T&gt; x) =&gt; (x != null))</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
      <summary>
            Returns only distinct items from the IEnumerable based on the predicate
            </summary>
      <typeparam name="T">Object type within the list</typeparam>
      <param name="Enumerable">List of objects</param>
      <param name="Predicate">
            Predicate that is used to determine if two objects are equal. True if they are the same,
            false otherwise
            </param>
      <returns>An IEnumerable of only the distinct items</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
      <requires description="Enumerable" exception="T:System.ArgumentNullException" csharp="Enumerable != null" vb="Enumerable &lt;&gt; Nothing">Enumerable != null</requires>
      <exception cref="T:System.ArgumentNullException">Enumerable == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ElementsBetween``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
      <summary>
            Returns elements starting at the index and ending at the end index
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">List to search</param>
      <param name="Start">Start index (inclusive)</param>
      <param name="End">End index (exclusive)</param>
      <returns>The items between the start and end index</returns>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.For``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Action{``0})">
      <summary>
            Does an action for each item in the IEnumerable between the start and end indexes
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Start">Item to start with</param>
      <param name="End">Item to end with</param>
      <param name="Action">Action to do</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
      <requires description="End must be greater than start" exception="T:System.ArgumentException" csharp="End + 1 - Start &gt;= 0" vb="End + 1 - Start &gt;= 0">End + 1 - Start &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">End + 1 - Start &lt; 0</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.For``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Func{``0,``1})">
      <summary>
            Does a function for each item in the IEnumerable between the start and end indexes and
            returns an IEnumerable of the results
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Start">Item to start with</param>
      <param name="End">Item to end with</param>
      <param name="Function">Function to do</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
      <requires description="End must be greater than start" exception="T:System.ArgumentException" csharp="End + 1 - Start &gt;= 0" vb="End + 1 - Start &gt;= 0">End + 1 - Start &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">End + 1 - Start &lt; 0</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Does an action for each item in the IEnumerable
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Action">Action to do</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Does a function for each item in the IEnumerable, returning a list of the results
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Function">Function to do</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{``0,System.Exception})">
      <summary>
            Does an action for each item in the IEnumerable
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Action">Action to do</param>
      <param name="CatchAction">Action that occurs if an exception occurs</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
      <requires description="CatchAction" exception="T:System.ArgumentNullException" csharp="CatchAction != null" vb="CatchAction &lt;&gt; Nothing">CatchAction != null</requires>
      <exception cref="T:System.ArgumentNullException">CatchAction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Action{``0,System.Exception})">
      <summary>
            Does a function for each item in the IEnumerable, returning a list of the results
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Function">Function to do</param>
      <param name="CatchAction">Action that occurs if an exception occurs</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
      <requires description="CatchAction" exception="T:System.ArgumentNullException" csharp="CatchAction != null" vb="CatchAction &lt;&gt; Nothing">CatchAction != null</requires>
      <exception cref="T:System.ArgumentNullException">CatchAction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForParallel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Action{``0})">
      <summary>
            Does an action for each item in the IEnumerable between the start and end indexes in parallel
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Start">Item to start with</param>
      <param name="End">Item to end with</param>
      <param name="Action">Action to do</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt;();&#xD;&#xA;        local_0.List = List;&#xD;&#xA;        local_0.Action = Action;&#xD;&#xA;    }&#xD;&#xA;    return local_0.List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt; local_0 = New Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass2(Of T)();&#xD;&#xA;    local_0.List = List&#xD;&#xA;    local_0.Action = Action&#xD;&#xA;    return local_0.List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt;();
        local_0.List = List;
        local_0.Action = Action;
    }
    return local_0.List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt;();
        (local_0.List = List);
        (local_0.Action = Action);
    }
    return (local_0.List != null); })()</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="local_0.Action != null" vb="local_0.Action &lt;&gt; Nothing">local_0.Action != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Action == null</exception>
      <requires description="End must be greater than start" exception="T:System.ArgumentException" csharp="End + 1 - Start &gt;= 0" vb="End + 1 - Start &gt;= 0">End + 1 - Start &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">End + 1 - Start &lt; 0</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForParallel``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Func{``0,``1})">
      <summary>
            Does an action for each item in the IEnumerable between the start and end indexes in parallel
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Results type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Start">Item to start with</param>
      <param name="End">Item to end with</param>
      <param name="Function">Function to do</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt;();&#xD;&#xA;        local_0.List = List;&#xD;&#xA;        local_0.Start = Start;&#xD;&#xA;        local_0.Function = Function;&#xD;&#xA;    }&#xD;&#xA;    return local_0.List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt; local_0 = New Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass5(Of T, R)();&#xD;&#xA;    local_0.List = List&#xD;&#xA;    local_0.Start = Start&#xD;&#xA;    local_0.Function = Function&#xD;&#xA;    return local_0.List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt;();
        local_0.List = List;
        local_0.Start = Start;
        local_0.Function = Function;
    }
    return local_0.List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt;();
        (local_0.List = List);
        (local_0.Start = Start);
        (local_0.Function = Function);
    }
    return (local_0.List != null); })()</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="local_0.Function != null" vb="local_0.Function &lt;&gt; Nothing">local_0.Function != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Function == null</exception>
      <requires description="End must be greater than start" exception="T:System.ArgumentException" csharp="End + 1 - local_0.Start &gt;= 0" vb="End + 1 - local_0.Start &gt;= 0">End + 1 - local_0.Start &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">End + 1 - local_0.Start &lt; 0</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForEachParallel``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Does an action for each item in the IEnumerable in parallel
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Action">Action to do</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForEachParallel``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Does an action for each item in the IEnumerable in parallel
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Results type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Function">Function to do</param>
      <returns>The results in an IEnumerable list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForEachParallel``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{``0,System.Exception})">
      <summary>
            Does an action for each item in the IEnumerable
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Action">Action to do</param>
      <param name="CatchAction">Action that occurs if an exception occurs</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt;();&#xD;&#xA;        local_0.Action = Action;&#xD;&#xA;        local_0.CatchAction = CatchAction;&#xD;&#xA;    }&#xD;&#xA;    return List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt; local_0 = New Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass8(Of T)();&#xD;&#xA;    local_0.Action = Action&#xD;&#xA;    local_0.CatchAction = CatchAction&#xD;&#xA;    return List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt;();
        local_0.Action = Action;
        local_0.CatchAction = CatchAction;
    }
    return List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt;();
        (local_0.Action = Action);
        (local_0.CatchAction = CatchAction);
    }
    return (List != null); })()</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="local_0.Action != null" vb="local_0.Action &lt;&gt; Nothing">local_0.Action != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Action == null</exception>
      <requires description="CatchAction" exception="T:System.ArgumentNullException" csharp="local_0.CatchAction != null" vb="local_0.CatchAction &lt;&gt; Nothing">local_0.CatchAction != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.CatchAction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ForEachParallel``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Action{``0,System.Exception})">
      <summary>
            Does a function for each item in the IEnumerable, returning a list of the results
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Function">Function to do</param>
      <param name="CatchAction">Action that occurs if an exception occurs</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt;();&#xD;&#xA;        local_0.Function = Function;&#xD;&#xA;        local_0.CatchAction = CatchAction;&#xD;&#xA;    }&#xD;&#xA;    return List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt; local_0 = New Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassb(Of T, R)();&#xD;&#xA;    local_0.Function = Function&#xD;&#xA;    local_0.CatchAction = CatchAction&#xD;&#xA;    return List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt;();
        local_0.Function = Function;
        local_0.CatchAction = CatchAction;
    }
    return List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt;();
        (local_0.Function = Function);
        (local_0.CatchAction = CatchAction);
    }
    return (List != null); })()</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="local_0.Function != null" vb="local_0.Function &lt;&gt; Nothing">local_0.Function != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Function == null</exception>
      <requires description="CatchAction" exception="T:System.ArgumentNullException" csharp="local_0.CatchAction != null" vb="local_0.CatchAction &lt;&gt; Nothing">local_0.CatchAction != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.CatchAction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.Last``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            Returns the last X number of items from the list
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Count">Numbers of items to return</param>
      <returns>The last X items from the list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.PositionOf``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines the position of an object if it is present, otherwise it returns -1
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">List of objects to search</param>
      <param name="Object">Object to find the position of</param>
      <param name="EqualityComparer">
            Equality comparer used to determine if the object is present
            </param>
      <returns>The position of the object if it is present, otherwise -1</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.Remove``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Removes values from a list that meet the criteria set forth by the predicate
            </summary>
      <typeparam name="T">Value type</typeparam>
      <param name="Value">List to cull items from</param>
      <param name="Predicate">Predicate that determines what items to remove</param>
      <returns>An IEnumerable with the objects that meet the criteria removed</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassf&lt;T&gt;(){&#xD;&#xA;    Predicate = Predicate, &#xD;&#xA;}.Predicate != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassf&lt;T&gt; local_0_prime = New Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassf(Of T)();&#xD;&#xA;    (local_0_prime.Predicate = Predicate)&#xD;&#xA;    return local_0_prime; })().Predicate &lt;&gt; Nothing">new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassf&lt;T&gt;(){
    Predicate = Predicate, 
}.Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClassf&lt;T&gt;(){
    Predicate = Predicate, 
}.Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Converts a list to an array
            </summary>
      <typeparam name="Source">Source type</typeparam>
      <typeparam name="Target">Target type</typeparam>
      <param name="List">List to convert</param>
      <param name="ConvertingFunction">Function used to convert each item</param>
      <returns>The array containing the items from the list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="ConvertingFunction" exception="T:System.ArgumentNullException" csharp="ConvertingFunction != null" vb="ConvertingFunction &lt;&gt; Nothing">ConvertingFunction != null</requires>
      <exception cref="T:System.ArgumentNullException">ConvertingFunction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.To``1(System.Collections.Generic.IEnumerable{``0},System.String[])">
      <summary>
            Converts the IEnumerable to a DataTable
            </summary>
      <typeparam name="T">Type of the objects in the IEnumerable</typeparam>
      <param name="List">List to convert</param>
      <param name="Columns">Column names (if empty, uses property names)</param>
      <returns>The list as a DataTable</returns>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ToList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Converts an IEnumerable to a list
            </summary>
      <typeparam name="Source">Source type</typeparam>
      <typeparam name="Target">Target type</typeparam>
      <param name="List">IEnumerable to convert</param>
      <param name="ConvertingFunction">Function used to convert each item</param>
      <returns>The list containing the items from the IEnumerable</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="ConvertingFunction" exception="T:System.ArgumentNullException" csharp="ConvertingFunction != null" vb="ConvertingFunction &lt;&gt; Nothing">ConvertingFunction != null</requires>
      <exception cref="T:System.ArgumentNullException">ConvertingFunction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ToString``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String)">
      <summary>
            Converts the list to a string where each item is seperated by the Seperator
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">List to convert</param>
      <param name="ItemOutput">
            Used to convert the item to a string (defaults to calling ToString)
            </param>
      <param name="Seperator">Seperator to use between items (defaults to ,)</param>
      <returns>The string version of the list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt;();&#xD;&#xA;        local_0.ItemOutput = ItemOutput;&#xD;&#xA;        local_0.Seperator = Seperator;&#xD;&#xA;    }&#xD;&#xA;    return List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt; local_0 = New Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e(Of T)();&#xD;&#xA;    local_0.ItemOutput = ItemOutput&#xD;&#xA;    local_0.Seperator = Seperator&#xD;&#xA;    return List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt;();
        local_0.ItemOutput = ItemOutput;
        local_0.Seperator = Seperator;
    }
    return List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt; local_0 = new Utilities.DataTypes.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt;();
        (local_0.ItemOutput = ItemOutput);
        (local_0.Seperator = Seperator);
    }
    return (List != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ThrowIfAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Func{System.Exception})">
      <summary>
            Throws the specified exception if the predicate is true for all items
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
      <requires description="Exception" exception="T:System.ArgumentNullException" csharp="Exception != null" vb="Exception &lt;&gt; Nothing">Exception != null</requires>
      <exception cref="T:System.ArgumentNullException">Exception == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ThrowIfAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Exception)">
      <summary>
            Throws the specified exception if the predicate is true for all items
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
      <requires description="Exception" exception="T:System.ArgumentNullException" csharp="Exception != null" vb="Exception &lt;&gt; Nothing">Exception != null</requires>
      <exception cref="T:System.ArgumentNullException">Exception == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ThrowIfAny``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Func{System.Exception})">
      <summary>
            Throws the specified exception if the predicate is true for any items
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
      <requires description="Exception" exception="T:System.ArgumentNullException" csharp="Exception != null" vb="Exception &lt;&gt; Nothing">Exception != null</requires>
      <exception cref="T:System.ArgumentNullException">Exception == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.IEnumerableExtensions.ThrowIfAny``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Exception)">
      <summary>
            Throws the specified exception if the predicate is true for any items
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
      <requires description="Exception" exception="T:System.ArgumentNullException" csharp="Exception != null" vb="Exception &lt;&gt; Nothing">Exception != null</requires>
      <exception cref="T:System.ArgumentNullException">Exception == null</exception>
    </member>
    <member name="T:Utilities.DataTypes.MatchCollectionExtensions">
      <summary>
            MatchCollection extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.MatchCollectionExtensions.Where(System.Text.RegularExpressions.MatchCollection,System.Predicate{System.Text.RegularExpressions.Match})">
      <summary>
            Gets a list of items that satisfy the predicate from the collection
            </summary>
      <param name="Collection">Collection to search through</param>
      <param name="Predicate">Predicate that the items must satisfy</param>
      <returns>The matches that satisfy the predicate</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="T:Utilities.DataTypes.ProcessExtensions">
      <summary>
            Process extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ProcessExtensions.KillProcessAsync(System.Diagnostics.Process,System.Int32)">
      <summary>
            Kills a process
            </summary>
      <param name="Process">Process that should be killed</param>
      <param name="TimeToKill">Amount of time (in ms) until the process is killed.</param>
      <requires description="Process" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ProcessExtensions.&lt;&gt;c__DisplayClass1(){&#xD;&#xA;    Process = Process, &#xD;&#xA;    TimeToKill = TimeToKill, &#xD;&#xA;}.Process != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ProcessExtensions.&lt;&gt;c__DisplayClass1 local_0_prime = New Utilities.DataTypes.ProcessExtensions.&lt;&gt;c__DisplayClass1();&#xD;&#xA;    (local_0_prime.Process = Process)&#xD;&#xA;    (local_0_prime.TimeToKill = TimeToKill)&#xD;&#xA;    return local_0_prime; })().Process &lt;&gt; Nothing">new Utilities.DataTypes.ProcessExtensions.&lt;&gt;c__DisplayClass1(){
    Process = Process, 
    TimeToKill = TimeToKill, 
}.Process != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ProcessExtensions.&lt;&gt;c__DisplayClass1(){
    Process = Process, 
    TimeToKill = TimeToKill, 
}.Process == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ProcessExtensions.KillProcessAsync(System.Collections.Generic.IEnumerable{System.Diagnostics.Process},System.Int32)">
      <summary>
            Kills a list of processes
            </summary>
      <param name="Processes">Processes that should be killed</param>
      <param name="TimeToKill">Amount of time (in ms) until the processes are killed.</param>
      <requires description="Processes" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ProcessExtensions.&lt;&gt;c__DisplayClass5().TimeToKill = TimeToKill;&#xD;&#xA;    }&#xD;&#xA;    return Processes != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ProcessExtensions.&lt;&gt;c__DisplayClass5().TimeToKill = TimeToKill&#xD;&#xA;    return Processes &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ProcessExtensions.&lt;&gt;c__DisplayClass5().TimeToKill = TimeToKill;
    }
    return Processes != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ProcessExtensions.&lt;&gt;c__DisplayClass5().TimeToKill = TimeToKill);
    }
    return (Processes != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ProcessExtensions.GetInformation(System.Diagnostics.Process,System.Boolean)">
      <summary>
            Gets information about all processes and returns it in an HTML formatted string
            </summary>
      <param name="Process">Process to get information about</param>
      <param name="HTMLFormat">Should this be HTML formatted?</param>
      <returns>An HTML formatted string</returns>
      <requires description="Process" exception="T:System.ArgumentNullException" csharp="Process != null" vb="Process &lt;&gt; Nothing">Process != null</requires>
      <exception cref="T:System.ArgumentNullException">Process == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ProcessExtensions.GetInformation(System.Collections.Generic.IEnumerable{System.Diagnostics.Process},System.Boolean)">
      <summary>
            Gets information about all processes and returns it in an HTML formatted string
            </summary>
      <param name="Processes">Processes to get information about</param>
      <param name="HTMLFormat">Should this be HTML formatted?</param>
      <returns>An HTML formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ProcessExtensions.KillProcessAsyncHelper(System.Diagnostics.Process,System.Int32)">
      <summary>
            Kills a process asyncronously
            </summary>
      <param name="Process">Process to kill</param>
      <param name="TimeToKill">Amount of time until the process is killed</param>
      <requires description="Process" exception="T:System.ArgumentNullException" csharp="Process != null" vb="Process &lt;&gt; Nothing">Process != null</requires>
      <exception cref="T:System.ArgumentNullException">Process == null</exception>
    </member>
    <member name="T:Utilities.DataTypes.ReflectionExtensions">
      <summary>
            Reflection oriented extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Attribute``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
      <summary>
            Gets the attribute from the item
            </summary>
      <typeparam name="T">Attribute type</typeparam>
      <param name="Provider">Attribute provider</param>
      <param name="Inherit">
            When true, it looks up the heirarchy chain for the inherited custom attributes
            </param>
      <returns>Attribute specified if it exists</returns>
      <requires description="Provider" exception="T:System.ArgumentNullException" csharp="Provider != null" vb="Provider &lt;&gt; Nothing">Provider != null</requires>
      <exception cref="T:System.ArgumentNullException">Provider == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Attributes``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
      <summary>
            Gets the attributes from the item
            </summary>
      <typeparam name="T">Attribute type</typeparam>
      <param name="Provider">Attribute provider</param>
      <param name="Inherit">
            When true, it looks up the heirarchy chain for the inherited custom attributes
            </param>
      <returns>Array of attributes</returns>
      <requires description="Provider" exception="T:System.ArgumentNullException" csharp="Provider != null" vb="Provider &lt;&gt; Nothing">Provider != null</requires>
      <exception cref="T:System.ArgumentNullException">Provider == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Call``1(System.Object,System.String,System.Object[])">
      <summary>
            Calls a method on an object
            </summary>
      <param name="MethodName">Method name</param>
      <param name="Object">Object to call the method on</param>
      <param name="InputVariables">(Optional)input variables for the method</param>
      <typeparam name="ReturnType">Return type expected</typeparam>
      <returns>The returned value of the method</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="MethodName" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(MethodName)" vb="Not IsNullOrEmpty(MethodName)">!string.IsNullOrEmpty(MethodName)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(MethodName)</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Call``2(System.Object,System.String,System.Object[])">
      <summary>
            Calls a method on an object
            </summary>
      <param name="MethodName">Method name</param>
      <param name="Object">Object to call the method on</param>
      <param name="InputVariables">(Optional)input variables for the method</param>
      <typeparam name="ReturnType">Return type expected</typeparam>
      <typeparam name="GenericType1">Generic method type 1</typeparam>
      <returns>The returned value of the method</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="MethodName" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(MethodName)" vb="Not IsNullOrEmpty(MethodName)">!string.IsNullOrEmpty(MethodName)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(MethodName)</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Call``3(System.Object,System.String,System.Object[])">
      <summary>
            Calls a method on an object
            </summary>
      <param name="MethodName">Method name</param>
      <param name="Object">Object to call the method on</param>
      <param name="InputVariables">(Optional)input variables for the method</param>
      <typeparam name="ReturnType">Return type expected</typeparam>
      <typeparam name="GenericType1">Generic method type 1</typeparam>
      <typeparam name="GenericType2">Generic method type 2</typeparam>
      <returns>The returned value of the method</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="MethodName" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(MethodName)" vb="Not IsNullOrEmpty(MethodName)">!string.IsNullOrEmpty(MethodName)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(MethodName)</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Call``4(System.Object,System.String,System.Object[])">
      <summary>
            Calls a method on an object
            </summary>
      <param name="MethodName">Method name</param>
      <param name="Object">Object to call the method on</param>
      <param name="InputVariables">(Optional)input variables for the method</param>
      <typeparam name="ReturnType">Return type expected</typeparam>
      <typeparam name="GenericType1">Generic method type 1</typeparam>
      <typeparam name="GenericType2">Generic method type 2</typeparam>
      <typeparam name="GenericType3">Generic method type 3</typeparam>
      <returns>The returned value of the method</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="MethodName" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(MethodName)" vb="Not IsNullOrEmpty(MethodName)">!string.IsNullOrEmpty(MethodName)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(MethodName)</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Call``1(System.Object,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Calls a method on an object
            </summary>
      <param name="Method">Method</param>
      <param name="Object">Object to call the method on</param>
      <param name="InputVariables">(Optional)input variables for the method</param>
      <typeparam name="ReturnType">Return type expected</typeparam>
      <returns>The returned value of the method</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Method" exception="T:System.ArgumentNullException" csharp="Method != (System.Reflection.MethodInfo)null" vb="Method &lt;&gt; ((System.Reflection.MethodInfo)Nothing) ">Method != (System.Reflection.MethodInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Method != (System.Reflection.MethodInfo)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Create``1(System.Type,System.Object[])">
      <summary>
            Creates an instance of the type and casts it to the specified type
            </summary>
      <typeparam name="ClassType">Class type to return</typeparam>
      <param name="Type">Type to create an instance of</param>
      <param name="args">Arguments sent into the constructor</param>
      <returns>The newly created instance of the type</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="Type != (System.Type)null" vb="Type &lt;&gt; ((System.Type)Nothing) ">Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Create(System.Type,System.Object[])">
      <summary>
            Creates an instance of the type
            </summary>
      <param name="Type">Type to create an instance of</param>
      <param name="args">Arguments sent into the constructor</param>
      <returns>The newly created instance of the type</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="Type != (System.Type)null" vb="Type &lt;&gt; ((System.Type)Nothing) ">Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Create``1(System.Collections.Generic.IEnumerable{System.Type},System.Object[])">
      <summary>
            Creates an instance of the types and casts it to the specified type
            </summary>
      <typeparam name="ClassType">Class type to return</typeparam>
      <param name="Types">Types to create an instance of</param>
      <param name="args">Arguments sent into the constructor</param>
      <returns>The newly created instance of the types</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass2&lt;ClassType&gt;().args = args;&#xD;&#xA;    }&#xD;&#xA;    return Types != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass2(Of ClassType)().args = args&#xD;&#xA;    return Types &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass2&lt;ClassType&gt;().args = args;
    }
    return Types != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass2&lt;ClassType&gt;().args = args);
    }
    return (Types != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Create(System.Collections.Generic.IEnumerable{System.Type},System.Object[])">
      <summary>
            Creates an instance of the types specified
            </summary>
      <param name="Types">Types to create an instance of</param>
      <param name="args">Arguments sent into the constructor</param>
      <returns>The newly created instance of the types</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass5().args = args;&#xD;&#xA;    }&#xD;&#xA;    return Types != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass5().args = args&#xD;&#xA;    return Types &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass5().args = args;
    }
    return Types != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass5().args = args);
    }
    return (Types != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.GetName(System.Type)">
      <summary>
            Returns the type's name (Actual C# name, not the funky version from the Name property)
            </summary>
      <param name="ObjectType">Type to get the name of</param>
      <returns>string name of the type</returns>
      <requires description="ObjectType" exception="T:System.ArgumentNullException" csharp="ObjectType != (System.Type)null" vb="ObjectType &lt;&gt; ((System.Type)Nothing) ">ObjectType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!ObjectType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.HasDefaultConstructor(System.Type)">
      <summary>
            Determines if the type has a default constructor
            </summary>
      <param name="Type">Type to check</param>
      <returns>True if it does, false otherwise</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="Type != (System.Type)null" vb="Type &lt;&gt; ((System.Type)Nothing) ">Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Is(System.Object,System.Type)">
      <summary>
            Determines if an object is of a specific type
            </summary>
      <param name="Object">Object</param>
      <param name="Type">Type</param>
      <returns>True if it is, false otherwise</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="Type != (System.Type)null" vb="Type &lt;&gt; ((System.Type)Nothing) ">Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Is(System.Type,System.Type)">
      <summary>
            Determines if an object is of a specific type
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Type">Type</param>
      <returns>True if it is, false otherwise</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClassa(){&#xD;&#xA;    Type = Type, &#xD;&#xA;}.Type != (System.Type)null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClassa local_0_prime = New Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClassa();&#xD;&#xA;    local_0_prime.Type = Type&#xD;&#xA;    return local_0_prime; })().Type &lt;&gt; ((System.Type)Nothing) ">new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClassa(){
    Type = Type, 
}.Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClassa(){
    Type = Type, 
}.Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Is``1(System.Object)">
      <summary>
            Determines if an object is of a specific type
            </summary>
      <param name="Object">Object</param>
      <typeparam name="BaseObjectType">Base object type</typeparam>
      <returns>True if it is, false otherwise</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Is``1(System.Type)">
      <summary>
            Determines if an object is of a specific type
            </summary>
      <param name="ObjectType">Object type</param>
      <typeparam name="BaseObjectType">Base object type</typeparam>
      <returns>True if it is, false otherwise</returns>
      <requires description="ObjectType" exception="T:System.ArgumentNullException" csharp="ObjectType != (System.Type)null" vb="ObjectType &lt;&gt; ((System.Type)Nothing) ">ObjectType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!ObjectType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Load(System.Reflection.AssemblyName)">
      <summary>
            Loads an assembly by its name
            </summary>
      <param name="Name">Name of the assembly to return</param>
      <returns>The assembly specified if it exists</returns>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="Name != null" vb="Name &lt;&gt; Nothing">Name != null</requires>
      <exception cref="T:System.ArgumentNullException">Name == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.LoadAssemblies(System.IO.DirectoryInfo,System.Boolean)">
      <summary>
            Loads assemblies within a directory and returns them in an array.
            </summary>
      <param name="Directory">The directory to search in</param>
      <param name="Recursive">Determines whether to search recursively or not</param>
      <returns>Array of assemblies in the directory</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="Directory != null" vb="Directory &lt;&gt; Nothing">Directory != null</requires>
      <exception cref="T:System.ArgumentNullException">Directory == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.MarkedWith``1(System.Collections.Generic.IEnumerable{System.Type},System.Boolean)">
      <summary>
            Goes through a list of types and determines if they're marked with a specific attribute
            </summary>
      <typeparam name="T">Attribute type</typeparam>
      <param name="Types">Types to check</param>
      <param name="Inherit">
            When true, it looks up the heirarchy chain for the inherited custom attributes
            </param>
      <returns>The list of types that are marked with an attribute</returns>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.MakeShallowCopy``1(``0,System.Boolean)">
      <summary>
            Makes a shallow copy of the object
            </summary>
      <param name="Object">Object to copy</param>
      <param name="SimpleTypesOnly">
            If true, it only copies simple types (no classes, only items like int, string, etc.),
            false copies everything.
            </param>
      <returns>A copy of the object</returns>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Objects``1(System.Reflection.Assembly)">
      <summary>
            Returns an instance of all classes that it finds within an assembly that are of the
            specified base type/interface.
            </summary>
      <typeparam name="ClassType">Base type/interface searching for</typeparam>
      <param name="Assembly">Assembly to search within</param>
      <returns>A list of objects that are of the type specified</returns>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="Assembly != (System.Reflection.Assembly)null" vb="Assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">Assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">!Assembly != (System.Reflection.Assembly)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Objects``1(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
      <summary>
            Returns an instance of all classes that it finds within a group of assemblies that are
            of the specified base type/interface.
            </summary>
      <typeparam name="ClassType">Base type/interface searching for</typeparam>
      <param name="Assemblies">Assemblies to search within</param>
      <returns>A list of objects that are of the type specified</returns>
      <requires description="Assemblies" exception="T:System.ArgumentNullException" csharp="Assemblies != null" vb="Assemblies &lt;&gt; Nothing">Assemblies != null</requires>
      <exception cref="T:System.ArgumentNullException">Assemblies == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Objects``1(System.IO.DirectoryInfo,System.Boolean)">
      <summary>
            Returns an instance of all classes that it finds within a directory that are of the
            specified base type/interface.
            </summary>
      <typeparam name="ClassType">Base type/interface searching for</typeparam>
      <param name="Directory">Directory to search within</param>
      <param name="Recursive">Should this be recursive</param>
      <returns>A list of objects that are of the type specified</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="Directory != null" vb="Directory &lt;&gt; Nothing">Directory != null</requires>
      <exception cref="T:System.ArgumentNullException">Directory == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Property(System.Object,System.Reflection.PropertyInfo)">
      <summary>
            Gets the value of property
            </summary>
      <param name="Object">The object to get the property of</param>
      <param name="Property">The property to get</param>
      <returns>Returns the property's value</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != (System.Reflection.PropertyInfo)null" vb="Property &lt;&gt; ((System.Reflection.PropertyInfo)Nothing) ">Property != (System.Reflection.PropertyInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Property != (System.Reflection.PropertyInfo)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Property(System.Object,System.String)">
      <summary>
            Gets the value of property
            </summary>
      <param name="Object">The object to get the property of</param>
      <param name="Property">The property to get</param>
      <returns>Returns the property's value</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Property)" vb="Not IsNullOrEmpty(Property)">!string.IsNullOrEmpty(Property)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Property)</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Property(System.Object,System.Reflection.PropertyInfo,System.Object,System.String)">
      <summary>
            Sets the value of destination property
            </summary>
      <param name="Object">The object to set the property of</param>
      <param name="Property">The property to set</param>
      <param name="Value">Value to set the property to</param>
      <param name="Format">Allows for formatting if the destination is a string</param>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != (System.Reflection.PropertyInfo)null" vb="Property &lt;&gt; ((System.Reflection.PropertyInfo)Nothing) ">Property != (System.Reflection.PropertyInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Property != (System.Reflection.PropertyInfo)null</exception>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != null" vb="Value &lt;&gt; Nothing">Value != null</requires>
      <exception cref="T:System.ArgumentNullException">Value == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Property(System.Object,System.String,System.Object,System.String)">
      <summary>
            Sets the value of destination property
            </summary>
      <param name="Object">The object to set the property of</param>
      <param name="Property">The property to set</param>
      <param name="Value">Value to set the property to</param>
      <param name="Format">Allows for formatting if the destination is a string</param>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Property)" vb="Not IsNullOrEmpty(Property)">!string.IsNullOrEmpty(Property)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Property)</exception>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != null" vb="Value &lt;&gt; Nothing">Value != null</requires>
      <exception cref="T:System.ArgumentNullException">Value == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.PropertyGetter``2(System.Reflection.PropertyInfo)">
      <summary>
            Gets a lambda expression that calls a specific property's getter function
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type expecting</typeparam>
      <param name="Property">Property</param>
      <returns>A lambda expression that calls a specific property's getter function</returns>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != (System.Reflection.PropertyInfo)null" vb="Property &lt;&gt; ((System.Reflection.PropertyInfo)Nothing) ">Property != (System.Reflection.PropertyInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Property != (System.Reflection.PropertyInfo)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.PropertyGetter``1(System.Reflection.PropertyInfo)">
      <summary>
            Gets a lambda expression that calls a specific property's getter function
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="Property">Property</param>
      <returns>A lambda expression that calls a specific property's getter function</returns>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != (System.Reflection.PropertyInfo)null" vb="Property &lt;&gt; ((System.Reflection.PropertyInfo)Nothing) ">Property != (System.Reflection.PropertyInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Property != (System.Reflection.PropertyInfo)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.PropertyName(System.Linq.Expressions.LambdaExpression)">
      <summary>
            Gets a property name
            </summary>
      <param name="Expression">LINQ expression</param>
      <returns>The name of the property</returns>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.PropertyName(System.Linq.Expressions.Expression)">
      <summary>
            Gets a property name
            </summary>
      <param name="Expression">LINQ expression</param>
      <returns>The name of the property</returns>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.PropertySetter``2(System.Linq.Expressions.LambdaExpression)">
      <summary>
            Gets a lambda expression that calls a specific property's setter function
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type expecting</typeparam>
      <param name="Property">Property</param>
      <returns>A lambda expression that calls a specific property's setter function</returns>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Func&lt;System.Reflection.MethodInfo, bool&gt; local_18 = (System.Func&lt;System.Reflection.MethodInfo, bool&gt;)null;&#xD;&#xA;    }&#xD;&#xA;    return Property != null; })()" vb="(() =&gt; {&#xD;&#xA;    System.Func&lt;System.Reflection.MethodInfo, bool&gt; local_18 = ((System.Func(Of System.Reflection.MethodInfo, Boolean))Nothing);&#xD;&#xA;    return Property &lt;&gt; Nothing; })()">(() =&gt; {
    {
        System.Func&lt;System.Reflection.MethodInfo, bool&gt; local_18 = (System.Func&lt;System.Reflection.MethodInfo, bool&gt;)null;
    }
    return Property != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        System.Func&lt;System.Reflection.MethodInfo, bool&gt; local_18 = (System.Func&lt;System.Reflection.MethodInfo, bool&gt;)null;
    }
    return (Property != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.PropertySetter``1(System.Linq.Expressions.LambdaExpression)">
      <summary>
            Gets a lambda expression that calls a specific property's setter function
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="Property">Property</param>
      <returns>A lambda expression that calls a specific property's setter function</returns>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != null" vb="Property &lt;&gt; Nothing">Property != null</requires>
      <exception cref="T:System.ArgumentNullException">Property == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.PropertyType(System.Object,System.String)">
      <summary>
            Gets a property's type
            </summary>
      <param name="Object">object who contains the property</param>
      <param name="PropertyPath">
            Path of the property (ex: Prop1.Prop2.Prop3 would be the Prop1 of the source object,
            which then has a Prop2 on it, which in turn has a Prop3 on it.)
            </param>
      <returns>The type of the property specified or null if it can not be reached.</returns>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.PropertyType(System.Type,System.String)">
      <summary>
            Gets a property's type
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="PropertyPath">
            Path of the property (ex: Prop1.Prop2.Prop3 would be the Prop1 of the source object,
            which then has a Prop2 on it, which in turn has a Prop3 on it.)
            </param>
      <returns>The type of the property specified or null if it can not be reached.</returns>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.ToString(System.Reflection.Assembly,Utilities.DataTypes.VersionInfo)">
      <summary>
            Gets the version information in a string format
            </summary>
      <param name="Assembly">Assembly to get version information from</param>
      <param name="InfoType">Version info type</param>
      <returns>The version information as a string</returns>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="Assembly != (System.Reflection.Assembly)null" vb="Assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">Assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">!Assembly != (System.Reflection.Assembly)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.ToString(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},Utilities.DataTypes.VersionInfo)">
      <summary>
            Gets the version information in a string format
            </summary>
      <param name="Assemblies">Assemblies to get version information from</param>
      <param name="InfoType">Version info type</param>
      <returns>The version information as a string</returns>
      <requires description="Assemblies" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass15().InfoType = InfoType;&#xD;&#xA;    }&#xD;&#xA;    return Assemblies != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass15().InfoType = InfoType&#xD;&#xA;    return Assemblies &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass15().InfoType = InfoType;
    }
    return Assemblies != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass15().InfoType = InfoType);
    }
    return (Assemblies != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.ToString(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Boolean)">
      <summary>
            Gets assembly information for all currently loaded assemblies
            </summary>
      <param name="Assemblies">Assemblies to dump information from</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>An HTML formatted string containing the assembly information</returns>
      <requires description="Assemblies" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass18().HTMLOutput = HTMLOutput;&#xD;&#xA;    }&#xD;&#xA;    return Assemblies != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass18().HTMLOutput = HTMLOutput&#xD;&#xA;    return Assemblies &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass18().HTMLOutput = HTMLOutput;
    }
    return Assemblies != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass18().HTMLOutput = HTMLOutput);
    }
    return (Assemblies != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.ToString(System.Object,System.Boolean)">
      <summary>
            Dumps the property names and current values from an object
            </summary>
      <param name="Object">Object to dunp</param>
      <param name="HTMLOutput">Determines if the output should be HTML or not</param>
      <returns>An HTML formatted table containing the information about the object</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.ToString(System.Type,System.Boolean)">
      <summary>
            Dumps the properties names and current values from an object type (used for static classes)
            </summary>
      <param name="ObjectType">Object type to dunp</param>
      <param name="HTMLOutput">Should this be output as an HTML string</param>
      <returns>An HTML formatted table containing the information about the object type</returns>
      <requires description="ObjectType" exception="T:System.ArgumentNullException" csharp="ObjectType != (System.Type)null" vb="ObjectType &lt;&gt; ((System.Type)Nothing) ">ObjectType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!ObjectType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Types``1(System.Reflection.Assembly)">
      <summary>
            Gets a list of types based on an interface
            </summary>
      <param name="Assembly">Assembly to check</param>
      <typeparam name="BaseType">Class type to search for</typeparam>
      <returns>List of types that use the interface</returns>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="Assembly != (System.Reflection.Assembly)null" vb="Assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">Assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">!Assembly != (System.Reflection.Assembly)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Types(System.Reflection.Assembly,System.Type)">
      <summary>
            Gets a list of types based on an interface
            </summary>
      <param name="Assembly">Assembly to check</param>
      <param name="BaseType">Base type to look for</param>
      <returns>List of types that use the interface</returns>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Func&lt;System.Type, bool&gt; local_1 = (System.Func&lt;System.Type, bool&gt;)null;&#xD;&#xA;        Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1c local_2 = new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1c();&#xD;&#xA;        local_2.BaseType = BaseType;&#xD;&#xA;    }&#xD;&#xA;    return Assembly != (System.Reflection.Assembly)null; })()" vb="(() =&gt; {&#xD;&#xA;    System.Func&lt;System.Type, bool&gt; local_1 = ((System.Func(Of System.Type, Boolean))Nothing);&#xD;&#xA;    Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1c local_2 = New Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1c();&#xD;&#xA;    local_2.BaseType = BaseType&#xD;&#xA;    return Assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ; })()">(() =&gt; {
    {
        System.Func&lt;System.Type, bool&gt; local_1 = (System.Func&lt;System.Type, bool&gt;)null;
        Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1c local_2 = new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1c();
        local_2.BaseType = BaseType;
    }
    return Assembly != (System.Reflection.Assembly)null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        System.Func&lt;System.Type, bool&gt; local_1 = (System.Func&lt;System.Type, bool&gt;)null;
        Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1c local_2 = new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1c();
        (local_2.BaseType = BaseType);
    }
    return Assembly != (System.Reflection.Assembly)null; })()</exception>
      <requires description="BaseType" exception="T:System.ArgumentNullException" csharp="local_2.BaseType != (System.Type)null" vb="local_2.BaseType &lt;&gt; ((System.Type)Nothing) ">local_2.BaseType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!local_2.BaseType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Types``1(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
      <summary>
            Gets a list of types based on an interface
            </summary>
      <param name="Assemblies">Assemblies to check</param>
      <typeparam name="BaseType">Class type to search for</typeparam>
      <returns>List of types that use the interface</returns>
      <requires description="Assemblies" exception="T:System.ArgumentNullException" csharp="Assemblies != null" vb="Assemblies &lt;&gt; Nothing">Assemblies != null</requires>
      <exception cref="T:System.ArgumentNullException">Assemblies == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Types(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Type)">
      <summary>
            Gets a list of types based on an interface
            </summary>
      <param name="Assemblies">Assemblies to check</param>
      <param name="BaseType">Base type to look for</param>
      <returns>List of types that use the interface</returns>
      <requires description="Assemblies" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1f local_0 = new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1f();&#xD;&#xA;        local_0.BaseType = BaseType;&#xD;&#xA;    }&#xD;&#xA;    return Assemblies != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1f local_0 = New Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1f();&#xD;&#xA;    local_0.BaseType = BaseType&#xD;&#xA;    return Assemblies &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1f local_0 = new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1f();
        local_0.BaseType = BaseType;
    }
    return Assemblies != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1f local_0 = new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass1f();
        (local_0.BaseType = BaseType);
    }
    return (Assemblies != null); })()</exception>
      <requires description="BaseType" exception="T:System.ArgumentNullException" csharp="local_0.BaseType != (System.Type)null" vb="local_0.BaseType &lt;&gt; ((System.Type)Nothing) ">local_0.BaseType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!local_0.BaseType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ReflectionExtensions.Types(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
      <summary>
            Gets a list of types in the assemblies specified
            </summary>
      <param name="Assemblies">Assemblies to check</param>
      <returns>List of types</returns>
      <requires description="Assemblies" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass22 local_0 = new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass22();&#xD;&#xA;    }&#xD;&#xA;    return Assemblies != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass22 local_0 = New Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass22();&#xD;&#xA;    return Assemblies &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass22 local_0 = new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass22();
    }
    return Assemblies != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass22 local_0 = new Utilities.DataTypes.ReflectionExtensions.&lt;&gt;c__DisplayClass22();
    }
    return (Assemblies != null); })()</exception>
    </member>
    <member name="T:Utilities.DataTypes.VersionInfo">
      <summary>
            Version info
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.VersionInfo.ShortVersion">
      <summary>
            Short version
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.VersionInfo.LongVersion">
      <summary>
            Long version
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.StackTraceExtensions">
      <summary>
            Extension methods related to the stack trace
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.StackTraceExtensions.GetMethods(System.Diagnostics.StackTrace,System.Reflection.Assembly[])">
      <summary>
            Gets the methods involved in the stack trace
            </summary>
      <param name="Stack">Stack trace to get methods from</param>
      <param name="ExcludedAssemblies">Excludes methods from the specified assemblies</param>
      <returns>A list of methods involved in the stack trace</returns>
      <requires description="Stack" exception="T:System.ArgumentNullException" csharp="Stack != null" vb="Stack &lt;&gt; Nothing">Stack != null</requires>
      <exception cref="T:System.ArgumentNullException">Stack == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.StackTraceExtensions.GetMethods(System.Collections.Generic.IEnumerable{System.Diagnostics.StackFrame},System.Reflection.Assembly[])">
      <summary>
            Gets the methods involved in the individual frames
            </summary>
      <param name="Frames">Frames to get the methods from</param>
      <param name="ExcludedAssemblies">Excludes methods from the specified assemblies</param>
      <returns>The list of methods involved</returns>
    </member>
    <member name="T:Utilities.DataTypes.StreamExtensions">
      <summary>
            Extension methods for Streams
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.StreamExtensions.ReadAllBinary(System.IO.Stream)">
      <summary>
            Takes all of the data in the stream and returns it as an array of bytes
            </summary>
      <param name="Input">Input stream</param>
      <returns>A byte array</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.StreamExtensions.ReadAll(System.IO.Stream,System.Text.Encoding)">
      <summary>
            Takes all of the data in the stream and returns it as a string
            </summary>
      <param name="Input">Input stream</param>
      <param name="EncodingUsing">
            Encoding that the string should be in (defaults to UTF8)
            </param>
      <returns>A string containing the content of the stream</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="T:Utilities.DataTypes.StringExtensions">
      <summary>
            String and StringBuilder extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.AppendLineFormat(System.Text.StringBuilder,System.String,System.Object[])">
      <summary>
            Does an AppendFormat and then an AppendLine on the StringBuilder
            </summary>
      <param name="Builder">Builder object</param>
      <param name="Format">Format string</param>
      <param name="Objects">Objects to format</param>
      <returns>The StringBuilder passed in</returns>
      <requires description="Format" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Format)" vb="Not IsNullOrEmpty(Format)">!string.IsNullOrEmpty(Format)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Format)</exception>
      <requires description="Builder" exception="T:System.ArgumentNullException" csharp="Builder != null" vb="Builder &lt;&gt; Nothing">Builder != null</requires>
      <exception cref="T:System.ArgumentNullException">Builder == null</exception>
      <requires description="Objects" exception="T:System.ArgumentNullException" csharp="Objects != null" vb="Objects &lt;&gt; Nothing">Objects != null</requires>
      <exception cref="T:System.ArgumentNullException">Objects == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Center(System.String,System.Int32,System.String)">
      <summary>
            Centers the input string (if it's longer than the length) and pads it using the padding string
            </summary>
      <param name="Input" />
      <param name="Length" />
      <param name="Padding" />
      <returns>The centered string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Encode(System.String,System.Text.Encoding,System.Text.Encoding)">
      <summary>
            Converts a string to a string of another encoding
            </summary>
      <param name="Input">input string</param>
      <param name="OriginalEncodingUsing">
            The type of encoding the string is currently using (defaults to ASCII)
            </param>
      <param name="EncodingUsing">
            The type of encoding the string is converted into (defaults to UTF8)
            </param>
      <returns>string of the byte array</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.FromBase64(System.String,System.Text.Encoding)">
      <summary>
            Converts base 64 string based on the encoding passed in
            </summary>
      <param name="Input">Input string</param>
      <param name="EncodingUsing">
            The type of encoding the string is using (defaults to UTF8)
            </param>
      <returns>string in the encoding format</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.FromBase64(System.String)">
      <summary>
            Converts base 64 string to a byte array
            </summary>
      <param name="Input">Input string</param>
      <returns>A byte array equivalent of the base 64 string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Is(System.String,Utilities.DataTypes.StringCompare)">
      <summary>
            Is this value of the specified type
            </summary>
      <param name="Value">Value to compare</param>
      <param name="ComparisonType">Comparison type</param>
      <returns>True if it is of the type specified, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Is(System.String,System.String,Utilities.DataTypes.StringCompare)">
      <summary>
            Is this value of the specified type
            </summary>
      <param name="Value1">Value 1 to compare</param>
      <param name="Value2">Value 2 to compare</param>
      <param name="ComparisonType">Comparison type</param>
      <returns>True if it is of the type specified, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Keep(System.String,System.String)">
      <summary>
            Removes everything that is not in the filter text from the input.
            </summary>
      <param name="Input">Input text</param>
      <param name="Filter">Regex expression of text to keep</param>
      <returns>The input text minus everything not in the filter text.</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Keep(System.String,Utilities.DataTypes.StringFilter)">
      <summary>
            Removes everything that is not in the filter text from the input.
            </summary>
      <param name="Input">Input text</param>
      <param name="Filter">Predefined filter to use (can be combined as they are flags)</param>
      <returns>The input text minus everything not in the filter text.</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Left(System.String,System.Int32)">
      <summary>
            Gets the first x number of characters from the left hand side
            </summary>
      <param name="Input">Input string</param>
      <param name="Length">x number of characters to return</param>
      <returns>The resulting string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.LevenshteinDistance(System.String,System.String)">
      <summary>
            Calculates the Levenshtein distance
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>The Levenshtein distance</returns>
      <requires description="Value1" exception="T:System.ArgumentNullException" csharp="Value1 != null" vb="Value1 &lt;&gt; Nothing">Value1 != null</requires>
      <exception cref="T:System.ArgumentNullException">Value1 == null</exception>
      <requires description="Value2" exception="T:System.ArgumentNullException" csharp="Value2 != null" vb="Value2 &lt;&gt; Nothing">Value2 != null</requires>
      <exception cref="T:System.ArgumentNullException">Value2 == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.MaskLeft(System.String,System.Int32,System.Char)">
      <summary>
            Masks characters to the left ending at a specific character
            </summary>
      <param name="Input">Input string</param>
      <param name="EndPosition">End position (counting from the left)</param>
      <param name="Mask">Mask character to use</param>
      <returns>The masked string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.MaskRight(System.String,System.Int32,System.Char)">
      <summary>
            Masks characters to the right starting at a specific character
            </summary>
      <param name="Input">Input string</param>
      <param name="StartPosition">Start position (counting from the left)</param>
      <param name="Mask">Mask character to use</param>
      <returns>The masked string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.NumberTimesOccurs(System.String,System.String)">
      <summary>
            returns the number of times a string occurs within the text
            </summary>
      <param name="Input">input text</param>
      <param name="Match">The string to match (can be regex)</param>
      <returns>The number of times the string occurs</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Pluralize(System.String,System.Globalization.CultureInfo)">
      <summary>
            Pluralizes a word
            </summary>
      <param name="Word">Word to pluralize</param>
      <param name="Culture">
            Culture info used to pluralize the word (defaults to current culture)
            </param>
      <returns>The word pluralized</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Remove(System.String,System.String)">
      <summary>
            Removes everything that is in the filter text from the input.
            </summary>
      <param name="Input">Input text</param>
      <param name="Filter">Regex expression of text to remove</param>
      <returns>Everything not in the filter text.</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Remove(System.String,Utilities.DataTypes.StringFilter)">
      <summary>
            Removes everything that is in the filter text from the input.
            </summary>
      <param name="Input">Input text</param>
      <param name="Filter">Predefined filter to use (can be combined as they are flags)</param>
      <returns>Everything not in the filter text.</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Replace(System.String,Utilities.DataTypes.StringFilter,System.String)">
      <summary>
            Replaces everything that is in the filter text with the value specified.
            </summary>
      <param name="Input">Input text</param>
      <param name="Value">Value to fill in</param>
      <param name="Filter">Predefined filter to use (can be combined as they are flags)</param>
      <returns>The input text with the various items replaced</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Reverse(System.String)">
      <summary>
            Reverses a string
            </summary>
      <param name="Input">Input string</param>
      <returns>The reverse of the input string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Right(System.String,System.Int32)">
      <summary>
            Gets the last x number of characters from the right hand side
            </summary>
      <param name="Input">Input string</param>
      <param name="Length">x number of characters to return</param>
      <returns>The resulting string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.Singularize(System.String,System.Globalization.CultureInfo)">
      <summary>
            Singularizes a word
            </summary>
      <param name="Word">Word to singularize</param>
      <param name="Culture">
            Culture info used to singularize the word (defaults to current culture)
            </param>
      <returns>The word singularized</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.StripLeft(System.String,System.String)">
      <summary>
            Strips out any of the characters specified starting on the left side of the input string
            (stops when a character not in the list is found)
            </summary>
      <param name="Input">Input string</param>
      <param name="Characters">Characters to strip (defaults to a space)</param>
      <returns>The Input string with specified characters stripped out</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.StripRight(System.String,System.String)">
      <summary>
            Strips out any of the characters specified starting on the right side of the input
            string (stops when a character not in the list is found)
            </summary>
      <param name="Input">Input string</param>
      <param name="Characters">Characters to strip (defaults to a space)</param>
      <returns>The Input string with specified characters stripped out</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.StripIllegalXML(System.String)">
      <summary>
            Strips illegal characters for XML content
            </summary>
      <param name="Content">Content</param>
      <returns>The stripped string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.ToByteArray(System.String,System.Text.Encoding)">
      <summary>
            Converts a string to a byte array
            </summary>
      <param name="Input">input string</param>
      <param name="EncodingUsing">
            The type of encoding the string is using (defaults to UTF8)
            </param>
      <returns>the byte array representing the string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.ToString(System.String,System.Base64FormattingOptions,System.Text.Encoding)">
      <summary>
            Converts from the specified encoding to a base 64 string
            </summary>
      <param name="Input">Input string</param>
      <param name="Options">Base 64 formatting options</param>
      <param name="OriginalEncodingUsing">
            The type of encoding the string is using (defaults to UTF8)
            </param>
      <returns>Bas64 string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.ToString(System.String,Utilities.DataTypes.StringCase)">
      <summary>
            Formats the string based on the capitalization specified
            </summary>
      <param name="Input">Input string</param>
      <param name="Case">Capitalization type to use</param>
      <returns>Capitalizes the string based on the case specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.ToString(System.String,System.String,Utilities.DataTypes.Formatters.Interfaces.IStringFormatter)">
      <summary>
            Formats a string based on a format string passed in. The default formatter uses the
            following format: # = digits @ = alpha characters \ = escape char
            </summary>
      <param name="Input">Input string</param>
      <param name="Format">Format of the output string</param>
      <param name="Provider">
            String formatter provider (defaults to GenericStringFormatter)
            </param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.ToString(System.String,System.Object,System.String,System.String)">
      <summary>
            Formats a string based on the object's properties
            </summary>
      <param name="Input">Input string</param>
      <param name="Object">Object to use to format the string</param>
      <param name="StartSeperator">
            Seperator character/string to use to describe the start of the property name
            </param>
      <param name="EndSeperator">
            Seperator character/string to use to describe the end of the property name
            </param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.ToString(System.String,System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
      <summary>
            Formats a string based on the key/value pairs that are sent in
            </summary>
      <param name="Input">Input string</param>
      <param name="Pairs">Key/value pairs. Replaces the key with the corresponding value.</param>
      <returns>The string after the changes have been made</returns>
    </member>
    <member name="M:Utilities.DataTypes.StringExtensions.ToString(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
      <summary>
            Uses a regex to format the input string
            </summary>
      <param name="Input">Input string</param>
      <param name="Format">Regex string used to</param>
      <param name="OutputFormat">Output format</param>
      <param name="Options">Regex options</param>
      <returns>The input string formatted by using the regex string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
      <requires description="Format" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Format)" vb="Not IsNullOrEmpty(Format)">!string.IsNullOrEmpty(Format)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Format)</exception>
      <requires description="OutputFormat" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(OutputFormat)" vb="Not IsNullOrEmpty(OutputFormat)">!string.IsNullOrEmpty(OutputFormat)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(OutputFormat)</exception>
    </member>
    <member name="T:Utilities.DataTypes.StringCase">
      <summary>
            What sort of string capitalization should be used?
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringCase.SentenceCapitalize">
      <summary>
            Sentence capitalization
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringCase.FirstCharacterUpperCase">
      <summary>
            First character upper case
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringCase.TitleCase">
      <summary>
            Title case
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.StringCompare">
      <summary>
            What type of string comparison are we doing?
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringCompare.CreditCard">
      <summary>
            Is this a credit card number?
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringCompare.Anagram">
      <summary>
            Is this an anagram?
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringCompare.Unicode">
      <summary>
            Is this Unicode
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.StringFilter">
      <summary>
            Predefined filters
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringFilter.Alpha">
      <summary>
            Alpha characters
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringFilter.Numeric">
      <summary>
            Numeric characters
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringFilter.FloatNumeric">
      <summary>
            Numbers with period, basically allows for decimal point
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.StringFilter.ExtraSpaces">
      <summary>
            Multiple spaces
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.TimeSpanExtensions">
      <summary>
            TimeSpan extension methods
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.TimeSpanExtensions.DaysRemainder(System.TimeSpan)">
      <summary>
            Days in the TimeSpan minus the months and years
            </summary>
      <param name="Span">TimeSpan to get the days from</param>
      <returns>The number of days minus the months and years that the TimeSpan has</returns>
    </member>
    <member name="M:Utilities.DataTypes.TimeSpanExtensions.Months(System.TimeSpan)">
      <summary>
            Months in the TimeSpan
            </summary>
      <param name="Span">TimeSpan to get the months from</param>
      <returns>The number of months that the TimeSpan has</returns>
    </member>
    <member name="M:Utilities.DataTypes.TimeSpanExtensions.Years(System.TimeSpan)">
      <summary>
            Years in the TimeSpan
            </summary>
      <param name="Span">TimeSpan to get the years from</param>
      <returns>The number of years that the TimeSpan has</returns>
    </member>
    <member name="M:Utilities.DataTypes.TimeSpanExtensions.ToStringFull(System.TimeSpan)">
      <summary>
            Converts the input to a string in this format: (Years) years, (Months) months,
            (DaysRemainder) days, (Hours) hours, (Minutes) minutes, (Seconds) seconds
            </summary>
      <param name="Input">Input TimeSpan</param>
      <returns>The TimeSpan as a string</returns>
    </member>
    <member name="M:Utilities.DataTypes.TimeSpanExtensions.Average(System.Collections.Generic.IEnumerable{System.TimeSpan})">
      <summary>
            Averages a list of TimeSpans
            </summary>
      <param name="List">List of TimeSpans</param>
      <returns>The average value</returns>
    </member>
    <member name="T:Utilities.DataTypes.TypeConversionExtensions">
      <summary>
            Extensions converting between types, checking if something is null, etc.
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.TypeConversionExtensions.FormatToString(System.Object,System.String)">
      <summary>
            Calls the object's ToString function passing in the formatting
            </summary>
      <param name="Input">Input object</param>
      <param name="Format">Format of the output string</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.TypeConversionExtensions.MapTo(System.Type,System.Type)">
      <summary>
            Sets up a mapping between two types
            </summary>
      <param name="LeftType">Left type</param>
      <param name="RightType">Right type</param>
      <returns>The type mapping</returns>
    </member>
    <member name="M:Utilities.DataTypes.TypeConversionExtensions.MapTo``2(``0)">
      <summary>
            Sets up a mapping between two types
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
      <param name="Object">Object to set up mapping for</param>
      <returns>The type mapping</returns>
    </member>
    <member name="M:Utilities.DataTypes.TypeConversionExtensions.MapTo``2(System.Type)">
      <summary>
            Sets up a mapping between two types
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
      <param name="ObjectType">Object type to set up mapping for</param>
      <returns>The type mapping</returns>
    </member>
    <member name="M:Utilities.DataTypes.TypeConversionExtensions.To``1(System.Data.DataTable,System.Func{``0})">
      <summary>
            Attempts to convert the DataTable to a list of objects
            </summary>
      <typeparam name="T">Type the objects should be in the list</typeparam>
      <param name="Data">DataTable to convert</param>
      <param name="Creator">Function used to create each object</param>
      <returns>The DataTable converted to a list of objects</returns>
    </member>
    <member name="M:Utilities.DataTypes.TypeConversionExtensions.To``2(``0,``1)">
      <summary>
            Attempts to convert the object to another type and returns the value
            </summary>
      <typeparam name="T">Type to convert from</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="Object">Object to convert</param>
      <param name="DefaultValue">
            Default value to return if there is an issue or it can't be converted
            </param>
      <returns>
            The object converted to the other type or the default value if there is an error or
            can't be converted
            </returns>
    </member>
    <member name="M:Utilities.DataTypes.TypeConversionExtensions.To``1(``0,System.Type,System.Object)">
      <summary>
            Attempts to convert the object to another type and returns the value
            </summary>
      <typeparam name="T">Type to convert from</typeparam>
      <param name="ResultType">Result type</param>
      <param name="Object">Object to convert</param>
      <param name="DefaultValue">
            Default value to return if there is an issue or it can't be converted
            </param>
      <returns>
            The object converted to the other type or the default value if there is an error or
            can't be converted
            </returns>
    </member>
    <member name="T:Utilities.DataTypes.ValueTypeExtensions">
      <summary>
            Value type extension methods
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ValueTypeExtensions.ToString(System.Byte[],System.Base64FormattingOptions,System.Int32,System.Int32)">
      <summary>
            Converts a byte array into a base 64 string
            </summary>
      <param name="Input">Input array</param>
      <param name="Count">
            Number of bytes starting at the index to convert (use -1 for the entire array starting
            at the index)
            </param>
      <param name="Index">Index to start at</param>
      <param name="Options">Base 64 formatting options</param>
      <returns>The equivalent byte array in a base 64 string</returns>
      <requires description="Index" exception="T:System.ArgumentException" csharp="Index &gt;= 0" vb="Index &gt;= 0">Index &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">Index &lt; 0</exception>
    </member>
    <member name="M:Utilities.DataTypes.ValueTypeExtensions.ToString(System.Byte[],System.Text.Encoding,System.Int32,System.Int32)">
      <summary>
            Converts a byte array to a string
            </summary>
      <param name="Input">input array</param>
      <param name="EncodingUsing">
            The type of encoding the string is using (defaults to UTF8)
            </param>
      <param name="Count">
            Number of bytes starting at the index to convert (use -1 for the entire array starting
            at the index)
            </param>
      <param name="Index">Index to start at</param>
      <returns>string of the byte array</returns>
    </member>
    <member name="M:Utilities.DataTypes.ValueTypeExtensions.Is(System.Char,Utilities.DataTypes.CharIs)">
      <summary>
            Is the character of a specific type
            </summary>
      <param name="Value">Value to check</param>
      <param name="CharacterType">Character type</param>
      <returns>True if it is, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ValueTypeExtensions.IsUnicode(System.Byte[])">
      <summary>
            Determines if a byte array is unicode
            </summary>
      <param name="Input">Input array</param>
      <returns>True if it's unicode, false otherwise</returns>
    </member>
    <member name="T:Utilities.DataTypes.CharIs">
      <summary>
            What type of character is this
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.WhiteSpace">
      <summary>
            White space
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.Upper">
      <summary>
            Upper case
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.Symbol">
      <summary>
            Symbol
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.Surrogate">
      <summary>
            Surrogate
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.Punctuation">
      <summary>
            Punctuation
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.Number">
      <summary>
            Number
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.LowSurrogate">
      <summary>
            Low surrogate
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.Lower">
      <summary>
            Lower
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.LetterOrDigit">
      <summary>
            letter or digit
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.Letter">
      <summary>
            Letter
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.HighSurrogate">
      <summary>
            High surrogate
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.Digit">
      <summary>
            Digit
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.CharIs.Control">
      <summary>
            Control
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Formatters.GenericStringFormatter">
      <summary>
            Generic string formatter
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Formatters.Interfaces.IStringFormatter">
      <summary>
            String formatter
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.Interfaces.IStringFormatter.Format(System.String,System.String)">
      <summary>
            Formats the string based on the pattern
            </summary>
      <param name="Input">Input string</param>
      <param name="FormatPattern">Format pattern</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.GetFormat(System.Type)">
      <summary>
            Gets the format associated with the type
            </summary>
      <param name="formatType">Format type</param>
      <returns>The appropriate formatter based on the type</returns>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.Format(System.String,System.Object,System.IFormatProvider)">
      <summary>
            Formats the string
            </summary>
      <param name="format">Format to use</param>
      <param name="arg">Argument object to use</param>
      <param name="formatProvider">Format provider to use</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.Format(System.String,System.String)">
      <summary>
            Formats the string based on the pattern
            </summary>
      <param name="Input">Input string</param>
      <param name="FormatPattern">Format pattern</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.GetMatchingInput(System.String,System.Char,System.Char@)">
      <summary>
            Gets matching input
            </summary>
      <param name="Input">Input string</param>
      <param name="FormatChar">Current format character</param>
      <param name="MatchChar">The matching character found</param>
      <returns>The remainder of the input string left</returns>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.IsValid(System.String)">
      <summary>
            Checks if the format pattern is valid
            </summary>
      <param name="FormatPattern">Format pattern</param>
      <returns>Returns true if it's valid, otherwise false</returns>
      <requires description="FormatPattern" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(FormatPattern)" vb="Not IsNullOrEmpty(FormatPattern)">!string.IsNullOrEmpty(FormatPattern)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(FormatPattern)</exception>
    </member>
    <member name="P:Utilities.DataTypes.Formatters.GenericStringFormatter.AlphaChar">
      <summary>
            Represents alpha characters (defaults to @)
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Formatters.GenericStringFormatter.DigitChar">
      <summary>
            Represents digits (defaults to #)
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Formatters.GenericStringFormatter.EscapeChar">
      <summary>
            Represents the escape character (defaults to \)
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ListMapping`2">
      <summary>
            Maps a key to a list of data
            </summary>
      <typeparam name="T1">Key value</typeparam>
      <typeparam name="T2">Type that the list should contain</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Add(`0,`1)">
      <summary>
            Adds an item to the mapping
            </summary>
      <param name="Key">Key value</param>
      <param name="Value">The value to add</param>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Adds a key value pair
            </summary>
      <param name="item">Key value pair to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Add(`0,System.Collections.Generic.ICollection{`1})">
      <summary>
            Adds a list of items to the mapping
            </summary>
      <param name="Key">Key value</param>
      <param name="Value">The values to add</param>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.ContainsKey(`0)">
      <summary>
            Determines if a key exists
            </summary>
      <param name="key">Key to check on</param>
      <returns>True if it exists, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result ⇒ this.Count &gt; 0; })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = Me;&#xD;&#xA;    return result Implies Me.Count &gt; 0; })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = this;
    }
    return !result || this.Count &gt; 0; })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Remove(`0)">
      <summary>
            Remove a list of items associated with a key
            </summary>
      <param name="key">Key to use</param>
      <returns>True if the key is found, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Removes a key value pair from the list mapping
            </summary>
      <param name="item">items to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Remove(`0,`1)">
      <summary>
            Removes a key value pair from the list mapping
            </summary>
      <param name="Key">Key to remove</param>
      <param name="Value">Value to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Clear">
      <summary>
            Clears all items from the listing
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.TryGetValue(`0,System.Collections.Generic.ICollection{`1}@)">
      <summary>
            Tries to get the value associated with the key
            </summary>
      <param name="Key">Key value</param>
      <param name="Value">The values getting</param>
      <returns>True if it was able to get the value, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result == this.ContainsKey(key); })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = Me;&#xD;&#xA;    return result = Me.ContainsKey(key); })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = this;
    }
    return result == this.ContainsKey(key); })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Does this contain the key value pairs?
            </summary>
      <param name="item">Key value pair to check</param>
      <returns>True if it exists, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Contains(`0,System.Collections.Generic.ICollection{`1})">
      <summary>
            Does the list mapping contain the key value pairs?
            </summary>
      <param name="Key">Key value</param>
      <param name="Values">Value</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Contains(`0,`1)">
      <summary>
            Does the list mapping contain the key value pair?
            </summary>
      <param name="Key">Key</param>
      <param name="Value">Value</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}}[],System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">array index</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator for this object</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator for this object</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Items">
      <summary>
            Container holding the data
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Count">
      <summary>
            The number of items in the listing
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.IsReadOnly">
      <summary>
            Not read only
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Keys">
      <summary>
            The list of keys within the mapping
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Values">
      <summary>
            List that contains the list of values
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Item(`0)">
      <summary>
            Gets a list of values associated with a key
            </summary>
      <param name="key">Key to look for</param>
      <returns>The list of values</returns>
    </member>
    <member name="T:Utilities.DataTypes.MathExtensions">
      <summary>
            Extension methods that add basic math functions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Absolute(System.Decimal)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Absolute(System.Double)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Absolute(System.Single)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Absolute(System.Int32)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Absolute(System.Int64)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
      <requires exception="T:System.ArgumentException" csharp="Value != long.MinValue" vb="Value &lt;&gt; long.MinValue">Value != long.MinValue</requires>
      <exception cref="T:System.ArgumentException">Value == long.MinValue</exception>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Absolute(System.Int16)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
      <requires exception="T:System.ArgumentException" csharp="Value != -32768" vb="Value &lt;&gt; -32768">Value != -32768</requires>
      <exception cref="T:System.ArgumentException">Value == -32768</exception>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Exp(System.Double)">
      <summary>
            Returns E raised to the specified power
            </summary>
      <param name="Value">Power to raise E by</param>
      <returns>E raised to the specified power</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Factorial(System.Int32)">
      <summary>
            Calculates the factorial for a number
            </summary>
      <param name="Input">Input value (N!)</param>
      <returns>The factorial specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.GreatestCommonDenominator(System.Int32,System.Int32)">
      <summary>
            Returns the greatest common denominator between value1 and value2
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>The greatest common denominator if one exists</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.GreatestCommonDenominator(System.Int32,System.UInt32)">
      <summary>
            Returns the greatest common denominator between value1 and value2
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>The greatest common denominator if one exists</returns>
      <requires exception="T:System.ArgumentException" csharp="Value2 != int.MinValue" vb="Value2 &lt;&gt; int.MinValue">Value2 != int.MinValue</requires>
      <exception cref="T:System.ArgumentException">Value2 == int.MinValue</exception>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.GreatestCommonDenominator(System.UInt32,System.UInt32)">
      <summary>
            Returns the greatest common denominator between value1 and value2
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>The greatest common denominator if one exists</returns>
      <requires exception="T:System.ArgumentException" csharp="Value1 != int.MinValue" vb="Value1 &lt;&gt; int.MinValue">Value1 != int.MinValue</requires>
      <exception cref="T:System.ArgumentException">Value1 == int.MinValue</exception>
      <requires exception="T:System.ArgumentException" csharp="Value2 != int.MinValue" vb="Value2 &lt;&gt; int.MinValue">Value2 != int.MinValue</requires>
      <exception cref="T:System.ArgumentException">Value2 == int.MinValue</exception>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Log(System.Double)">
      <summary>
            Returns the natural (base e) logarithm of a specified number
            </summary>
      <param name="Value">Specified number</param>
      <returns>The natural logarithm of the specified number</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Log(System.Double,System.Double)">
      <summary>
            Returns the logarithm of a specified number in a specified base
            </summary>
      <param name="Value">Value</param>
      <param name="Base">Base</param>
      <returns>The logarithm of a specified number in a specified base</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Log10(System.Double)">
      <summary>
            Returns the base 10 logarithm of a specified number
            </summary>
      <param name="Value">Value</param>
      <returns>The base 10 logarithm of the specified number</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Median``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Gets the median from the list
            </summary>
      <typeparam name="T">The data type of the list</typeparam>
      <param name="Values">The list of values</param>
      <returns>The median value</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Mode``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Gets the mode (item that occurs the most) from the list
            </summary>
      <typeparam name="T">The data type of the list</typeparam>
      <param name="Values">The list of values</param>
      <returns>The mode value</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Pow(System.Double,System.Double)">
      <summary>
            Raises Value to the power of Power
            </summary>
      <param name="Value">Value to raise</param>
      <param name="Power">Power</param>
      <returns>The resulting value</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Round(System.Double,System.Int32,System.MidpointRounding)">
      <summary>
            Rounds the value to the number of digits
            </summary>
      <param name="Value">Value to round</param>
      <param name="Digits">Digits to round to</param>
      <param name="Rounding">Rounding mode to use</param>
      <returns />
      <requires exception="T:System.ArgumentException" csharp="Digits &gt;= 0" vb="Digits &gt;= 0">Digits &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">Digits &lt; 0</exception>
      <requires exception="T:System.ArgumentException" csharp="Digits &lt;= 15" vb="Digits &lt;= 15">Digits &lt;= 15</requires>
      <exception cref="T:System.ArgumentException">Digits &gt; 15</exception>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.StandardDeviation(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Gets the standard deviation
            </summary>
      <param name="Values">List of values</param>
      <returns>The standard deviation</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Sqrt(System.Double)">
      <summary>
            Returns the square root of a value
            </summary>
      <param name="Value">Value to take the square root of</param>
      <returns>The square root</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Variance(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Calculates the variance of a list of values
            </summary>
      <param name="Values">List of values</param>
      <returns>The variance</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Variance(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>
            Calculates the variance of a list of values
            </summary>
      <param name="Values">List of values</param>
      <returns>The variance</returns>
    </member>
    <member name="M:Utilities.DataTypes.MathExtensions.Variance(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>
            Calculates the variance of a list of values
            </summary>
      <param name="Values">List of values</param>
      <returns>The variance</returns>
    </member>
    <member name="T:Utilities.DataTypes.PermutationExtensions">
      <summary>
            Permutation extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.PermutationExtensions.Permute``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds all permutations of the items within the list
            </summary>
      <typeparam name="T">Object type in the list</typeparam>
      <param name="Input">Input list</param>
      <returns>The list of permutations</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="T:Utilities.DataTypes.PredicateExtensions">
      <summary>
            Predicate extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.PredicateExtensions.AddToSet``1(System.Predicate{``0},``0[])">
      <summary>
            Adds the given values to the predicate set
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate">Predicate to add to</param>
      <param name="Values">Values to add</param>
      <returns>The resulting predicate set</returns>
    </member>
    <member name="M:Utilities.DataTypes.PredicateExtensions.CartesianProduct``2(System.Predicate{``0},System.Predicate{``1})">
      <summary>
            Treats the predicates as sets and does a cartesian product of them
            </summary>
      <typeparam name="T1">Type 1</typeparam>
      <typeparam name="T2">Type 2</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The cartesian product</returns>
    </member>
    <member name="M:Utilities.DataTypes.PredicateExtensions.Difference``1(System.Predicate{``0},System.Predicate{``0})">
      <summary>
            Treats the predicates as sets and does a difference
            </summary>
      <typeparam name="T">Data Type</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The difference of the two predicates</returns>
    </member>
    <member name="M:Utilities.DataTypes.PredicateExtensions.Intersect``1(System.Predicate{``0},System.Predicate{``0})">
      <summary>
            Treats predicates as sets and intersects them together
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The intersected predicate</returns>
    </member>
    <member name="M:Utilities.DataTypes.PredicateExtensions.RelativeComplement``1(System.Predicate{``0},System.Predicate{``0})">
      <summary>
            Treats predicates as sets and returns the relative complement
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The relative complement</returns>
    </member>
    <member name="M:Utilities.DataTypes.PredicateExtensions.RemoveFromSet``1(System.Predicate{``0},``0[])">
      <summary>
            Removes the values from the predicate set
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate">Predicate</param>
      <param name="Values">Values to remove</param>
      <returns>The resulting set</returns>
    </member>
    <member name="M:Utilities.DataTypes.PredicateExtensions.Union``1(System.Predicate{``0},System.Predicate{``0})">
      <summary>
            Treats predicates as sets and unions them together
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The unioned predicate</returns>
    </member>
    <member name="T:Utilities.DataTypes.Fraction">
      <summary>
            Represents a fraction
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Numerator">Numerator</param>
      <param name="Denominator">Denominator</param>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.#ctor(System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="Numerator">Numerator</param>
      <param name="Denominator">Denominator</param>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.#ctor(System.Decimal,System.Decimal)">
      <summary>
            Constructor
            </summary>
      <param name="Numerator">Numerator</param>
      <param name="Denominator">Denominator</param>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.#ctor(System.Single,System.Single)">
      <summary>
            Constructor
            </summary>
      <param name="Numerator">Numerator</param>
      <param name="Denominator">Denominator</param>
      <requires exception="T:System.ArgumentException" csharp="Denominator != -2.14748365E+09f" vb="Denominator &lt;&gt; -2.147484E+09">Denominator != -2.14748365E+09f</requires>
      <exception cref="T:System.ArgumentException">Denominator == -2.14748365E+09f</exception>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.ToString">
      <summary>
            Displays the fraction as a string
            </summary>
      <returns>The fraction as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.GetHashCode">
      <summary>
            Gets the hash code of the fraction
            </summary>
      <returns>The hash code of the fraction</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.Equals(System.Object)">
      <summary>
            Determines if the fractions are equal
            </summary>
      <param name="obj">object to check</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.Reduce">
      <summary>
            Reduces the fraction (finds the greatest common denominator and divides the
            numerator/denominator by it).
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.Inverse">
      <summary>
            Returns the inverse of the fraction
            </summary>
      <returns>The inverse</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Equality(Utilities.DataTypes.Fraction,Utilities.DataTypes.Fraction)">
      <summary>
            Equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Equality(Utilities.DataTypes.Fraction,System.Double)">
      <summary>
            Equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Equality(System.Double,Utilities.DataTypes.Fraction)">
      <summary>
            Equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Inequality(Utilities.DataTypes.Fraction,Utilities.DataTypes.Fraction)">
      <summary>
            Not equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Inequality(Utilities.DataTypes.Fraction,System.Double)">
      <summary>
            Not equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Inequality(System.Double,Utilities.DataTypes.Fraction)">
      <summary>
            Not equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Implicit(Utilities.DataTypes.Fraction)~System.Double">
      <summary>
            Converts the fraction to a double
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The fraction as a double</returns>
      <requires description="Fraction" exception="T:System.ArgumentNullException" csharp="Fraction != (Utilities.DataTypes.Fraction)null" vb="Fraction &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">Fraction != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!Fraction != (Utilities.DataTypes.Fraction)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Implicit(Utilities.DataTypes.Fraction)~System.Decimal">
      <summary>
            Converts the fraction to a decimal
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The fraction as a decimal</returns>
      <requires description="Fraction" exception="T:System.ArgumentNullException" csharp="Fraction != (Utilities.DataTypes.Fraction)null" vb="Fraction &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">Fraction != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!Fraction != (Utilities.DataTypes.Fraction)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Implicit(Utilities.DataTypes.Fraction)~System.Single">
      <summary>
            Converts the fraction to a float
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The fraction as a float</returns>
      <requires description="Fraction" exception="T:System.ArgumentNullException" csharp="Fraction != (Utilities.DataTypes.Fraction)null" vb="Fraction &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">Fraction != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!Fraction != (Utilities.DataTypes.Fraction)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Implicit(System.Double)~Utilities.DataTypes.Fraction">
      <summary>
            Converts the double to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The double as a fraction</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Implicit(System.Decimal)~Utilities.DataTypes.Fraction">
      <summary>
            Converts the decimal to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The decimal as a fraction</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Implicit(System.Single)~Utilities.DataTypes.Fraction">
      <summary>
            Converts the float to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The float as a fraction</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Implicit(System.Int32)~Utilities.DataTypes.Fraction">
      <summary>
            Converts the int to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The int as a fraction</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Implicit(System.UInt32)~Utilities.DataTypes.Fraction">
      <summary>
            Converts the uint to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The uint as a fraction</returns>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Implicit(Utilities.DataTypes.Fraction)~System.String">
      <summary>
            Converts the fraction to a string
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The fraction as a string</returns>
      <requires description="Fraction" exception="T:System.ArgumentNullException" csharp="Fraction != (Utilities.DataTypes.Fraction)null" vb="Fraction &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">Fraction != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!Fraction != (Utilities.DataTypes.Fraction)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Multiply(Utilities.DataTypes.Fraction,Utilities.DataTypes.Fraction)">
      <summary>
            Multiplication
            </summary>
      <param name="First">First fraction</param>
      <param name="Second">Second fraction</param>
      <returns>The resulting fraction</returns>
      <requires description="First" exception="T:System.ArgumentNullException" csharp="First != (Utilities.DataTypes.Fraction)null" vb="First &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">First != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!First != (Utilities.DataTypes.Fraction)null</exception>
      <requires description="Second" exception="T:System.ArgumentNullException" csharp="Second != (Utilities.DataTypes.Fraction)null" vb="Second &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">Second != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!Second != (Utilities.DataTypes.Fraction)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Addition(Utilities.DataTypes.Fraction,Utilities.DataTypes.Fraction)">
      <summary>
            Addition
            </summary>
      <param name="First">First fraction</param>
      <param name="Second">Second fraction</param>
      <returns>The added fraction</returns>
      <requires description="First" exception="T:System.ArgumentNullException" csharp="First != (Utilities.DataTypes.Fraction)null" vb="First &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">First != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!First != (Utilities.DataTypes.Fraction)null</exception>
      <requires description="Second" exception="T:System.ArgumentNullException" csharp="Second != (Utilities.DataTypes.Fraction)null" vb="Second &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">Second != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!Second != (Utilities.DataTypes.Fraction)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Subtraction(Utilities.DataTypes.Fraction,Utilities.DataTypes.Fraction)">
      <summary>
            Subtraction
            </summary>
      <param name="First">First fraction</param>
      <param name="Second">Second fraction</param>
      <returns>The subtracted fraction</returns>
      <requires description="First" exception="T:System.ArgumentNullException" csharp="First != (Utilities.DataTypes.Fraction)null" vb="First &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">First != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!First != (Utilities.DataTypes.Fraction)null</exception>
      <requires description="Second" exception="T:System.ArgumentNullException" csharp="Second != (Utilities.DataTypes.Fraction)null" vb="Second &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">Second != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!Second != (Utilities.DataTypes.Fraction)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_Division(Utilities.DataTypes.Fraction,Utilities.DataTypes.Fraction)">
      <summary>
            Division
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>The divided fraction</returns>
      <requires description="First" exception="T:System.ArgumentNullException" csharp="First != (Utilities.DataTypes.Fraction)null" vb="First &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">First != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!First != (Utilities.DataTypes.Fraction)null</exception>
      <requires description="Second" exception="T:System.ArgumentNullException" csharp="Second != (Utilities.DataTypes.Fraction)null" vb="Second &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">Second != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!Second != (Utilities.DataTypes.Fraction)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Fraction.op_UnaryNegation(Utilities.DataTypes.Fraction)">
      <summary>
            Negation of the fraction
            </summary>
      <param name="First">Fraction to negate</param>
      <returns>The negated fraction</returns>
      <requires description="First" exception="T:System.ArgumentNullException" csharp="First != (Utilities.DataTypes.Fraction)null" vb="First &lt;&gt; ((Utilities.DataTypes.Fraction)Nothing) ">First != (Utilities.DataTypes.Fraction)null</requires>
      <exception cref="T:System.ArgumentNullException">!First != (Utilities.DataTypes.Fraction)null</exception>
    </member>
    <member name="P:Utilities.DataTypes.Fraction.Denominator">
      <summary>
            Denominator of the fraction
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Fraction.Numerator">
      <summary>
            Numerator of the faction
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Matrix">
      <summary>
            Matrix used in linear algebra
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.#ctor(System.Int32,System.Int32,System.Double[0:,0:])">
      <summary>
            Constructor
            </summary>
      <param name="Width">Width of the matrix</param>
      <param name="Height">Height of the matrix</param>
      <param name="Values">Values to use in the matrix</param>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_Subtraction(Utilities.DataTypes.Matrix,Utilities.DataTypes.Matrix)">
      <summary>
            Subtracts two matrices
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.DataTypes.Matrix)null" vb="M1 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M1 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.DataTypes.Matrix)null</exception>
      <requires description="M2" exception="T:System.ArgumentNullException" csharp="M2 != (Utilities.DataTypes.Matrix)null" vb="M2 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M2 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M2 != (Utilities.DataTypes.Matrix)null</exception>
      <requires description="Both matrices must be the same dimensions." exception="T:System.ArgumentException" csharp="M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height" vb="M1.Width = M2.Width AndAlso M1.Height = M2.Height">M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height</requires>
      <exception cref="T:System.ArgumentException">M1.Width != M2.Width ? !false : M1.Height != M2.Height</exception>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_UnaryNegation(Utilities.DataTypes.Matrix)">
      <summary>
            Negates a matrix
            </summary>
      <param name="M1">Matrix 1</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.DataTypes.Matrix)null" vb="M1 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M1 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.DataTypes.Matrix)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_Inequality(Utilities.DataTypes.Matrix,Utilities.DataTypes.Matrix)">
      <summary>
            Determines if two matrices are unequal
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_Multiply(Utilities.DataTypes.Matrix,Utilities.DataTypes.Matrix)">
      <summary>
            Multiplies two matrices
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.DataTypes.Matrix)null" vb="M1 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M1 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.DataTypes.Matrix)null</exception>
      <requires description="M2" exception="T:System.ArgumentNullException" csharp="M2 != (Utilities.DataTypes.Matrix)null" vb="M2 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M2 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M2 != (Utilities.DataTypes.Matrix)null</exception>
      <requires description="Both matrices must be the same dimensions." exception="T:System.ArgumentException" csharp="M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height" vb="M1.Width = M2.Width AndAlso M1.Height = M2.Height">M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height</requires>
      <exception cref="T:System.ArgumentException">M1.Width != M2.Width ? !false : M1.Height != M2.Height</exception>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_Multiply(Utilities.DataTypes.Matrix,System.Double)">
      <summary>
            Multiplies a matrix by a value
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="D">Value to multiply by</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.DataTypes.Matrix)null" vb="M1 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M1 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.DataTypes.Matrix)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_Multiply(System.Double,Utilities.DataTypes.Matrix)">
      <summary>
            Multiplies a matrix by a value
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="D">Value to multiply by</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.DataTypes.Matrix)null" vb="M1 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M1 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.DataTypes.Matrix)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_Division(Utilities.DataTypes.Matrix,System.Double)">
      <summary>
            Divides a matrix by a value
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="D">Value to divide by</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.DataTypes.Matrix)null" vb="M1 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M1 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.DataTypes.Matrix)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_Division(System.Double,Utilities.DataTypes.Matrix)">
      <summary>
            Divides a matrix by a value
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="D">Value to divide by</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.DataTypes.Matrix)null" vb="M1 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M1 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.DataTypes.Matrix)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_Addition(Utilities.DataTypes.Matrix,Utilities.DataTypes.Matrix)">
      <summary>
            Adds two matrices
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.DataTypes.Matrix)null" vb="M1 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M1 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.DataTypes.Matrix)null</exception>
      <requires description="M2" exception="T:System.ArgumentNullException" csharp="M2 != (Utilities.DataTypes.Matrix)null" vb="M2 &lt;&gt; ((Utilities.DataTypes.Matrix)Nothing) ">M2 != (Utilities.DataTypes.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M2 != (Utilities.DataTypes.Matrix)null</exception>
      <requires description="Both matrices must be the same dimensions." exception="T:System.ArgumentException" csharp="M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height" vb="M1.Width = M2.Width AndAlso M1.Height = M2.Height">M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height</requires>
      <exception cref="T:System.ArgumentException">M1.Width != M2.Width ? !false : M1.Height != M2.Height</exception>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.op_Equality(Utilities.DataTypes.Matrix,Utilities.DataTypes.Matrix)">
      <summary>
            Determines if two matrices are equal
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to check</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.GetHashCode">
      <summary>
            Gets the hash code for the object
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.ToString">
      <summary>
            Gets the string representation of the matrix
            </summary>
      <returns>The matrix as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.Determinant">
      <summary>
            Gets the determinant of a square matrix
            </summary>
      <returns>The determinant of a square matrix</returns>
      <requires description="The determinant can not be calculated for a non square matrix" exception="T:System.InvalidOperationException" csharp="this.Width == this.Height" vb="Me.Width = Me.Height">this.Width == this.Height</requires>
      <exception cref="T:System.InvalidOperationException">this.Width != this.Height</exception>
    </member>
    <member name="M:Utilities.DataTypes.Matrix.Transpose">
      <summary>
            Transposes the matrix
            </summary>
      <returns>Returns a new transposed matrix</returns>
    </member>
    <member name="P:Utilities.DataTypes.Matrix.Height">
      <summary>
            Height of the matrix
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Matrix.Values">
      <summary>
            Values for the matrix
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Matrix.Width">
      <summary>
            Width of the matrix
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Matrix.Item(System.Int32,System.Int32)">
      <summary>
            Sets the values of the matrix
            </summary>
      <param name="X">X position</param>
      <param name="Y">Y position</param>
      <returns>the value at a point in the matrix</returns>
      <getter>
        <requires description="X" exception="T:System.ArgumentOutOfRangeException" csharp="X &gt;= 0 &amp;&amp; !(X &gt; this.Width)" vb="X &gt;= 0 AndAlso Not X &gt; Me.Width">X &gt;= 0 &amp;&amp; !(X &gt; this.Width)</requires>
        <requires description="Y" exception="T:System.ArgumentOutOfRangeException" csharp="Y &gt;= 0 &amp;&amp; !(Y &gt; this.Height)" vb="Y &gt;= 0 AndAlso Not Y &gt; Me.Height">Y &gt;= 0 &amp;&amp; !(Y &gt; this.Height)</requires>
      </getter>
      <exception cref="T:System.ArgumentOutOfRangeException">X &lt; 0 ? !false : X &gt; this.Width</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Y &lt; 0 ? !false : Y &gt; this.Height</exception>
      <setter>
        <requires description="X" exception="T:System.ArgumentOutOfRangeException" csharp="X &gt;= 0 &amp;&amp; !(X &gt; this.Width)" vb="X &gt;= 0 AndAlso Not X &gt; Me.Width">X &gt;= 0 &amp;&amp; !(X &gt; this.Width)</requires>
        <requires description="Y" exception="T:System.ArgumentOutOfRangeException" csharp="Y &gt;= 0 &amp;&amp; !(Y &gt; this.Height)" vb="Y &gt;= 0 AndAlso Not Y &gt; Me.Height">Y &gt;= 0 &amp;&amp; !(Y &gt; this.Height)</requires>
      </setter>
      <exception cref="T:System.ArgumentOutOfRangeException">X &lt; 0 ? !false : X &gt; this.Width</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Y &lt; 0 ? !false : Y &gt; this.Height</exception>
    </member>
    <member name="T:Utilities.DataTypes.Set`1">
      <summary>
            Class to be used for sets of data
            </summary>
      <typeparam name="T">Type that the set holds</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="InitialSize">Initial size</param>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.Contains(Utilities.DataTypes.Set{`0})">
      <summary>
            Used to tell if this set contains the other
            </summary>
      <param name="Set">Set to check against</param>
      <returns>True if it is, false otherwise</returns>
      <requires description="Set" exception="T:System.ArgumentNullException" csharp="Set != (Utilities.DataTypes.Set&lt;T&gt;)null" vb="Set &lt;&gt; ((Utilities.DataTypes.Set(Of T))Nothing) ">Set != (Utilities.DataTypes.Set&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Set != (Utilities.DataTypes.Set&lt;T&gt;)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.Intersect(Utilities.DataTypes.Set{`0})">
      <summary>
            Determines if the sets intersect
            </summary>
      <param name="Set">Set to check against</param>
      <returns>True if they do, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.IsSubset(Utilities.DataTypes.Set{`0})">
      <summary>
            Used to tell if this is a subset of the other
            </summary>
      <param name="Set">Set to check against</param>
      <returns>True if it is, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.GetIntersection(Utilities.DataTypes.Set{`0},Utilities.DataTypes.Set{`0})">
      <summary>
            Gets the intersection of set 1 and set 2
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>The intersection of the two sets</returns>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.op_Subtraction(Utilities.DataTypes.Set{`0},Utilities.DataTypes.Set{`0})">
      <summary>
            Removes items from set 2 from set 1
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>The resulting set</returns>
      <requires description="Set1" exception="T:System.ArgumentNullException" csharp="Set1 != (Utilities.DataTypes.Set&lt;T&gt;)null" vb="Set1 &lt;&gt; ((Utilities.DataTypes.Set(Of T))Nothing) ">Set1 != (Utilities.DataTypes.Set&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Set1 != (Utilities.DataTypes.Set&lt;T&gt;)null</exception>
      <requires description="Set2" exception="T:System.ArgumentNullException" csharp="Set2 != (Utilities.DataTypes.Set&lt;T&gt;)null" vb="Set2 &lt;&gt; ((Utilities.DataTypes.Set(Of T))Nothing) ">Set2 != (Utilities.DataTypes.Set&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Set2 != (Utilities.DataTypes.Set&lt;T&gt;)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.op_Inequality(Utilities.DataTypes.Set{`0},Utilities.DataTypes.Set{`0})">
      <summary>
            Determines if the two sets are not equivalent
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>False if they are, true otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.op_Addition(Utilities.DataTypes.Set{`0},Utilities.DataTypes.Set{`0})">
      <summary>
            Adds two sets together
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>The joined sets</returns>
      <requires description="Set1" exception="T:System.ArgumentNullException" csharp="Set1 != (Utilities.DataTypes.Set&lt;T&gt;)null" vb="Set1 &lt;&gt; ((Utilities.DataTypes.Set(Of T))Nothing) ">Set1 != (Utilities.DataTypes.Set&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Set1 != (Utilities.DataTypes.Set&lt;T&gt;)null</exception>
      <requires description="Set2" exception="T:System.ArgumentNullException" csharp="Set2 != (Utilities.DataTypes.Set&lt;T&gt;)null" vb="Set2 &lt;&gt; ((Utilities.DataTypes.Set(Of T))Nothing) ">Set2 != (Utilities.DataTypes.Set&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Set2 != (Utilities.DataTypes.Set&lt;T&gt;)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.op_Equality(Utilities.DataTypes.Set{`0},Utilities.DataTypes.Set{`0})">
      <summary>
            Determines if the two sets are equivalent
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.Equals(System.Object)">
      <summary>
            Determines if the two sets are equivalent
            </summary>
      <param name="obj">The object to compare to</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.GetHashCode">
      <summary>
            Returns the hash code for the object
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="M:Utilities.DataTypes.Set`1.ToString">
      <summary>
            Returns the set as a string
            </summary>
      <returns>The set as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.DataTypes.Vector3">
      <summary>
            Vector class (holds three items)
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="X">X direction</param>
      <param name="Y">Y direction</param>
      <param name="Z">Z direction</param>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.Normalize">
      <summary>
            Normalizes the vector
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.Equals(System.Object)">
      <summary>
            Determines if the items are equal
            </summary>
      <param name="obj">Object to compare</param>
      <returns>true if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.GetHashCode">
      <summary>
            Gets the hash code
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.ToString">
      <summary>
            To string function
            </summary>
      <returns>String representation of the vector</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.Angle(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Determines the angle between the vectors
            </summary>
      <param name="V1">Vector 1</param>
      <param name="V2">Vector 2</param>
      <returns>Angle between the vectors</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.Distance(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            The distance between two vectors
            </summary>
      <param name="V1">Vector 1</param>
      <param name="V2">Vector 2</param>
      <returns>Distance between the vectors</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.DotProduct(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Does a dot product
            </summary>
      <param name="V1">Vector 1</param>
      <param name="V2">Vector 2</param>
      <returns>a dot product</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.Interpolate(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3,System.Double)">
      <summary>
            Interpolates between the vectors
            </summary>
      <param name="V1">Vector 1</param>
      <param name="V2">Vector 2</param>
      <param name="Control">Percent to move between 1 and 2</param>
      <returns>The interpolated vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_Subtraction(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Subtraction
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_UnaryNegation(Utilities.DataTypes.Vector3)">
      <summary>
            Negation
            </summary>
      <param name="V1">Item 1</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_Inequality(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Not equals
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_Multiply(Utilities.DataTypes.Vector3,System.Double)">
      <summary>
            Multiplication
            </summary>
      <param name="V1">Item 1</param>
      <param name="D">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_Multiply(System.Double,Utilities.DataTypes.Vector3)">
      <summary>
            Multiplication
            </summary>
      <param name="V1">Item 1</param>
      <param name="D">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_Multiply(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Does a cross product
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_Division(Utilities.DataTypes.Vector3,System.Double)">
      <summary>
            Division
            </summary>
      <param name="V1">Item 1</param>
      <param name="D">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_Addition(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Addition
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_LessThan(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Less than
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_LessThanOrEqual(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Less than or equal
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_Equality(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Equals
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_GreaterThan(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Greater than
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Vector3.op_GreaterThanOrEqual(Utilities.DataTypes.Vector3,Utilities.DataTypes.Vector3)">
      <summary>
            Greater than or equal
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
      <requires description="V1" exception="T:System.ArgumentNullException" csharp="V1 != (Utilities.DataTypes.Vector3)null" vb="V1 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V1 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V1 != (Utilities.DataTypes.Vector3)null</exception>
      <requires description="V2" exception="T:System.ArgumentNullException" csharp="V2 != (Utilities.DataTypes.Vector3)null" vb="V2 &lt;&gt; ((Utilities.DataTypes.Vector3)Nothing) ">V2 != (Utilities.DataTypes.Vector3)null</requires>
      <exception cref="T:System.ArgumentNullException">!V2 != (Utilities.DataTypes.Vector3)null</exception>
    </member>
    <member name="P:Utilities.DataTypes.Vector3.Array">
      <summary>
            Used for converting this to an array and back
            </summary>
      <setter>
        <requires description="value" exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      </setter>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
    </member>
    <member name="P:Utilities.DataTypes.Vector3.Magnitude">
      <summary>
            Returns the magnitude of the vector
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Vector3.X">
      <summary>
            X value
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Vector3.Y">
      <summary>
            Y Value
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Vector3.Z">
      <summary>
            Z value
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Patterns.BaseClasses.Singleton`1">
      <summary>
            Base class used for singletons
            </summary>
      <typeparam name="T">The class type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.Singleton`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Patterns.BaseClasses.Singleton`1.Instance">
      <summary>
            Gets the instance of the singleton
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Patterns.Factory`2">
      <summary>
            Factory class
            </summary>
      <typeparam name="Key">The "message" type</typeparam>
      <typeparam name="T">The class type that you want created</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.Create(`0)">
      <summary>
            Creates an instance associated with the key
            </summary>
      <param name="Key">Registered item</param>
      <returns>The type returned by the initializer</returns>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.Exists(`0)">
      <summary>
            Determines if a key has been registered
            </summary>
      <param name="Key">Key to check</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.Register(`0,`1)">
      <summary>
            Registers an item
            </summary>
      <param name="Key">Item to register</param>
      <param name="Result">The object to be returned</param>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.Register(`0,System.Func{`1})">
      <summary>
            Registers an item
            </summary>
      <param name="Key">Item to register</param>
      <param name="Constructor">The function to call when creating the item</param>
    </member>
    <member name="P:Utilities.DataTypes.Patterns.Factory`2.Constructors">
      <summary>
            List of constructors/initializers
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Patterns.IFluentInterface">
      <summary>
            Helps in fluent interface design to hide ToString, Equals, and GetHashCode
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.IFluentInterface.Equals(System.Object)">
      <summary>
            Hides equals
            </summary>
      <param name="obj" />
      <returns />
    </member>
    <member name="M:Utilities.DataTypes.Patterns.IFluentInterface.GetHashCode">
      <summary>
            Hides GetHashCode
            </summary>
      <returns />
    </member>
    <member name="M:Utilities.DataTypes.Patterns.IFluentInterface.GetType">
      <summary>
            Hides GetType
            </summary>
      <returns />
    </member>
    <member name="M:Utilities.DataTypes.Patterns.IFluentInterface.ToString">
      <summary>
            Hides ToString
            </summary>
      <returns />
    </member>
    <member name="T:Utilities.DataTypes.PriorityQueue`1">
      <summary>
            Helper class that implements a priority queue
            </summary>
      <typeparam name="T">The type of the values placed in the queue</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Add(System.Int32,System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds an item to the queue
            </summary>
      <param name="Priority">Priority</param>
      <param name="Value">Items to add</param>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Add(System.Collections.Generic.KeyValuePair{System.Int32,System.Collections.Generic.ICollection{`0}})">
      <summary>
            Adds an item to the queue
            </summary>
      <param name="item">Item to add</param>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Add(System.Int32,`0)">
      <summary>
            Adds an item to the queue
            </summary>
      <param name="Priority">Priority</param>
      <param name="Value">Item to add</param>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Peek">
      <summary>
            Peek at the next thing in the queue
            </summary>
      <returns>The next item in queue or default(T) if it is empty</returns>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Pop">
      <summary>
            Removes an item from the queue and returns it
            </summary>
      <returns>The next item in the queue</returns>
    </member>
    <member name="P:Utilities.DataTypes.PriorityQueue`1.HighestKey">
      <summary>
            Highest value key
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.RingBuffer`1">
      <summary>
            Implements a ring buffer
            </summary>
      <typeparam name="T">Type of the data it holds</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.#ctor(System.Int32,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="MaxCapacity">Max capacity for the circular buffer</param>
      <param name="AllowOverflow">Is overflow allowed (defaults to false)</param>
      <requires description="Max capacity must be above 0" exception="T:System.ArgumentException" csharp="MaxCapacity &gt; 0" vb="MaxCapacity &gt; 0">MaxCapacity &gt; 0</requires>
      <exception cref="T:System.ArgumentException">MaxCapacity &lt;= 0</exception>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Add(`0)">
      <summary>
            Adds an item to the buffer
            </summary>
      <param name="item">Item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Add(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a number of items to the buffer
            </summary>
      <param name="Items">Items to add</param>
      <requires description="Items" exception="T:System.ArgumentNullException" csharp="Items != null" vb="Items &lt;&gt; Nothing">Items != null</requires>
      <exception cref="T:System.ArgumentNullException">Items == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Add(`0[],System.Int32,System.Int32)">
      <summary>
            Adds a number of items to the buffer
            </summary>
      <param name="buffer">Items to add</param>
      <param name="count">Number of items to add</param>
      <param name="offset">Offset to start at</param>
      <requires description="buffer" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires description="buffer" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Clear">
      <summary>
            Clears the buffer
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Contains(`0)">
      <summary>
            Determines if the buffer contains the item
            </summary>
      <param name="item">Item to check</param>
      <returns>True if the item is present, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the buffer to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Array index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the buffer to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="index">Array index to start at</param>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection" csharp="array.Rank == 1" vb="array.Rank = 1">array.Rank == 1</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection" csharp="index &lt;= array.Length - this.Count" vb="index &lt;= array.Length - Me.Count">index &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.GetEnumerator">
      <summary>
            Gets the enumerator for the buffer
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the buffer
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Remove">
      <summary>
            Reads the next item from the buffer
            </summary>
      <returns>The next item from the buffer</returns>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Remove(System.Int32)">
      <summary>
            Reads the next X number of items from the buffer
            </summary>
      <param name="Amount">Number of items to return</param>
      <returns>The next X items from the buffer</returns>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Remove(`0)">
      <summary>
            Removes an item from the buffer
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Remove(`0[],System.Int32,System.Int32)">
      <summary>
            Reads the next X number of items and places them in the array passed in
            </summary>
      <param name="array">Array to copy to</param>
      <param name="offset">Offset to start at</param>
      <param name="count">Number of items to read</param>
      <returns>The number of items that were read</returns>
      <requires description="array" exception="T:System.ArgumentException" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <exception cref="T:System.ArgumentException">array == null</exception>
      <requires description="array" exception="T:System.ArgumentOutOfRangeException" csharp="this.Count &lt;= array.Length - offset" vb="Me.Count &lt;= array.Length - offset">this.Count &lt;= array.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">this.Count &gt; array.Length - offset</exception>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Skip(System.Int32)">
      <summary>
            Skips ahead in the buffer
            </summary>
      <param name="Count">Number of items in the buffer to skip</param>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.op_Implicit(Utilities.DataTypes.RingBuffer{`0})~System.String">
      <summary>
            Converts the object to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != null" vb="Value &lt;&gt; Nothing">Value != null</requires>
      <exception cref="T:System.ArgumentNullException">Value == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.ToString">
      <summary>
            Returns the buffer as a string
            </summary>
      <returns>The buffer as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.AllowOverflow">
      <summary>
            Is overflow allowed?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.Count">
      <summary>
            Item count for the circular buffer
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.IsReadOnly">
      <summary>
            Is this read only?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.IsSynchronized">
      <summary>
            Is this synchronized?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.MaxCapacity">
      <summary>
            Maximum capacity
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.SyncRoot">
      <summary>
            Sync root
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_SyncRoot" inheritedFromTypeName="ICollection" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.Buffer">
      <summary>
            Buffer that the circular buffer uses
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.ReadPosition">
      <summary>
            Read position
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.WritePosition">
      <summary>
            Write position
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.Item(System.Int32)">
      <summary>
            Allows getting an item at a specific position in the buffer
            </summary>
      <param name="Position">Position to look at</param>
      <returns>The specified item</returns>
    </member>
    <member name="T:Utilities.DataTypes.StringTemplate">
      <summary>
            Acts as a template for a string
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Template">Template</param>
      <param name="KeyEnd">Ending signifier of a key</param>
      <param name="KeyStart">Starting signifier of a key</param>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor
            </summary>
      <param name="Info">Serialization info</param>
      <param name="Context">Streaming context</param>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.op_Implicit(Utilities.DataTypes.StringTemplate)~System.String">
      <summary>
            Converts the object to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != null" vb="Value &lt;&gt; Nothing">Value != null</requires>
      <exception cref="T:System.ArgumentNullException">Value == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Implements the ISerializable interface and returns the data needed to serialize the
            dictionary instance
            </summary>
      <param name="info">Serialization info</param>
      <param name="context">Streaming context</param>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.ToString">
      <summary>
            Applies the key/values to the template and returns the resulting string
            </summary>
      <returns>The resulting string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.DataTypes.StringTemplate.KeyEnd">
      <summary>
            Ending signifier of a key
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.StringTemplate.KeyStart">
      <summary>
            Beginning signifier of a key
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.StringTemplate.Template">
      <summary>
            Template
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Row">
      <summary>
            Holds an individual row
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Row.#ctor(System.Collections.Hashtable,System.String[],System.Object[])">
      <summary>
            Constructor
            </summary>
      <param name="ColumnNames">Column names</param>
      <param name="ColumnValues">Column values</param>
      <param name="ColumnNameHash">Column name hash</param>
      <requires description="ColumnValues" exception="T:System.ArgumentNullException" csharp="ColumnValues != null" vb="ColumnValues &lt;&gt; Nothing">ColumnValues != null</requires>
      <exception cref="T:System.ArgumentNullException">ColumnValues == null</exception>
    </member>
    <member name="P:Utilities.DataTypes.Row.ColumnNameHash">
      <summary>
            Column names
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Row.ColumnNames">
      <summary>
            Column names
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Row.ColumnValues">
      <summary>
            Column values
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Row.Item(System.String)">
      <summary>
            Returns a column based on the column name specified
            </summary>
      <param name="ColumnName">Column name to search for</param>
      <returns>The value specified</returns>
      <getter>
        <requires description="ColumnName" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ColumnName)" vb="Not IsNullOrEmpty(ColumnName)">!string.IsNullOrEmpty(ColumnName)</requires>
      </getter>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ColumnName)</exception>
    </member>
    <member name="P:Utilities.DataTypes.Row.Item(System.Int32)">
      <summary>
            Returns a column based on the value specified
            </summary>
      <param name="Column">Column number</param>
      <returns>The value specified</returns>
      <getter>
        <requires description="Column" exception="T:System.ArgumentOutOfRangeException" csharp="Column &gt;= 0" vb="Column &gt;= 0">Column &gt;= 0</requires>
      </getter>
      <exception cref="T:System.ArgumentOutOfRangeException">Column &lt; 0</exception>
    </member>
    <member name="T:Utilities.DataTypes.Table">
      <summary>
            Holds tabular information
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Table.#ctor(System.String[])">
      <summary>
            Constructor
            </summary>
      <param name="ColumnNames">Column names</param>
      <requires description="ColumnNames" exception="T:System.ArgumentNullException" csharp="ColumnNames != null" vb="ColumnNames &lt;&gt; Nothing">ColumnNames != null</requires>
      <exception cref="T:System.ArgumentNullException">ColumnNames == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Table.#ctor(System.Data.IDataReader)">
      <summary>
            Constructor
            </summary>
      <param name="Reader">Data reader to get the data from</param>
      <requires description="Reader" exception="T:System.ArgumentNullException" csharp="Reader != null" vb="Reader &lt;&gt; Nothing">Reader != null</requires>
      <exception cref="T:System.ArgumentNullException">Reader == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.Table.AddRow(System.Object[])">
      <summary>
            Adds a row using the objects passed in
            </summary>
      <param name="Objects">Objects to create the row from</param>
      <returns>This</returns>
      <requires description="Objects" exception="T:System.ArgumentNullException" csharp="Objects != null" vb="Objects &lt;&gt; Nothing">Objects != null</requires>
      <exception cref="T:System.ArgumentNullException">Objects == null</exception>
    </member>
    <member name="P:Utilities.DataTypes.Table.ColumnNameHash">
      <summary>
            Column Name hash table
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Table.ColumnNames">
      <summary>
            Column names for the table
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Table.Rows">
      <summary>
            Rows within the table
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Table.Item(System.Int32)">
      <summary>
            Gets a specific row
            </summary>
      <param name="RowNumber">Row number</param>
      <returns>The row specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.TagDictionary`2">
      <summary>
            Dictionary that matches multiple keys to each value
            </summary>
      <typeparam name="Key">Key type</typeparam>
      <typeparam name="Value">Value type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Add(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Adds a list of values to the key
            </summary>
      <param name="key">Key</param>
      <param name="value">Values to add</param>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Add(`1,`0[])">
      <summary>
            Adds a value to the dicionary
            </summary>
      <param name="Value">Value to add</param>
      <param name="Keys">Keys to associate the value with</param>
      <requires description="Keys" exception="T:System.ArgumentNullException" csharp="Keys != null" vb="Keys &lt;&gt; Nothing">Keys != null</requires>
      <exception cref="T:System.ArgumentNullException">Keys == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Adds an item to the dictionary
            </summary>
      <param name="item">item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Clear">
      <summary>
            Clears the dictionary
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Determines if the dictionary contains the key/value pair
            </summary>
      <param name="item">item to check</param>
      <returns>True if it is, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.ContainsKey(`0)">
      <summary>
            Determines if a key is in the dictionary
            </summary>
      <param name="key">Key to check</param>
      <returns>True if it exists, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result ⇒ this.Count &gt; 0; })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = Me;&#xD;&#xA;    return result Implies Me.Count &gt; 0; })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = this;
    }
    return !result || this.Count &gt; 0; })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IEnumerable{`1}}[],System.Int32)">
      <summary>
            Copies itself to an array
            </summary>
      <param name="array">Array</param>
      <param name="arrayIndex">Array index</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Remove(`0)">
      <summary>
            Removes all items that are associated with a key
            </summary>
      <param name="key">Key</param>
      <returns>Returns true if the key was found, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Removes a specific key/value pair
            </summary>
      <param name="item">item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.TryGetValue(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <summary>
            Attempts to get the values associated with a key
            </summary>
      <param name="key">Key</param>
      <param name="value">Values associated with a key</param>
      <returns>True if something is returned, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result == this.ContainsKey(key); })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = Me;&#xD;&#xA;    return result = Me.ContainsKey(key); })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = this;
    }
    return result == this.ContainsKey(key); })()</ensures>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Count">
      <summary>
            Number of items in the dictionary
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.IsReadOnly">
      <summary>
            Always false
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Keys">
      <summary>
            Gets the keys found in the dictionary
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Values">
      <summary>
            Gets the values found in the dictionary
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Items">
      <summary>
            Items in the dictionary
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.KeyList">
      <summary>
            List of keys that have been entered
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Item(`0)">
      <summary>
            Gets the values based on a key
            </summary>
      <param name="key">Key to get the values of</param>
      <returns>The values associated with the key</returns>
    </member>
    <member name="T:Utilities.DataTypes.TagDictionary`2.TaggedItem`2">
      <summary>
            Holds information about each value
            </summary>
      <typeparam name="TKey">Key type</typeparam>
      <typeparam name="TValue">Value type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.TaggedItem`2.#ctor(System.Collections.Generic.IEnumerable{`2},`3)">
      <summary>
            Constructor
            </summary>
      <param name="Keys">Keys</param>
      <param name="Value">Value</param>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.TaggedItem`2.#ctor(`2,`3)">
      <summary>
            Constructor
            </summary>
      <param name="Key">Key</param>
      <param name="Value">Value</param>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.TaggedItem`2.Keys">
      <summary>
            The list of keys associated with the value
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.TaggedItem`2.Value">
      <summary>
            Value
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.TaskQueue`1">
      <summary>
            Class that helps with running tasks in parallel on a set of objects (that will come in on an
            ongoing basis, think producer/consumer situations)
            </summary>
      <typeparam name="T">Object type to process</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.TaskQueue`1.#ctor(System.Int32,System.Action{`0},System.Action{System.Exception})">
      <summary>
            Constructor
            </summary>
      <param name="Capacity">
            Number of items that are allowed to be processed in the queue at one time
            </param>
      <param name="ProcessItem">Action that is used to process each item</param>
      <param name="HandleError">
            Handles an exception if it occurs (defaults to eating the error)
            </param>
      <requires description="Capacity must be greater than 0" exception="T:System.ArgumentException" csharp="Capacity &gt; 0" vb="Capacity &gt; 0">Capacity &gt; 0</requires>
      <exception cref="T:System.ArgumentException">Capacity &lt;= 0</exception>
    </member>
    <member name="M:Utilities.DataTypes.TaskQueue`1.Cancel(System.Boolean)">
      <summary>
            Cancels the queue from processing
            </summary>
      <param name="Wait">
            Determines if the function should wait for the tasks to complete before returning
            </param>
    </member>
    <member name="M:Utilities.DataTypes.TaskQueue`1.Enqueue(`0)">
      <summary>
            Adds the item to the queue to be processed
            </summary>
      <param name="Item">Item to process</param>
      <requires description="TaskQueue has been stopped" exception="T:System.InvalidOperationException" csharp="!this.IsCompleted &amp;&amp; !this.IsCanceled" vb="Not Me.IsCompleted AndAlso Not Me.IsCanceled">!this.IsCompleted &amp;&amp; !this.IsCanceled</requires>
      <exception cref="T:System.InvalidOperationException">this.IsCompleted ? !false : this.IsCanceled</exception>
    </member>
    <member name="M:Utilities.DataTypes.TaskQueue`1.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">
            True to dispose of all resources, false only disposes of native resources
            </param>
    </member>
    <member name="M:Utilities.DataTypes.TaskQueue`1.Process">
      <summary>
            Processes the queue
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TaskQueue`1.IsCanceled">
      <summary>
            Determines if it has been cancelled
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TaskQueue`1.IsComplete">
      <summary>
            Determines if it has completed all tasks
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TaskQueue`1.CancellationToken">
      <summary>
            Token used to signal cancellation
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TaskQueue`1.HandleError">
      <summary>
            Called when an exception occurs when processing the queue
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TaskQueue`1.ProcessItem">
      <summary>
            Action used to process an individual item in the queue
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TaskQueue`1.Tasks">
      <summary>
            Group of tasks that the queue uses
            </summary>
    </member>
    <member name="T:Utilities.IoC.BaseClasses.BootstrapperBase`1">
      <summary>
            Bootstrapper base class
            </summary>
      <typeparam name="Container">The actual IoC object</typeparam>
    </member>
    <member name="T:Utilities.IoC.Interfaces.IBootstrapper">
      <summary>
            Bootstrapper interface
            </summary>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.Register``1(``0,System.String)">
      <summary>
            Registers an object with the bootstrapper
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to register</param>
      <param name="Name">Name associated with the object</param>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.Register``1(System.String)">
      <summary>
            Registers a type with the default constructor
            </summary>
      <typeparam name="T">Object type to register</typeparam>
      <param name="Name">Name associated with the object</param>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.Register``2(System.String)">
      <summary>
            Registers a type with the default constructor of a child class
            </summary>
      <typeparam name="T1">Base class/interface type</typeparam>
      <typeparam name="T2">Child class type</typeparam>
      <param name="Name">Name associated with the object</param>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.Register``1(System.Func{``0},System.String)">
      <summary>
            Registers a type with a function
            </summary>
      <typeparam name="T">Type that the function returns</typeparam>
      <param name="Function">Function to register with the type</param>
      <param name="Name">Name associated with the object</param>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.Resolve``1(``0)">
      <summary>
            Resolves the object based on the type specified
            </summary>
      <typeparam name="T">Type to resolve</typeparam>
      <param name="DefaultObject">
            Default object to return if the type can not be resolved
            </param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.Resolve``1(System.String,``0)">
      <summary>
            Resolves the object based on the type specified
            </summary>
      <typeparam name="T">Type to resolve</typeparam>
      <param name="Name">Name associated with the object</param>
      <param name="DefaultObject">
            Default object to return if the type can not be resolved
            </param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.Resolve(System.Type,System.Object)">
      <summary>
            Resolves the object based on the type specified
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="DefaultObject">
            Default object to return if the type can not be resolved
            </param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.Resolve(System.Type,System.String,System.Object)">
      <summary>
            Resolves the object based on the type specified
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Name">Name associated with the object</param>
      <param name="DefaultObject">
            Default object to return if the type can not be resolved
            </param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.ResolveAll``1">
      <summary>
            Resolves the objects based on the type specified
            </summary>
      <typeparam name="T">Type to resolve</typeparam>
      <returns>A list of objects of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.Interfaces.IBootstrapper.ResolveAll(System.Type)">
      <summary>
            Resolves all objects based on the type specified
            </summary>
      <param name="ObjectType">Object type</param>
      <returns>A list of objects of the specified type</returns>
    </member>
    <member name="P:Utilities.IoC.Interfaces.IBootstrapper.Name">
      <summary>
            Name of the bootstrapper
            </summary>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Dispose">
      <summary>
            Disposes of the object
            </summary>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Register``1(``0,System.String)">
      <summary>
            Registers an object with the bootstrapper
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to register</param>
      <param name="Name">Name associated with the object</param>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Register``1(System.String)">
      <summary>
            Registers a type with the default constructor
            </summary>
      <typeparam name="T">Object type to register</typeparam>
      <param name="Name">Name associated with the object</param>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Register``2(System.String)">
      <summary>
            Registers a type with the default constructor of a child class
            </summary>
      <typeparam name="T1">Base class/interface type</typeparam>
      <typeparam name="T2">Child class type</typeparam>
      <param name="Name">Name associated with the object</param>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Register``1(System.Func{``0},System.String)">
      <summary>
            Registers a type with a function
            </summary>
      <typeparam name="T">Type that the function returns</typeparam>
      <param name="Name">Name associated with the object</param>
      <param name="Function">Function to register with the type</param>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Resolve``1(``0)">
      <summary>
            Resolves the object based on the type specified
            </summary>
      <typeparam name="T">Type to resolve</typeparam>
      <param name="DefaultObject">
            Default object to return if the type can not be resolved
            </param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Resolve``1(System.String,``0)">
      <summary>
            Resolves the object based on the type specified
            </summary>
      <typeparam name="T">Type to resolve</typeparam>
      <param name="Name">Name associated with the object</param>
      <param name="DefaultObject">
            Default object to return if the type can not be resolved
            </param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Resolve(System.Type,System.Object)">
      <summary>
            Resolves the object based on the type specified
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="DefaultObject">
            Default object to return if the type can not be resolved
            </param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Resolve(System.Type,System.String,System.Object)">
      <summary>
            Resolves the object based on the type specified
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Name">Name associated with the object</param>
      <param name="DefaultObject">
            Default object to return if the type can not be resolved
            </param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.ResolveAll``1">
      <summary>
            Resolves the objects based on the type specified
            </summary>
      <typeparam name="T">Type to resolve</typeparam>
      <returns>A list of objects of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.ResolveAll(System.Type)">
      <summary>
            Resolves all objects based on the type specified
            </summary>
      <param name="ObjectType">Object type</param>
      <returns>A list of objects of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">
            Determines if all objects should be disposed or just managed objects
            </param>
    </member>
    <member name="M:Utilities.IoC.BaseClasses.BootstrapperBase`1.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="P:Utilities.IoC.BaseClasses.BootstrapperBase`1.Name">
      <summary>
            Name of the bootstrapper
            </summary>
    </member>
    <member name="P:Utilities.IoC.BaseClasses.BootstrapperBase`1.AppContainer">
      <summary>
            The IoC container
            </summary>
    </member>
    <member name="T:Utilities.IoC.Default.DefaultBootstrapper">
      <summary>
            Default bootstrapper if one isn't found
            </summary>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.Register``1(``0,System.String)">
      <summary>
            Registers an object
            </summary>
      <typeparam name="T">Type to register</typeparam>
      <param name="Object">Object to return</param>
      <param name="Name">Name to associate with it</param>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.Register``1(System.String)">
      <summary>
            Registers an object
            </summary>
      <typeparam name="T">Type to register</typeparam>
      <param name="Name">Name to associate with it</param>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.Register``2(System.String)">
      <summary>
            Registers two types together
            </summary>
      <typeparam name="T1">Interface/base class</typeparam>
      <typeparam name="T2">Implementation</typeparam>
      <param name="Name">Name to associate with it</param>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.Register``1(System.Func{``0},System.String)">
      <summary>
            Registers a function with a type
            </summary>
      <typeparam name="T">Type to register</typeparam>
      <param name="Function">Function used to create the type</param>
      <param name="Name">Name to associate with the function</param>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.Resolve``1(``0)">
      <summary>
            Resolves an object based on the type specified
            </summary>
      <typeparam name="T">Type of object to return</typeparam>
      <param name="DefaultObject">Default value if type is not registered or error occurs</param>
      <returns>Object of the type specified</returns>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.Resolve``1(System.String,``0)">
      <summary>
            Resolves an object based on the type specified
            </summary>
      <typeparam name="T">Type of object to return</typeparam>
      <param name="DefaultObject">Default value if type is not registered or error occurs</param>
      <param name="Name">Name of the object to return</param>
      <returns>Object of the type specified</returns>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.Resolve(System.Type,System.Object)">
      <summary>
            Resolves an object based on the type specified
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="DefaultObject">Default value if type is not registered or error occurs</param>
      <returns>Object of the type specified</returns>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.Resolve(System.Type,System.String,System.Object)">
      <summary>
            Resolves an object based on the type specified
            </summary>
      <param name="Name">Name of the object to return</param>
      <param name="ObjectType">Object type</param>
      <param name="DefaultObject">Default value if type is not registered or error occurs</param>
      <returns>Object of the type specified</returns>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.ResolveAll``1">
      <summary>
            Resolves all objects of the type specified
            </summary>
      <typeparam name="T">Type of objects to return</typeparam>
      <returns>An IEnumerable containing all objects of the type specified</returns>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.ResolveAll(System.Type)">
      <summary>
            Resolves all objects of the type specified
            </summary>
      <param name="ObjectType">Object type to return</param>
      <returns>An IEnumerable containing all objects of the type specified</returns>
    </member>
    <member name="M:Utilities.IoC.Default.DefaultBootstrapper.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">Not used</param>
    </member>
    <member name="P:Utilities.IoC.Default.DefaultBootstrapper.Name">
      <summary>
            Name of the bootstrapper
            </summary>
    </member>
    <member name="P:Utilities.IoC.Default.DefaultBootstrapper.AppContainer">
      <summary>
            App container
            </summary>
    </member>
    <member name="T:Utilities.IoC.Default.Interfaces.ITypeBuilder">
      <summary>
            Type builder interface
            </summary>
    </member>
    <member name="M:Utilities.IoC.Default.Interfaces.ITypeBuilder.Create">
      <summary>
            Creates the object
            </summary>
      <returns>The object</returns>
    </member>
    <member name="P:Utilities.IoC.Default.Interfaces.ITypeBuilder.ReturnType">
      <summary>
            Return type of the builder
            </summary>
    </member>
    <member name="T:Utilities.IoC.Manager">
      <summary>
            IoC manager class
            </summary>
    </member>
    <member name="M:Utilities.IoC.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IoC.Manager.Dispose">
      <summary>
            Disposes of the object
            </summary>
    </member>
    <member name="M:Utilities.IoC.Manager.ToString">
      <summary>
            Displays information about the IoC container in string form
            </summary>
      <returns>Information about the IoC container</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IoC.Manager.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">
            Determines if all objects should be disposed or just managed objects
            </param>
    </member>
    <member name="M:Utilities.IoC.Manager.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="P:Utilities.IoC.Manager.Bootstrapper">
      <summary>
            Gets the instance of the manager
            </summary>
    </member>
    <member name="P:Utilities.IoC.Manager.InternalBootstrapper">
      <summary>
            Bootstrapper object
            </summary>
    </member>
    <member name="T:Utilities.IoC.Default.TypeBuilder`1">
      <summary>
            Type builder
            </summary>
      <typeparam name="T">Type this builder creates</typeparam>
    </member>
    <member name="M:Utilities.IoC.Default.TypeBuilder`1.#ctor(System.Func{`0})">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IoC.Default.TypeBuilder`1.Create">
      <summary>
            Creates the object
            </summary>
      <returns>The created object</returns>
    </member>
    <member name="P:Utilities.IoC.Default.TypeBuilder`1.ReturnType">
      <summary>
            Return type of the implementation
            </summary>
    </member>
    <member name="P:Utilities.IoC.Default.TypeBuilder`1.Implementation">
      <summary>
            Implementation used to create the type
            </summary>
    </member>
    <member name="T:Utilities.IO.Compression.BaseClasses.CompressorBase">
      <summary>
            Compressor base class
            </summary>
    </member>
    <member name="T:Utilities.IO.Compression.Interfaces.ICompressor">
      <summary>
            Compressor interface
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.Interfaces.ICompressor.Compress(System.Byte[])">
      <summary>
            Compresses the byte array
            </summary>
      <param name="Data">Data to compress</param>
      <returns>Compressed data</returns>
    </member>
    <member name="M:Utilities.IO.Compression.Interfaces.ICompressor.Decompress(System.Byte[])">
      <summary>
            Decompresses the data
            </summary>
      <param name="Data">Data to decompress</param>
      <returns>The decompressed data</returns>
    </member>
    <member name="P:Utilities.IO.Compression.Interfaces.ICompressor.Name">
      <summary>
            Compressor name
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.BaseClasses.CompressorBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.BaseClasses.CompressorBase.Compress(System.Byte[])">
      <summary>
            Compresses the byte array
            </summary>
      <param name="Data">Data to compress</param>
      <returns>Compressed data</returns>
    </member>
    <member name="M:Utilities.IO.Compression.BaseClasses.CompressorBase.Decompress(System.Byte[])">
      <summary>
            Decompresses the data
            </summary>
      <param name="Data">Data to decompress</param>
      <returns>The decompressed data</returns>
    </member>
    <member name="M:Utilities.IO.Compression.BaseClasses.CompressorBase.GetStream(System.IO.MemoryStream,System.IO.Compression.CompressionMode)">
      <summary>
            Gets the stream used to compress/decompress the data
            </summary>
      <param name="Stream">Memory stream used</param>
      <param name="compressionMode">Compression mode</param>
      <returns>The stream used to compress/decompress the data</returns>
    </member>
    <member name="P:Utilities.IO.Compression.BaseClasses.CompressorBase.Name">
      <summary>
            Compressor name
            </summary>
    </member>
    <member name="T:Utilities.IO.Compression.Default.DeflateCompressor">
      <summary>
            Deflate compressor
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.Default.DeflateCompressor.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.Default.DeflateCompressor.GetStream(System.IO.MemoryStream,System.IO.Compression.CompressionMode)">
      <summary>
            Gets the stream
            </summary>
      <param name="Stream">Memory stream</param>
      <param name="compressionMode">Compression mode</param>
      <returns>The compressor stream</returns>
    </member>
    <member name="P:Utilities.IO.Compression.Default.DeflateCompressor.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Compression.Default.GZipCompressor">
      <summary>
            GZip compressor
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.Default.GZipCompressor.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.Default.GZipCompressor.GetStream(System.IO.MemoryStream,System.IO.Compression.CompressionMode)">
      <summary>
            Gets the stream
            </summary>
      <param name="Stream">Memory stream</param>
      <param name="compressionMode">Compression mode</param>
      <returns>The compressor stream</returns>
    </member>
    <member name="P:Utilities.IO.Compression.Default.GZipCompressor.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Compression.Manager">
      <summary>
            Compression manager
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.Manager.Compress(System.Byte[],System.String)">
      <summary>
            Compresses the data
            </summary>
      <param name="Data">Data to compress</param>
      <param name="Compressor">Compressor name</param>
      <returns>The compressed data</returns>
    </member>
    <member name="M:Utilities.IO.Compression.Manager.Decompress(System.Byte[],System.String)">
      <summary>
            Decompresses the data
            </summary>
      <param name="Data">Data to decompress</param>
      <param name="Compressor">Compressor name</param>
      <returns>The decompressed data</returns>
    </member>
    <member name="M:Utilities.IO.Compression.Manager.ToString">
      <summary>
            String info for the manager
            </summary>
      <returns>The string info that the manager contains</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.Compression.Manager.Compressors">
      <summary>
            Compressors
            </summary>
    </member>
    <member name="T:Utilities.IO.Compression.Module.CompressionModule">
      <summary>
            Compression module
            </summary>
    </member>
    <member name="M:Utilities.IO.Compression.Module.CompressionModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.IO.Compression.Module.CompressionModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.IO.DirectoryInfo">
      <summary>
            Directory info class
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Interfaces.IDirectory">
      <summary>
            Represents a directory
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IDirectory.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,Utilities.IO.Enums.CopyOptions)">
      <summary>
            Copies the directory to the specified parent directory
            </summary>
      <param name="Directory">Directory to copy to</param>
      <param name="Options">Copy options</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IDirectory.Create">
      <summary>
            Creates the directory if it does not currently exist
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IDirectory.Delete">
      <summary>
            Deletes the directory
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IDirectory.EnumerateDirectories(System.String,System.IO.SearchOption)">
      <summary>
            Enumerates sub directories (defaults to top level sub directories)
            </summary>
      <param name="SearchPattern">Search pattern to use</param>
      <param name="Options">Search options to use</param>
      <returns>The list of directories</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IDirectory.EnumerateDirectories(System.Predicate{Utilities.IO.FileSystem.Interfaces.IDirectory},System.IO.SearchOption)">
      <summary>
            Enumerates sub directories (defaults to top level sub directories)
            </summary>
      <param name="Predicate">Predicate used to filter directories</param>
      <param name="Options">Search options to use</param>
      <returns>The list of directories</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IDirectory.EnumerateFiles(System.String,System.IO.SearchOption)">
      <summary>
            Enumerates files within the directory (defaults to top level directory and not the sub directories)
            </summary>
      <param name="SearchPattern">Search pattern to use</param>
      <param name="Options">Search options to use</param>
      <returns>The list of files</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IDirectory.EnumerateFiles(System.Predicate{Utilities.IO.FileSystem.Interfaces.IFile},System.IO.SearchOption)">
      <summary>
            Enumerates files within the directory (defaults to top level directory and not the sub directories)
            </summary>
      <param name="Predicate">Predicate used to filter files</param>
      <param name="Options">Search options to use</param>
      <returns>The list of files</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IDirectory.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves the directory to the specified parent directory
            </summary>
      <param name="Directory">Directory to move to</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IDirectory.Rename(System.String)">
      <summary>
            Renames the directory
            </summary>
      <param name="Name">The new name of the directory</param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IDirectory.Accessed">
      <summary>
            Last time it was accessed
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IDirectory.Created">
      <summary>
            When it was created
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IDirectory.Exists">
      <summary>
            Does the directory exist
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IDirectory.FullName">
      <summary>
            Full path to the directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IDirectory.Modified">
      <summary>
            When it was last modified
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IDirectory.Name">
      <summary>
            Name of the directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IDirectory.Parent">
      <summary>
            Parent directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IDirectory.Root">
      <summary>
            Root directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IDirectory.Size">
      <summary>
            Size of the contents of the directory in bytes
            </summary>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Path">Path to the directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.#ctor(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Constructor
            </summary>
      <param name="Directory">Directory object</param>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.Clone">
      <summary>
            Clones the directory object
            </summary>
      <returns>The cloned object</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.CompareTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Compares this to another directory
            </summary>
      <param name="other">Directory to compare to</param>
      <returns />
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.CompareTo(System.Object)">
      <summary>
            Compares this object to another object
            </summary>
      <param name="obj">Object to compare it to</param>
      <returns />
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,Utilities.IO.Enums.CopyOptions)">
      <summary>
            Copies the directory to the specified parent directory
            </summary>
      <param name="Directory">Directory to copy to</param>
      <param name="Options">Copy options</param>
      <returns>Returns the new directory</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.Create">
      <summary>
            Creates the directory if it does not currently exist
            </summary>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.Delete">
      <summary>
            Deletes the directory
            </summary>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
      <summary>
            Enumerates sub directories (defaults to top level sub directories)
            </summary>
      <param name="SearchPattern">Search pattern to use</param>
      <param name="Options">Search options to use</param>
      <returns>The list of directories</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.EnumerateDirectories(System.Predicate{Utilities.IO.FileSystem.Interfaces.IDirectory},System.IO.SearchOption)">
      <summary>
            Enumerates sub directories (defaults to top level sub directories)
            </summary>
      <param name="Predicate">Predicate used to filter directories</param>
      <param name="Options">Search options to use</param>
      <returns>The list of directories</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
      <summary>
            Enumerates files within the directory (defaults to top level directory and not the sub directories)
            </summary>
      <param name="SearchPattern">Search pattern to use</param>
      <param name="Options">Search options to use</param>
      <returns>The list of files</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.EnumerateFiles(System.Predicate{Utilities.IO.FileSystem.Interfaces.IFile},System.IO.SearchOption)">
      <summary>
            Enumerates files within the directory (defaults to top level directory and not the sub directories)
            </summary>
      <param name="Predicate">Predicate used to filter files</param>
      <param name="Options">Search options to use</param>
      <returns>The list of files</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.Equals(System.Object)">
      <summary>
            Determines if the two directories are the same
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they're the same, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.Equals(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Determines if the directories are equal
            </summary>
      <param name="other">Other directory</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.GetEnumerator">
      <summary>
            Enumerates the files in the directory
            </summary>
      <returns>The files in the directory</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.GetHashCode">
      <summary>
            Returns the hash code for the directory
            </summary>
      <returns>The hash code for the directory</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves the directory to the specified parent directory
            </summary>
      <param name="Directory">Directory to move to</param>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.Rename(System.String)">
      <summary>
            Renames the directory
            </summary>
      <param name="Name">The new name of the directory</param>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Enumerates the files and directories in the directory
            </summary>
      <returns>The files and directories</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.ToString">
      <summary>
            Gets info for the directory
            </summary>
      <returns>The full path to the directory</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.op_Inequality(Utilities.IO.DirectoryInfo,Utilities.IO.DirectoryInfo)">
      <summary>
            Determines if two directories are not equal
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.op_LessThan(Utilities.IO.DirectoryInfo,Utilities.IO.DirectoryInfo)">
      <summary>
            Less than
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.op_LessThanOrEqual(Utilities.IO.DirectoryInfo,Utilities.IO.DirectoryInfo)">
      <summary>
            Less than or equal
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.op_Equality(Utilities.IO.DirectoryInfo,Utilities.IO.DirectoryInfo)">
      <summary>
            Determines if two directories are equal
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.op_GreaterThan(Utilities.IO.DirectoryInfo,Utilities.IO.DirectoryInfo)">
      <summary>
            Greater than
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.DirectoryInfo.op_GreaterThanOrEqual(Utilities.IO.DirectoryInfo,Utilities.IO.DirectoryInfo)">
      <summary>
            Greater than or equal
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>The result</returns>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.Accessed">
      <summary>
            Last time it was accessed
            </summary>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.Created">
      <summary>
            When it was created
            </summary>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.Exists">
      <summary>
            Does the directory exist
            </summary>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.FullName">
      <summary>
            Full path to the directory
            </summary>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.Modified">
      <summary>
            When it was last modified
            </summary>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.Name">
      <summary>
            Name of the directory
            </summary>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.Parent">
      <summary>
            Parent directory
            </summary>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.Root">
      <summary>
            Root directory
            </summary>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.Size">
      <summary>
            Size of the contents of the directory in bytes
            </summary>
    </member>
    <member name="P:Utilities.IO.DirectoryInfo.InternalDirectory">
      <summary>
            Internal directory object
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.BaseClasses.AsymmetricBase">
      <summary>
            Asymmetric base class
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Interfaces.IAsymmetric">
      <summary>
            Asymmetric encryptor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.IAsymmetric.CreateKey(System.Boolean)">
      <summary>
            Creates a new set of keys
            </summary>
      <param name="PrivatePublic">True if private key should be included, false otherwise</param>
      <returns>XML representation of the key information</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.IAsymmetric.Decrypt(System.Byte[],System.String)">
      <summary>
            Decrypts a byte array using RSA
            </summary>
      <param name="Input">
            Input byte array (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for decryption</param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.IAsymmetric.Encrypt(System.Byte[],System.String)">
      <summary>
            Encrypts a string using RSA
            </summary>
      <param name="Input">
            Input byte array (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for encryption</param>
      <returns>An encrypted byte array (64bit string)</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.IAsymmetric.SignHash(System.String,System.String,System.String@,System.Text.Encoding)">
      <summary>
            Takes a string and creates a signed hash of it
            </summary>
      <param name="Input">Input string</param>
      <param name="Key">Key to encrypt/sign with</param>
      <param name="Hash">This will be filled with the unsigned hash</param>
      <param name="EncodingUsing">Encoding that the input is using (defaults to UTF8)</param>
      <returns>A signed hash of the input (64bit string)</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.IAsymmetric.VerifyHash(System.String,System.String,System.String)">
      <summary>
            Verifies a signed hash against the unsigned version
            </summary>
      <param name="Hash">The unsigned hash (should be 64bit string)</param>
      <param name="SignedHash">The signed hash (should be 64bit string)</param>
      <param name="Key">The key to use in decryption</param>
      <returns>True if it is verified, false otherwise</returns>
    </member>
    <member name="P:Utilities.IO.Encryption.Interfaces.IAsymmetric.Name">
      <summary>
            Name of the encryptor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.AsymmetricBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.AsymmetricBase.CreateKey(System.Boolean)">
      <summary>
            Creates a new set of keys
            </summary>
      <param name="PrivatePublic">True if private key should be included, false otherwise</param>
      <returns>XML representation of the key information</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.AsymmetricBase.Decrypt(System.Byte[],System.String)">
      <summary>
            Decrypts a byte array using RSA
            </summary>
      <param name="Input">
            Input byte array (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for decryption</param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.AsymmetricBase.Encrypt(System.Byte[],System.String)">
      <summary>
            Encrypts a string using RSA
            </summary>
      <param name="Input">
            Input byte array (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for encryption</param>
      <returns>An encrypted byte array (64bit string)</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.AsymmetricBase.SignHash(System.String,System.String,System.String@,System.Text.Encoding)">
      <summary>
            Takes a string and creates a signed hash of it
            </summary>
      <param name="Input">Input string</param>
      <param name="Key">Key to encrypt/sign with</param>
      <param name="Hash">This will be filled with the unsigned hash</param>
      <param name="EncodingUsing">Encoding that the input is using (defaults to UTF8)</param>
      <returns>A signed hash of the input (64bit string)</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.AsymmetricBase.VerifyHash(System.String,System.String,System.String)">
      <summary>
            Verifies a signed hash against the unsigned version
            </summary>
      <param name="Hash">The unsigned hash (should be 64bit string)</param>
      <param name="SignedHash">The signed hash (should be 64bit string)</param>
      <param name="Key">The key to use in decryption</param>
      <returns>True if it is verified, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.AsymmetricBase.GetProvider">
      <summary>
            Gets the provider used
            </summary>
      <returns>Asymmetric algorithm</returns>
    </member>
    <member name="P:Utilities.IO.Encryption.BaseClasses.AsymmetricBase.Name">
      <summary>
            Name of the encryptor
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.BaseClasses.HasherBase">
      <summary>
            Hasher base class
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Interfaces.IHasher">
      <summary>
            Hasher interface
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.IHasher.CanHandle(System.String)">
      <summary>
            Can this handle the algorithm specified
            </summary>
      <param name="Algorithm">The algorithm name</param>
      <returns>True if it can, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.IHasher.Hash(System.Byte[],System.String)">
      <summary>
            Hashes the data
            </summary>
      <param name="Data">Data to hash</param>
      <param name="Algorithm">Algorithm</param>
      <returns>The hashed data</returns>
    </member>
    <member name="P:Utilities.IO.Encryption.Interfaces.IHasher.Name">
      <summary>
            Hasher name
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.HasherBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.HasherBase.CanHandle(System.String)">
      <summary>
            Can this handle the algorithm specified
            </summary>
      <param name="Algorithm">The algorithm name</param>
      <returns>True if it can, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.HasherBase.Hash(System.Byte[],System.String)">
      <summary>
            Hashes the data
            </summary>
      <param name="Data">Data to hash</param>
      <param name="Algorithm">Algorithm to use</param>
      <returns>The hashed version of the data</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.HasherBase.GetAlgorithm(System.String)">
      <summary>
            Gets the hash algorithm that the system uses
            </summary>
      <param name="Algorithm">Algorithm</param>
      <returns>The hash algorithm</returns>
      <requires description="Algorithm" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Algorithm)" vb="Not IsNullOrEmpty(Algorithm)">!string.IsNullOrEmpty(Algorithm)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Algorithm)</exception>
    </member>
    <member name="P:Utilities.IO.Encryption.BaseClasses.HasherBase.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.IO.Encryption.BaseClasses.HasherBase.ImplementedAlgorithms">
      <summary>
            Algorithms this implements
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.BaseClasses.ShiftBase">
      <summary>
            Shift based encryption base class
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Interfaces.IShift">
      <summary>
            Shift based encryption interface
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.IShift.Decrypt(System.Byte[],System.Byte[])">
      <summary>
            Decrypt the data based on the key
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <returns>The decrypted data</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.IShift.Encrypt(System.Byte[],System.Byte[])">
      <summary>
            Encrypts the data based on the key
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <returns>The encrypted data</returns>
    </member>
    <member name="P:Utilities.IO.Encryption.Interfaces.IShift.Name">
      <summary>
            Name of the shift encryptor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.ShiftBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.ShiftBase.Decrypt(System.Byte[],System.Byte[])">
      <summary>
            Decrypt the data based on the key
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <returns>The decrypted data</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.ShiftBase.Encrypt(System.Byte[],System.Byte[])">
      <summary>
            Encrypts the data based on the key
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <returns>The encrypted data</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.ShiftBase.Process(System.Byte[],System.Byte[])">
      <summary>
            Actually does the encryption/decryption
            </summary>
    </member>
    <member name="P:Utilities.IO.Encryption.BaseClasses.ShiftBase.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.BaseClasses.SymmetricBase">
      <summary>
            Symmetric base class
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Interfaces.ISymmetric">
      <summary>
            Symmetric encryption
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.ISymmetric.CanHandle(System.String)">
      <summary>
            Can this handle the algorithm specified
            </summary>
      <param name="Algorithm">The algorithm name</param>
      <returns>True if it can, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.ISymmetric.Decrypt(System.Byte[],System.String,System.String,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Decrypts a byte array
            </summary>
      <param name="Data">Data to be decrypted</param>
      <param name="Key">Password to decrypt with</param>
      <param name="Algorithm">Algorithm to use for decryption</param>
      <param name="Salt">Salt to decrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.ISymmetric.Decrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.String,System.String,System.Int32)">
      <summary>
            Decrypts a byte array
            </summary>
      <param name="Data">Data to be decrypted</param>
      <param name="Key">Password to decrypt with</param>
      <param name="Algorithm">Algorithm to use for decryption</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.ISymmetric.Encrypt(System.Byte[],System.String,System.String,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to be encrypted</param>
      <param name="Key">Password to encrypt with</param>
      <param name="Salt">Salt to encrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <param name="Algorithm">Algorithm</param>
      <returns>An encrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Interfaces.ISymmetric.Encrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.String,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to be encrypted</param>
      <param name="Key">Password to encrypt with</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <param name="Algorithm">Algorithm</param>
      <returns>An encrypted byte array</returns>
    </member>
    <member name="P:Utilities.IO.Encryption.Interfaces.ISymmetric.Name">
      <summary>
            Name of the symmetric encryptor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.SymmetricBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.SymmetricBase.CanHandle(System.String)">
      <summary>
            Can this handle the algorithm specified
            </summary>
      <param name="Algorithm">The algorithm name</param>
      <returns>True if it can, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.SymmetricBase.Decrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.String,System.String,System.Int32)">
      <summary>
            Decrypts a byte array
            </summary>
      <param name="Data">Data to be decrypted</param>
      <param name="Key">Password to decrypt with</param>
      <param name="Algorithm">Algorithm to use for decryption</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.SymmetricBase.Decrypt(System.Byte[],System.String,System.String,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Decrypts a byte array
            </summary>
      <param name="Data">Data to be decrypted</param>
      <param name="Key">Password to decrypt with</param>
      <param name="Algorithm">Algorithm to use for decryption</param>
      <param name="Salt">Salt to decrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.SymmetricBase.Encrypt(System.Byte[],System.String,System.String,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to be encrypted</param>
      <param name="Key">Password to encrypt with</param>
      <param name="Salt">Salt to encrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <param name="Algorithm">Algorithm to use</param>
      <returns>The encrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.SymmetricBase.Encrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.String,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to be encrypted</param>
      <param name="Key">Password to encrypt with</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <param name="Algorithm">Algorithm to use</param>
      <returns>The encrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.BaseClasses.SymmetricBase.GetProvider(System.String)">
      <summary>
            Gets the symmetric algorithm
            </summary>
      <returns>The symmetric algorithm</returns>
      <requires description="Algorithm" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Algorithm)" vb="Not IsNullOrEmpty(Algorithm)">!string.IsNullOrEmpty(Algorithm)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Algorithm)</exception>
    </member>
    <member name="P:Utilities.IO.Encryption.BaseClasses.SymmetricBase.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.IO.Encryption.BaseClasses.SymmetricBase.ImplementedAlgorithms">
      <summary>
            Algorithms this implements
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Default.RSA">
      <summary>
            RSA Encryptor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Default.RSA.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Default.RSA.Decrypt(System.Byte[],System.String)">
      <summary>
            Decrypts a byte array using RSA
            </summary>
      <param name="Input">
            Input byte array (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for decryption</param>
      <returns>A decrypted byte array</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Key)" vb="Not IsNullOrEmpty(Key)">!string.IsNullOrEmpty(Key)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Key)</exception>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.IO.Encryption.Default.RSA.Encrypt(System.Byte[],System.String)">
      <summary>
            Encrypts a string using RSA
            </summary>
      <param name="Input">
            Input byte array (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for encryption</param>
      <returns>An encrypted byte array (64bit string)</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Key)" vb="Not IsNullOrEmpty(Key)">!string.IsNullOrEmpty(Key)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Key)</exception>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.IO.Encryption.Default.RSA.SignHash(System.String,System.String,System.String@,System.Text.Encoding)">
      <summary>
            Takes a string and creates a signed hash of it
            </summary>
      <param name="Input">Input string</param>
      <param name="Key">Key to encrypt/sign with</param>
      <param name="Hash">This will be filled with the unsigned hash</param>
      <param name="EncodingUsing">Encoding that the input is using (defaults to UTF8)</param>
      <returns>A signed hash of the input (64bit string)</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Key)" vb="Not IsNullOrEmpty(Key)">!string.IsNullOrEmpty(Key)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Key)</exception>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.IO.Encryption.Default.RSA.VerifyHash(System.String,System.String,System.String)">
      <summary>
            Verifies a signed hash against the unsigned version
            </summary>
      <param name="Hash">The unsigned hash (should be 64bit string)</param>
      <param name="SignedHash">The signed hash (should be 64bit string)</param>
      <param name="Key">The key to use in decryption</param>
      <returns>True if it is verified, false otherwise</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Key)" vb="Not IsNullOrEmpty(Key)">!string.IsNullOrEmpty(Key)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Key)</exception>
      <requires description="Hash" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Hash)" vb="Not IsNullOrEmpty(Hash)">!string.IsNullOrEmpty(Hash)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Hash)</exception>
      <requires description="SignedHash" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(SignedHash)" vb="Not IsNullOrEmpty(SignedHash)">!string.IsNullOrEmpty(SignedHash)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(SignedHash)</exception>
    </member>
    <member name="M:Utilities.IO.Encryption.Default.RSA.GetProvider">
      <summary>
            Gets the provider used
            </summary>
      <returns>Asymmetric algorithm</returns>
    </member>
    <member name="P:Utilities.IO.Encryption.Default.RSA.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Default.Hash">
      <summary>
            Hash
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Default.Hash.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.IO.Encryption.Default.Hash.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Default.Shift">
      <summary>
            Shift default class
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Default.Shift.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.IO.Encryption.Default.Shift.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Default.Symmetric">
      <summary>
            Symmetric class
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Default.Symmetric.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.IO.Encryption.Default.Symmetric.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Manager">
      <summary>
            Compression manager
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.CreateKey(System.Boolean)">
      <summary>
            Creates a new set of keys
            </summary>
      <param name="PrivatePublic">True if private key should be included, false otherwise</param>
      <returns>XML representation of the key information</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.Decrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.String,System.String,System.Int32)">
      <summary>
            Decrypts a byte array
            </summary>
      <param name="Data">Data to be decrypted</param>
      <param name="Key">Password to decrypt with</param>
      <param name="Algorithm">Algorithm to use for decryption</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.Decrypt(System.Byte[],System.String,System.String,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Decrypts a byte array
            </summary>
      <param name="Data">Data to be decrypted</param>
      <param name="Key">Password to decrypt with</param>
      <param name="Algorithm">Algorithm to use for decryption</param>
      <param name="Salt">Salt to decrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.Decrypt(System.Byte[],System.Byte[])">
      <summary>
            Decrypt the data based on the key
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <returns>The decrypted data</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.Decrypt(System.Byte[],System.String)">
      <summary>
            Decrypts a byte array using RSA
            </summary>
      <param name="Input">
            Input byte array (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for decryption</param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.Encrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.String,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to be encrypted</param>
      <param name="Key">Password to encrypt with</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <param name="Algorithm">Algorithm</param>
      <returns>An encrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.Encrypt(System.Byte[],System.String,System.String,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to be encrypted</param>
      <param name="Key">Password to encrypt with</param>
      <param name="Salt">Salt to encrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <param name="Algorithm">Algorithm</param>
      <returns>An encrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.Encrypt(System.Byte[],System.Byte[])">
      <summary>
            Encrypts the data based on the key
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <returns>The encrypted data</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.Encrypt(System.Byte[],System.String)">
      <summary>
            Encrypts a string using RSA
            </summary>
      <param name="Input">
            Input byte array (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for encryption</param>
      <returns>An encrypted byte array (64bit string)</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.Hash(System.Byte[],System.String)">
      <summary>
            Hashes the data
            </summary>
      <param name="Data">Data to hash</param>
      <param name="Algorithm">Algorithm</param>
      <returns>The hashed data</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.SignHash(System.String,System.String,System.String@,System.Text.Encoding)">
      <summary>
            Takes a string and creates a signed hash of it
            </summary>
      <param name="Input">Input string</param>
      <param name="Key">Key to encrypt/sign with</param>
      <param name="Hash">This will be filled with the unsigned hash</param>
      <param name="EncodingUsing">Encoding that the input is using (defaults to UTF8)</param>
      <returns>A signed hash of the input (64bit string)</returns>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.ToString">
      <summary>
            String info for the manager
            </summary>
      <returns>The string info that the manager contains</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.Encryption.Manager.VerifyHash(System.String,System.String,System.String)">
      <summary>
            Verifies a signed hash against the unsigned version
            </summary>
      <param name="Hash">The unsigned hash (should be 64bit string)</param>
      <param name="SignedHash">The signed hash (should be 64bit string)</param>
      <param name="Key">The key to use in decryption</param>
      <returns>True if it is verified, false otherwise</returns>
    </member>
    <member name="P:Utilities.IO.Encryption.Manager.AsymmetricAlgorithms">
      <summary>
            Asymmetric
            </summary>
    </member>
    <member name="P:Utilities.IO.Encryption.Manager.HasherAlgorithms">
      <summary>
            Hashers
            </summary>
    </member>
    <member name="P:Utilities.IO.Encryption.Manager.ShiftAlgorithms">
      <summary>
            Shift
            </summary>
    </member>
    <member name="P:Utilities.IO.Encryption.Manager.SymmetricAlgorithms">
      <summary>
            Symmetric
            </summary>
    </member>
    <member name="T:Utilities.IO.Encryption.Module.EncryptionModule">
      <summary>
            Encryption module
            </summary>
    </member>
    <member name="M:Utilities.IO.Encryption.Module.EncryptionModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.IO.Encryption.Module.EncryptionModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.IO.Enums.CopyOptions">
      <summary>
            Options used in directory copying
            </summary>
    </member>
    <member name="F:Utilities.IO.Enums.CopyOptions.CopyIfNewer">
      <summary>
            Copy if newer than the DateTime specified
            </summary>
    </member>
    <member name="F:Utilities.IO.Enums.CopyOptions.CopyAlways">
      <summary>
            Copy always
            </summary>
    </member>
    <member name="F:Utilities.IO.Enums.CopyOptions.DoNotOverwrite">
      <summary>
            Do not overwrite a file
            </summary>
    </member>
    <member name="T:Utilities.IO.CompressionType">
      <summary>
            Defines the various compression types that are available
            </summary>
    </member>
    <member name="F:Utilities.IO.CompressionType.Deflate">
      <summary>
            Deflate
            </summary>
    </member>
    <member name="F:Utilities.IO.CompressionType.GZip">
      <summary>
            GZip
            </summary>
    </member>
    <member name="T:Utilities.IO.CompressionExtensions">
      <summary>
            Extension methods dealing with compression
            </summary>
    </member>
    <member name="M:Utilities.IO.CompressionExtensions.Compress(System.Byte[],Utilities.IO.CompressionType)">
      <summary>
            Compresses the data using the specified compression type
            </summary>
      <param name="Data">Data to compress</param>
      <param name="CompressionType">Compression type</param>
      <returns>The compressed data</returns>
    </member>
    <member name="M:Utilities.IO.CompressionExtensions.Compress(System.String,System.Text.Encoding,Utilities.IO.CompressionType)">
      <summary>
            Compresses a string of data
            </summary>
      <param name="Data">Data to Compress</param>
      <param name="EncodingUsing">Encoding that the data uses (defaults to UTF8)</param>
      <param name="CompressionType">The compression type used</param>
      <returns>The data Compressed</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Data)" vb="Not IsNullOrEmpty(Data)">!string.IsNullOrEmpty(Data)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Data)</exception>
    </member>
    <member name="M:Utilities.IO.CompressionExtensions.Compress(System.Byte[],System.String)">
      <summary>
            Compresses the data using the specified compression type
            </summary>
      <param name="Data">Data to compress</param>
      <param name="CompressionType">Compression type</param>
      <returns>The compressed data</returns>
      <requires description="CompressionType" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(CompressionType)" vb="Not IsNullOrEmpty(CompressionType)">!string.IsNullOrEmpty(CompressionType)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(CompressionType)</exception>
    </member>
    <member name="M:Utilities.IO.CompressionExtensions.Compress(System.String,System.Text.Encoding,System.String)">
      <summary>
            Compresses a string of data
            </summary>
      <param name="Data">Data to Compress</param>
      <param name="EncodingUsing">Encoding that the data uses (defaults to UTF8)</param>
      <param name="CompressionType">The compression type used</param>
      <returns>The data Compressed</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Data)" vb="Not IsNullOrEmpty(Data)">!string.IsNullOrEmpty(Data)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Data)</exception>
      <requires description="CompressionType" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(CompressionType)" vb="Not IsNullOrEmpty(CompressionType)">!string.IsNullOrEmpty(CompressionType)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(CompressionType)</exception>
    </member>
    <member name="M:Utilities.IO.CompressionExtensions.Decompress(System.Byte[],Utilities.IO.CompressionType)">
      <summary>
            Decompresses the byte array that is sent in
            </summary>
      <param name="Data">Data to decompress</param>
      <param name="CompressionType">The compression type used</param>
      <returns>The data decompressed</returns>
    </member>
    <member name="M:Utilities.IO.CompressionExtensions.Decompress(System.String,System.Text.Encoding,Utilities.IO.CompressionType)">
      <summary>
            Decompresses a string of data
            </summary>
      <param name="Data">Data to decompress</param>
      <param name="EncodingUsing">Encoding that the result should use (defaults to UTF8)</param>
      <param name="CompressionType">The compression type used</param>
      <returns>The data decompressed</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Data)" vb="Not IsNullOrEmpty(Data)">!string.IsNullOrEmpty(Data)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Data)</exception>
    </member>
    <member name="M:Utilities.IO.CompressionExtensions.Decompress(System.Byte[],System.String)">
      <summary>
            Decompresses the byte array that is sent in
            </summary>
      <param name="Data">Data to decompress</param>
      <param name="CompressionType">The compression type used</param>
      <returns>The data decompressed</returns>
      <requires description="CompressionType" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(CompressionType)" vb="Not IsNullOrEmpty(CompressionType)">!string.IsNullOrEmpty(CompressionType)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(CompressionType)</exception>
    </member>
    <member name="M:Utilities.IO.CompressionExtensions.Decompress(System.String,System.Text.Encoding,System.String)">
      <summary>
            Decompresses a string of data
            </summary>
      <param name="Data">Data to decompress</param>
      <param name="EncodingUsing">Encoding that the result should use (defaults to UTF8)</param>
      <param name="CompressionType">The compression type used</param>
      <returns>The data decompressed</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Data)" vb="Not IsNullOrEmpty(Data)">!string.IsNullOrEmpty(Data)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Data)</exception>
      <requires description="CompressionType" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(CompressionType)" vb="Not IsNullOrEmpty(CompressionType)">!string.IsNullOrEmpty(CompressionType)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(CompressionType)</exception>
    </member>
    <member name="T:Utilities.IO.FileFormatExtensions">
      <summary>
            Extension methods pertaining to file formats
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormatExtensions.ToDelimitedFile``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Converts an IEnumerable to a delimited file
            </summary>
      <typeparam name="T">Type of the items within the list</typeparam>
      <param name="List">The list to convert</param>
      <param name="Delimiter">Delimiter to use</param>
      <returns>The delimited file containing the list</returns>
    </member>
    <member name="M:Utilities.IO.FileFormatExtensions.ToDelimitedFile(System.Data.DataTable,System.String)">
      <summary>
            Converts an IEnumerable to a delimited file
            </summary>
      <param name="Data">The DataTable to convert</param>
      <param name="Delimiter">Delimiter to use</param>
      <returns>The delimited file containing the list</returns>
    </member>
    <member name="T:Utilities.IO.EncryptionExtensions">
      <summary>
            Extension methods dealing with encryption
            </summary>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.GenerateSalt(System.Random,System.Int32)">
      <summary>
            Generates salt
            </summary>
      <param name="Random">Randomization object</param>
      <param name="Size">Size of the salt byte array</param>
      <returns>A byte array as salt</returns>
      <requires description="Size must be greater than 0" exception="T:System.ArgumentException" csharp="Size &gt; 0" vb="Size &gt; 0">Size &gt; 0</requires>
      <exception cref="T:System.ArgumentException">Size &lt;= 0</exception>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Hash(System.Byte[],System.String)">
      <summary>
            Computes the hash of a byte array
            </summary>
      <param name="Data">Byte array to hash</param>
      <param name="Algorithm">Hash algorithm to use (defaults to SHA1)</param>
      <returns>The hash of the byte array</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Hash(System.String,System.String,System.Text.Encoding)">
      <summary>
            Computes the hash of a string
            </summary>
      <param name="Data">string to hash</param>
      <param name="Algorithm">Algorithm to use (defaults to SHA1)</param>
      <param name="EncodingUsing">Encoding used by the string (defaults to UTF8)</param>
      <returns>The hash of the string</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Encrypt(System.Byte[],System.String)">
      <summary>
            Encrypts a byte array using RSA
            </summary>
      <param name="Input">
            Input (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for encryption</param>
      <returns>An encrypted string (64bit string)</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Encrypt(System.Byte[],System.Byte[])">
      <summary>
            Encrypts the data using a basic xor of the key (not very secure unless doing a one time pad)
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <returns>The encrypted data</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Encrypt(System.String,System.Security.Cryptography.DeriveBytes,System.Text.Encoding,System.String,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">
            Key to use to encrypt the data (can use PasswordDeriveBytes, Rfc2898DeriveBytes, etc.
            Really anything that implements DeriveBytes)
            </param>
      <param name="AlgorithmUsing">Algorithm to use for encryption (defaults to AES)</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <param name="EncodingUsing">
            Encoding that the original string is using (defaults to UTF8)
            </param>
      <returns>An encrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Encrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.String,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">
            Key to use to encrypt the data (can use PasswordDeriveBytes, Rfc2898DeriveBytes, etc.
            Really anything that implements DeriveBytes)
            </param>
      <param name="AlgorithmUsing">Algorithm to use for encryption (defaults to AES)</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <returns>An encrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Decrypt(System.String,System.Security.Cryptography.DeriveBytes,System.Text.Encoding,System.String,System.String,System.Int32)">
      <summary>
            Decrypts a string
            </summary>
      <param name="Data">Text to be decrypted (Base 64 string)</param>
      <param name="Key">
            Key to use to encrypt the data (can use PasswordDeriveBytes, Rfc2898DeriveBytes, etc.
            Really anything that implements DeriveBytes)
            </param>
      <param name="EncodingUsing">
            Encoding that the output string should use (defaults to UTF8)
            </param>
      <param name="AlgorithmUsing">Algorithm to use for decryption (defaults to AES)</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <returns>A decrypted string</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Decrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.String,System.String,System.Int32)">
      <summary>
            Decrypts a byte array
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">
            Key to use to encrypt the data (can use PasswordDeriveBytes, Rfc2898DeriveBytes, etc.
            Really anything that implements DeriveBytes)
            </param>
      <param name="AlgorithmUsing">Algorithm to use for encryption (defaults to AES)</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">
            Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)
            </param>
      <returns>An encrypted byte array</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Decrypt(System.Byte[],System.Byte[])">
      <summary>
            Decrypts the data using a basic xor of the key (not very secure unless doing a one time pad)
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <returns>The decrypted data</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="Key != null" vb="Key &lt;&gt; Nothing">Key != null</requires>
      <exception cref="T:System.ArgumentNullException">Key == null</exception>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.Decrypt(System.Byte[],System.String,System.Text.Encoding)">
      <summary>
            Decrypts a string using RSA
            </summary>
      <param name="Input">
            Input string (should be small as anything over 128 bytes can not be decrypted)
            </param>
      <param name="Key">Key to use for decryption</param>
      <param name="EncodingUsing">Encoding that the result should use (defaults to UTF8)</param>
      <returns>A decrypted string</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.CreateKey(System.Random,System.Boolean)">
      <summary>
            Creates a new set of keys
            </summary>
      <param name="Random">Random object</param>
      <param name="PrivatePublic">True if private key should be included, false otherwise</param>
      <returns>XML representation of the key information</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.SignHash(System.String,System.String,System.String@,System.Text.Encoding)">
      <summary>
            Takes a string and creates a signed hash of it
            </summary>
      <param name="Input">Input string</param>
      <param name="Key">Key to encrypt/sign with</param>
      <param name="Hash">This will be filled with the unsigned hash</param>
      <param name="EncodingUsing">Encoding that the input is using (defaults to UTF8)</param>
      <returns>A signed hash of the input (64bit string)</returns>
    </member>
    <member name="M:Utilities.IO.EncryptionExtensions.VerifyHash(System.String,System.String,System.String)">
      <summary>
            Verifies a signed hash against the unsigned version
            </summary>
      <param name="Hash">The unsigned hash (should be 64bit string)</param>
      <param name="SignedHash">The signed hash (should be 64bit string)</param>
      <param name="Key">The key to use in decryption</param>
      <returns>True if it is verified, false otherwise</returns>
    </member>
    <member name="T:Utilities.IO.HTMLExtensions">
      <summary>
            Extensions dealing with minification of data
            </summary>
    </member>
    <member name="M:Utilities.IO.HTMLExtensions.Minify(System.Collections.Generic.IEnumerable{System.String},Utilities.IO.MinificationType)">
      <summary>
            Combines and minifies various files
            </summary>
      <param name="Input">input strings (file contents)</param>
      <param name="Type">Type of minification</param>
      <returns>A minified/packed string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.IO.HTMLExtensions.Minify(System.Collections.Generic.IEnumerable{Utilities.IO.FileInfo},Utilities.IO.MinificationType)">
      <summary>
            Combines and minifies various files
            </summary>
      <param name="Input">input strings (file contents)</param>
      <param name="Type">Type of minification</param>
      <returns>A minified/packed string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.IO.HTMLExtensions.Minify(System.String,Utilities.IO.MinificationType)">
      <summary>
            Minifies the file based on the data type specified
            </summary>
      <param name="Input">Input text</param>
      <param name="Type">Type of minification to run</param>
      <returns>A stripped file</returns>
    </member>
    <member name="M:Utilities.IO.HTMLExtensions.Minify(Utilities.IO.FileInfo,Utilities.IO.MinificationType)">
      <summary>
            Minifies the file based on the data type specified
            </summary>
      <param name="Input">Input file</param>
      <param name="Type">Type of minification to run</param>
      <returns>A stripped file</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != (Utilities.IO.FileInfo)null" vb="Input &lt;&gt; ((Utilities.IO.FileInfo)Nothing) ">Input != (Utilities.IO.FileInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Input != (Utilities.IO.FileInfo)null</exception>
      <requires description="Input file does not exist" exception="T:System.IO.FileNotFoundException" csharp="Input.Exists" vb="Input.Exists">Input.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!Input.Exists</exception>
    </member>
    <member name="T:Utilities.IO.MinificationType">
      <summary>
            Defines the type of data that is being minified
            </summary>
    </member>
    <member name="F:Utilities.IO.MinificationType.CSS">
      <summary>
            CSS
            </summary>
    </member>
    <member name="F:Utilities.IO.MinificationType.JavaScript">
      <summary>
            Javascript
            </summary>
    </member>
    <member name="F:Utilities.IO.MinificationType.HTML">
      <summary>
            HTML
            </summary>
    </member>
    <member name="T:Utilities.IO.IDirectoryExtensions">
      <summary>
            Directory extensions
            </summary>
    </member>
    <member name="M:Utilities.IO.IDirectoryExtensions.Delete(System.Collections.Generic.IEnumerable{Utilities.IO.FileSystem.Interfaces.IDirectory})">
      <summary>
            Deletes a list of directories
            </summary>
      <param name="Directories">Directories to delete</param>
    </member>
    <member name="T:Utilities.IO.IFileExtensions">
      <summary>
            File extensions
            </summary>
    </member>
    <member name="M:Utilities.IO.IFileExtensions.Delete(System.Collections.Generic.IEnumerable{Utilities.IO.FileSystem.Interfaces.IFile})">
      <summary>
            Deletes a list of files
            </summary>
      <param name="Files">List of files</param>
    </member>
    <member name="T:Utilities.IO.SerializationExtensions">
      <summary>
            Extension methods dealing with serialization
            </summary>
    </member>
    <member name="M:Utilities.IO.SerializationExtensions.Deserialize``2(``1,System.String)">
      <summary>
            Deserializes the data based on the MIME content type specified (defaults to json)
            </summary>
      <typeparam name="R">Return type expected</typeparam>
      <typeparam name="T">Object type</typeparam>
      <param name="Data">Data to deserialize</param>
      <param name="ContentType">Content type (MIME type)</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.SerializationExtensions.Deserialize``2(``1,Utilities.IO.SerializationType)">
      <summary>
            Deserializes the data based on the content type specified (defaults to json)
            </summary>
      <typeparam name="R">Return type expected</typeparam>
      <typeparam name="T">Object type</typeparam>
      <param name="Data">Data to deserialize</param>
      <param name="ContentType">Content type</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.SerializationExtensions.Serialize``2(``1,System.String)">
      <summary>
            Serializes the data based on the MIME content type specified (defaults to json)
            </summary>
      <typeparam name="R">Return type expected</typeparam>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to serialize</param>
      <param name="ContentType">Content type (MIME type)</param>
      <returns>The serialized object</returns>
    </member>
    <member name="M:Utilities.IO.SerializationExtensions.Serialize``2(``1,Utilities.IO.SerializationType)">
      <summary>
            Serializes the data based on the type specified (defaults to json)
            </summary>
      <typeparam name="R">Return type expected</typeparam>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to serialize</param>
      <param name="ContentType">Content type</param>
      <returns>The serialized object</returns>
    </member>
    <member name="T:Utilities.IO.SerializationType">
      <summary>
            Serialization enum like class
            </summary>
    </member>
    <member name="M:Utilities.IO.SerializationType.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
    </member>
    <member name="M:Utilities.IO.SerializationType.op_Implicit(Utilities.IO.SerializationType)~System.String">
      <summary>
            Converts the object to a string implicitly
            </summary>
      <param name="Object">Object to convert</param>
      <returns>The string version of the serialization type</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
    </member>
    <member name="M:Utilities.IO.SerializationType.ToString">
      <summary>
            Returns the name of the serialization type
            </summary>
      <returns>Name</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.SerializationType.Binary">
      <summary>
            Binary
            </summary>
    </member>
    <member name="P:Utilities.IO.SerializationType.JSON">
      <summary>
            JSON
            </summary>
    </member>
    <member name="P:Utilities.IO.SerializationType.SOAP">
      <summary>
            SOAP
            </summary>
    </member>
    <member name="P:Utilities.IO.SerializationType.XML">
      <summary>
            XML
            </summary>
    </member>
    <member name="T:Utilities.IO.StringExtensions">
      <summary>
            Extension methods for strings
            </summary>
    </member>
    <member name="M:Utilities.IO.StringExtensions.RemoveIllegalDirectoryNameCharacters(System.String,System.Char)">
      <summary>
            Removes illegal characters from a directory
            </summary>
      <param name="DirectoryName">Directory name</param>
      <param name="ReplacementChar">Replacement character</param>
      <returns>DirectoryName with all illegal characters replaced with ReplacementChar</returns>
    </member>
    <member name="M:Utilities.IO.StringExtensions.RemoveIllegalFileNameCharacters(System.String,System.Char)">
      <summary>
            Removes illegal characters from a file
            </summary>
      <param name="FileName">File name</param>
      <param name="ReplacementChar">Replacement character</param>
      <returns>FileName with all illegal characters replaced with ReplacementChar</returns>
    </member>
    <member name="T:Utilities.IO.FileFormats.BaseClasses.FormatBase`2">
      <summary>
            Format base class
            </summary>
      <typeparam name="ContentType">Content type</typeparam>
      <typeparam name="FormatType">Format type</typeparam>
    </member>
    <member name="T:Utilities.IO.FileFormats.Interfaces.IFormat`2">
      <summary>
            Format interface
            </summary>
      <typeparam name="ContentType">Content type</typeparam>
      <typeparam name="FormatType">Format type</typeparam>
    </member>
    <member name="M:Utilities.IO.FileFormats.Interfaces.IFormat`2.Save(System.String)">
      <summary>
            Saves the object
            </summary>
      <param name="Location">Location to save it to</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.Load(System.String)">
      <summary>
            Loads the object from the location specified
            </summary>
      <param name="Location">Location of the file to load</param>
      <returns>The object specified in the location</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.Clone">
      <summary>
            Clones the object
            </summary>
      <returns>A newly cloned object</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.CompareTo(System.Object)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.CompareTo(`0)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="other">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.Equals(`0)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="other">Other object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Other object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.GetHashCode">
      <summary>
            Gets the hash code for the object
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.Save(System.String)">
      <summary>
            Saves the object
            </summary>
      <param name="Location">Location to save it to</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.InternalLoad(System.String)">
      <summary>
            Loads the object from the location specified
            </summary>
      <param name="Location">Location of the file to load</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.op_Inequality(Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1},Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1})">
      <summary>
            Determines if the two are not equal
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.op_LessThan(Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1},Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1})">
      <summary>
            Determines if it is less than
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>True if it is less than, false otherwise</returns>
      <requires description="Value1" exception="T:System.ArgumentNullException" csharp="Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null" vb="Value1 &lt;&gt; ((Utilities.IO.FileFormats.BaseClasses.FormatBase(Of FormatType, ContentType))Nothing) ">Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.op_LessThanOrEqual(Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1},Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1})">
      <summary>
            Determines if it is less than or equal
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>True if it is less than or equal, false otherwise</returns>
      <requires description="Value1" exception="T:System.ArgumentNullException" csharp="Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null" vb="Value1 &lt;&gt; ((Utilities.IO.FileFormats.BaseClasses.FormatBase(Of FormatType, ContentType))Nothing) ">Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.op_Equality(Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1},Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1})">
      <summary>
            Determines if the two are equal
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.op_GreaterThan(Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1},Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1})">
      <summary>
            Determines if it is greater than
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>True if it is greater than, false otherwise</returns>
      <requires description="Value1" exception="T:System.ArgumentNullException" csharp="Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null" vb="Value1 &lt;&gt; ((Utilities.IO.FileFormats.BaseClasses.FormatBase(Of FormatType, ContentType))Nothing) ">Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.FormatBase`2.op_GreaterThanOrEqual(Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1},Utilities.IO.FileFormats.BaseClasses.FormatBase{`0,`1})">
      <summary>
            Determines if it is greater than or equal
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>True if it is greater than or equal, false otherwise</returns>
      <requires description="Value1" exception="T:System.ArgumentNullException" csharp="Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null" vb="Value1 &lt;&gt; ((Utilities.IO.FileFormats.BaseClasses.FormatBase(Of FormatType, ContentType))Nothing) ">Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Value1 != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, ContentType&gt;)null</exception>
    </member>
    <member name="T:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1">
      <summary>
            Format base class for objects that are string based
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1.Clone">
      <summary>
            Clones the object
            </summary>
      <returns>A newly cloned object</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1.CompareTo(`0)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="other">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1.Equals(`0)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="other">Other object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1.Save(System.String)">
      <summary>
            Saves the object
            </summary>
      <param name="Location">Location to save it to</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1.InternalLoad(System.String)">
      <summary>
            Loads the object from the location specified
            </summary>
      <param name="Location">Location of the file to load</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1.op_Implicit(Utilities.IO.FileFormats.BaseClasses.StringFormatBase{`0})~System.String">
      <summary>
            Converts the format to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, string&gt;)null" vb="Value &lt;&gt; ((Utilities.IO.FileFormats.BaseClasses.FormatBase(Of FormatType, String))Nothing) ">Value != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, string&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Value != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;FormatType, string&gt;)null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringFormatBase`1.op_Implicit(System.String)~Utilities.IO.FileFormats.BaseClasses.StringFormatBase{`0}">
      <summary>
            Converts the string to the format specified
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The string as an object</returns>
    </member>
    <member name="T:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2">
      <summary>
            Format base class for objects that are string based and list of records
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.Add(`1)">
      <summary>
            Adds a Record to the file
            </summary>
      <param name="item">Record to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.Clear">
      <summary>
            Clears the file
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.Contains(`1)">
      <summary>
            Determines if the file contains a Record
            </summary>
      <param name="item">Record to check for</param>
      <returns>True if it does, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.CopyTo(`1[],System.Int32)">
      <summary>
            Copies the delimited file to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.GetEnumerator">
      <summary>
            Gets the enumerator for the delimited file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.IndexOf(`1)">
      <summary>
            Index of a specific Record
            </summary>
      <param name="item">Record to search for</param>
      <returns>The index of a specific Record</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.Insert(System.Int32,`1)">
      <summary>
            Inserts a Record at a specific index
            </summary>
      <param name="index">Index to insert at</param>
      <param name="item">Record to insert</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.Remove(`1)">
      <summary>
            Removes a Record from the file
            </summary>
      <param name="item">Record to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.RemoveAt(System.Int32)">
      <summary>
            Removes a Record at a specific index
            </summary>
      <param name="index">Index of the Record to remove</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the delimited file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.Count">
      <summary>
            Count of records
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.IsReadOnly">
      <summary>
            Is read only?
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.Records">
      <summary>
            The list of records
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.BaseClasses.StringListFormatBase`2.Item(System.Int32)">
      <summary>
            Individual records
            </summary>
      <param name="Position">The record that you want to get</param>
      <returns>The record requested</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="T:Utilities.IO.FileFormats.Delimited.Cell">
      <summary>
            Cell within a delimited file
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Cell.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Cell.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Content">Value within the cell</param>
      <requires description="Content" exception="T:System.ArgumentNullException" csharp="Content != null" vb="Content &lt;&gt; Nothing">Content != null</requires>
      <exception cref="T:System.ArgumentNullException">Content == null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Cell.op_Implicit(System.String)~Utilities.IO.FileFormats.Delimited.Cell">
      <summary>
            Converts the string to a cell
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The string as a cell</returns>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != null" vb="Value &lt;&gt; Nothing">Value != null</requires>
      <exception cref="T:System.ArgumentNullException">Value == null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Cell.op_Implicit(Utilities.IO.FileFormats.Delimited.Cell)~System.String">
      <summary>
            Converts the cell to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != null" vb="Value &lt;&gt; Nothing">Value != null</requires>
      <exception cref="T:System.ArgumentNullException">Value == null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Cell.ToString">
      <summary>
            To string function
            </summary>
      <returns>The value of the cell</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.Delimited.Cell.Value">
      <summary>
            Value within the cell
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.Delimited.Delimited">
      <summary>
            Base classs for delimited files (CSV, etc.)
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Delimited.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Delimited.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FileContent">File content</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Delimited.#ctor(System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FileContent">File content</param>
      <param name="Delimiter">Delimiter that the system uses</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Delimited.op_Implicit(System.Data.DataTable)~Utilities.IO.FileFormats.Delimited.Delimited">
      <summary>
            Converts the string to the format specified
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The string as an object</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Delimited.Parse(System.String)">
      <summary>
            Parses file content and adds it to the delimited file
            </summary>
      <param name="FileContent">File content</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Delimited.ToDataTable(System.Boolean,System.String[])">
      <summary>
            Converts the delimited file to a DataTable
            </summary>
      <param name="FirstRowIsHeader">
            Determines if the first row should be treated as a header or not
            </param>
      <param name="Headers">Headers for the columns if the first row is not a header</param>
      <returns>The delimited file as a DataTable</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Delimited.ToString">
      <summary>
            To string function
            </summary>
      <returns>A string containing the file information</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Delimited.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="P:Utilities.IO.FileFormats.Delimited.Delimited.Delimiter">
      <summary>
            The delimiter used to seperate values (must be overridden)
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.Delimited.Row">
      <summary>
            Individual row within a delimited file
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Delimiter">Delimiter to parse the individual cells</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.#ctor(System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Content">Content of the row</param>
      <param name="Delimiter">Delimiter to parse the individual cells</param>
      <requires description="Content" exception="T:System.ArgumentNullException" csharp="Content != null" vb="Content &lt;&gt; Nothing">Content != null</requires>
      <exception cref="T:System.ArgumentNullException">Content == null</exception>
      <requires description="Delimiter" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Delimiter)" vb="Not IsNullOrEmpty(Delimiter)">!string.IsNullOrEmpty(Delimiter)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Delimiter)</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.Add(Utilities.IO.FileFormats.Delimited.Cell)">
      <summary>
            Adds a Cell to the file
            </summary>
      <param name="item">Cell to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.Clear">
      <summary>
            Clears the file
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.Contains(Utilities.IO.FileFormats.Delimited.Cell)">
      <summary>
            Determines if the file contains a Cell
            </summary>
      <param name="item">Cell to check for</param>
      <returns>True if it does, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.CopyTo(Utilities.IO.FileFormats.Delimited.Cell[],System.Int32)">
      <summary>
            Copies the delimited file to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.GetEnumerator">
      <summary>
            Gets the enumerator for the delimited file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.IndexOf(Utilities.IO.FileFormats.Delimited.Cell)">
      <summary>
            Index of a specific Cell
            </summary>
      <param name="item">Cell to search for</param>
      <returns>The index of a specific Cell</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.Insert(System.Int32,Utilities.IO.FileFormats.Delimited.Cell)">
      <summary>
            Inserts a Cell at a specific index
            </summary>
      <param name="index">Index to insert at</param>
      <param name="item">Cell to insert</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.Remove(Utilities.IO.FileFormats.Delimited.Cell)">
      <summary>
            Removes a Cell from the file
            </summary>
      <param name="item">Cell to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.RemoveAt(System.Int32)">
      <summary>
            Removes a Cell at a specific index
            </summary>
      <param name="index">Index of the Cell to remove</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the delimited file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Delimited.Row.ToString">
      <summary>
            To string function
            </summary>
      <returns>The content of the row in string form</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.Delimited.Row.Delimiter">
      <summary>
            Delimiter used
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.Delimited.Row.Cells">
      <summary>
            Cells within the row
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.Delimited.Row.Item(System.Int32)">
      <summary>
            Returns a cell within the row
            </summary>
      <param name="Position">The position of the cell</param>
      <returns>The specified cell</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="P:Utilities.IO.FileFormats.Delimited.Row.Count">
      <summary>
            Number of Cells
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.IO.FileFormats.Delimited.Row.IsReadOnly">
      <summary>
            Is the file read only
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.Excel">
      <summary>
            Excel doc helper
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.Excel.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.Excel.#ctor(System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FilePath">FilePath</param>
      <param name="Sheet">Sheet to load</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.Excel.Load(System.String,System.String)">
      <summary>
            Loads an excel doc/sheet
            </summary>
      <param name="Location">Location of the file to load</param>
      <param name="Sheet">Sheet of the document to load</param>
      <returns>The excel doc</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.Excel.ToString">
      <summary>
            To string function
            </summary>
      <returns>A string containing the file information</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.Excel.InternalLoad(System.String)">
      <summary>
            Loads data from the excel doc
            </summary>
      <param name="Location">Location of the file</param>
      <returns>The excel doc</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.Excel.LoadFromData(System.String)">
      <summary>
            Loads data from the excel doc
            </summary>
      <param name="Data">Data to load from</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.Excel.Parse(System.String,System.String)">
      <summary>
            Parses the file
            </summary>
      <param name="FilePath">File path</param>
      <param name="Sheet">Sheet to parse</param>
    </member>
    <member name="P:Utilities.IO.FileFormats.Excel.ColumnNames">
      <summary>
            Names of each column
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.Excel.Item(System.Int32,System.String)">
      <summary>
            Gets the value based on the row and column name specified
            </summary>
      <param name="Value">Row to get</param>
      <param name="Name">Column name to look for</param>
      <returns>The value</returns>
      <getter>
        <requires description="Value must be greater than or equal to 0" exception="T:System.ArgumentException" csharp="Value &gt;= 0" vb="Value &gt;= 0">Value &gt;= 0</requires>
      </getter>
      <exception cref="T:System.ArgumentException">Value &lt; 0</exception>
    </member>
    <member name="T:Utilities.IO.FileFormats.FixedLength.BaseClasses.FieldBase`1">
      <summary>
            Field base class
            </summary>
      <typeparam name="T">Field type</typeparam>
    </member>
    <member name="T:Utilities.IO.FileFormats.FixedLength.Interfaces.IField`1">
      <summary>
            Field interface
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.Interfaces.IField`1.Parse(System.String,System.Int32,System.String)">
      <summary>
            Parses the string into fields
            </summary>
      <param name="Value">The string value</param>
      <param name="Length">Max length of the value</param>
      <param name="FillerCharacter">Filler character used to fill the rest of the field</param>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.Interfaces.IField`1.Length">
      <summary>
            Field length
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.Interfaces.IField`1.Value">
      <summary>
            Field value
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.FieldBase`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.FieldBase`1.Parse(System.String,System.Int32,System.String)">
      <summary>
            Parses the field
            </summary>
      <param name="Value">Value to place in the field</param>
      <param name="Length">Length of the field</param>
      <param name="FillerCharacter">Filler character to use</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.FieldBase`1.ToString">
      <summary>
            Converts the field to a string
            </summary>
      <returns>The field as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.BaseClasses.FieldBase`1.Length">
      <summary>
            Length of the field
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.BaseClasses.FieldBase`1.Value">
      <summary>
            Value of the field
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2">
      <summary>
            Parses and creates a fixed length file
            </summary>
      <typeparam name="ObjectType">Object Type</typeparam>
      <typeparam name="FieldType">Field Type</typeparam>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2.Parse(System.String,System.Int32)">
      <summary>
            Parses the string into fields
            </summary>
      <param name="Value">The string value</param>
      <param name="Length">Max length for the record</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2.ToString">
      <summary>
            Converts the file to a string
            </summary>
      <returns>The file as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2.LoadFromData(System.String)">
      <summary>
            Loads the data into the object
            </summary>
      <param name="Data">The data to load</param>
    </member>
    <member name="T:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1">
      <summary>
            Record base class
            </summary>
      <typeparam name="T">Field type</typeparam>
    </member>
    <member name="T:Utilities.IO.FileFormats.FixedLength.Interfaces.IRecord`1">
      <summary>
            Record interface
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.Interfaces.IRecord`1.Parse(System.String,System.Int32)">
      <summary>
            Parses the string into fields
            </summary>
      <param name="Value">The string value</param>
      <param name="Length">Max length of the value</param>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.Interfaces.IRecord`1.Length">
      <summary>
            Length of the record
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Add(Utilities.IO.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Adds a Field to the file
            </summary>
      <param name="item">Field to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Clear">
      <summary>
            Clears the file
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Contains(Utilities.IO.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Determines if the file contains a Field
            </summary>
      <param name="item">Field to check for</param>
      <returns>True if it does, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.CopyTo(Utilities.IO.FileFormats.FixedLength.Interfaces.IField{`0}[],System.Int32)">
      <summary>
            Copies the delimited file to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.GetEnumerator">
      <summary>
            Gets the enumerator for the file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.IndexOf(Utilities.IO.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Index of a specific Field
            </summary>
      <param name="item">Field to search for</param>
      <returns>The index of a specific Field</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Insert(System.Int32,Utilities.IO.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Inserts a Field at a specific index
            </summary>
      <param name="index">Index to insert at</param>
      <param name="item">Field to insert</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Parse(System.String,System.Int32)">
      <summary>
            Parses the record
            </summary>
      <param name="Value">Value</param>
      <param name="Length">Length of the record</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Remove(Utilities.IO.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Removes a Field from the file
            </summary>
      <param name="item">Field to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.RemoveAt(System.Int32)">
      <summary>
            Removes a Field at a specific index
            </summary>
      <param name="index">Index of the Field to remove</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.ToString">
      <summary>
            Converts the record to a string
            </summary>
      <returns>The record as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Count">
      <summary>
            Number of Fields
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.IsReadOnly">
      <summary>
            Is the file read only
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Length">
      <summary>
            Length
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Fields">
      <summary>
            The list of fields
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.FixedLength.BaseClasses.RecordBase`1.Item(System.Int32)">
      <summary>
            Individual records
            </summary>
      <param name="Position">The record that you want to get</param>
      <returns>The record requested</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="T:Utilities.IO.FileFormats.FixedLength.StringField">
      <summary>
            Field containing string info (used in text based files)
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.StringField.#ctor(System.String,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to place in the field</param>
      <param name="Length">Max length of the value</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.FixedLength.StringField.Parse(System.String,System.Int32,System.String)">
      <summary>
            Parses the string field
            </summary>
      <param name="Value">Value</param>
      <param name="Length">Max length allowed</param>
      <param name="FillerCharacter">Filler character</param>
    </member>
    <member name="T:Utilities.IO.FileFormats.INI">
      <summary>
            Class for helping with INI files
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.INI.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.INI.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FileName">Name of the file</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.INI.DeleteFromINI(System.String)">
      <summary>
            Deletes a section from the INI file
            </summary>
      <param name="Section">Section to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.INI.DeleteFromINI(System.String,System.String)">
      <summary>
            Deletes a key from the INI file
            </summary>
      <param name="Section">Section the key is under</param>
      <param name="Key">Key to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.INI.ReadFromINI(System.String,System.String,System.String)">
      <summary>
            Reads a value from an INI file
            </summary>
      <param name="Section">Section</param>
      <param name="Key">Key</param>
      <param name="DefaultValue">Default value if it does not exist</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.INI.ToString">
      <summary>
            Convert the INI to a string
            </summary>
      <returns>The INI file as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.INI.ToXML">
      <summary>
            Returns an XML representation of the INI file
            </summary>
      <returns>An XML representation of the INI file</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.INI.WriteToINI(System.String,System.String,System.String)">
      <summary>
            Writes a change to an INI file
            </summary>
      <param name="Section">Section</param>
      <param name="Key">Key</param>
      <param name="Value">Value</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.INI.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="P:Utilities.IO.FileFormats.INI.FileName">
      <summary>
            Name of the file
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.RSS.Channel">
      <summary>
            Channel item for RSS feeds
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.#ctor(System.Xml.XPath.IXPathNavigable)">
      <summary>
            Constructor
            </summary>
      <param name="Doc">XML representation of the channel</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Doc != null" vb="Doc &lt;&gt; Nothing">Doc != null</requires>
      <exception cref="T:System.ArgumentNullException">Doc == null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.Add(Utilities.IO.FileFormats.RSS.Item)">
      <summary>
            Adds an item
            </summary>
      <param name="item">Item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.Clear">
      <summary>
            Clears the items from the channel
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.Contains(Utilities.IO.FileFormats.RSS.Item)">
      <summary>
            Does the channel contain a specific item?
            </summary>
      <param name="item">Item to check</param>
      <returns>True if it is there, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.CopyTo(Utilities.IO.FileFormats.RSS.Item[],System.Int32)">
      <summary>
            Copies the items to an array
            </summary>
      <param name="array">array to copy to</param>
      <param name="arrayIndex">Array index</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator for the channel</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.IndexOf(Utilities.IO.FileFormats.RSS.Item)">
      <summary>
            Index of the item specified
            </summary>
      <param name="item">Item specified</param>
      <returns>The index of the item</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.Insert(System.Int32,Utilities.IO.FileFormats.RSS.Item)">
      <summary>
            Inserts the item at a specific index
            </summary>
      <param name="index">Index to insert at</param>
      <param name="item">Item to insert</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.Remove(Utilities.IO.FileFormats.RSS.Item)">
      <summary>
            Removes an item from the channel
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.RemoveAt(System.Int32)">
      <summary>
            Removes an item at a specific index
            </summary>
      <param name="index">Index to remove at</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator for the channel</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Channel.ToString">
      <summary>
            Converts the channel to a string
            </summary>
      <returns>The channel as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Categories">
      <summary>
            Categories
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Cloud">
      <summary>
            Cloud
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Copyright">
      <summary>
            Copyright
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Description">
      <summary>
            Description
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Docs">
      <summary>
            Docs
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Explicit">
      <summary>
            Explicit
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.ImageUrl">
      <summary>
            Image URL
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Language">
      <summary>
            Language
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Link">
      <summary>
            Link
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.PubDate">
      <summary>
            Publish date
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Title">
      <summary>
            Title
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.TTL">
      <summary>
            TTL
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.WebMaster">
      <summary>
            Web master
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Items">
      <summary>
            Items
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Count">
      <summary>
            Count
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.IsReadOnly">
      <summary>
            Is read only?
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Channel.Item(System.Int32)">
      <summary>
            Gets/sets an item at a specific index
            </summary>
      <param name="index">index to get/set</param>
      <returns>Item specified</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="T:Utilities.IO.FileFormats.RSS.Document">
      <summary>
            RSS document class
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Location">Location of the RSS feed to load</param>
      <requires description="Location" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Location)" vb="Not IsNullOrEmpty(Location)">!string.IsNullOrEmpty(Location)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Location)</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.#ctor(System.Xml.XPath.IXPathNavigable)">
      <summary>
            Constructor
            </summary>
      <param name="Document">XML document containing an RSS feed</param>
      <requires description="Document" exception="T:System.ArgumentNullException" csharp="Document != null" vb="Document &lt;&gt; Nothing">Document != null</requires>
      <exception cref="T:System.ArgumentNullException">Document == null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.Add(Utilities.IO.FileFormats.RSS.Channel)">
      <summary>
            Adds a channel to the document
            </summary>
      <param name="item">Item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.Clear">
      <summary>
            Clears the document
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.Contains(Utilities.IO.FileFormats.RSS.Channel)">
      <summary>
            Does this contain the channel specified
            </summary>
      <param name="item">Channel to check</param>
      <returns>True if it does, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.Copy(Utilities.IO.FileFormats.RSS.Document)">
      <summary>
            Copies one document's channels to another
            </summary>
      <param name="CopyFrom">RSS document to copy from</param>
      <requires description="CopyFrom" exception="T:System.ArgumentNullException" csharp="CopyFrom != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;Utilities.IO.FileFormats.RSS.Document, string&gt;)null" vb="CopyFrom &lt;&gt; ((Utilities.IO.FileFormats.BaseClasses.FormatBase(Of Utilities.IO.FileFormats.RSS.Document, String))Nothing) ">CopyFrom != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;Utilities.IO.FileFormats.RSS.Document, string&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!CopyFrom != (Utilities.IO.FileFormats.BaseClasses.FormatBase&lt;Utilities.IO.FileFormats.RSS.Document, string&gt;)null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.CopyTo(Utilities.IO.FileFormats.RSS.Channel[],System.Int32)">
      <summary>
            Copies the channels to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Array starting index</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>Enumerator of the document</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.IndexOf(Utilities.IO.FileFormats.RSS.Channel)">
      <summary>
            Index of the item specified
            </summary>
      <param name="item">Channel</param>
      <returns>Index of the channel</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.Insert(System.Int32,Utilities.IO.FileFormats.RSS.Channel)">
      <summary>
            Inserts a channel
            </summary>
      <param name="index">index</param>
      <param name="item">Channel item</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.Remove(Utilities.IO.FileFormats.RSS.Channel)">
      <summary>
            Removes an item from the document
            </summary>
      <param name="item">Channel to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.RemoveAt(System.Int32)">
      <summary>
            Remove channel at a specific index
            </summary>
      <param name="index">Index to remove</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>Enumerator of the document</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.ToString">
      <summary>
            string representation of the RSS feed.
            </summary>
      <returns>An rss formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Document.Count">
      <summary>
            Channel count
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Document.IsReadOnly">
      <summary>
            Determines if it is read only
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Document.Channels">
      <summary>
            Channels for the RSS feed
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Document.Item(System.Int32)">
      <summary>
            Gets/sets a channel
            </summary>
      <param name="index">index</param>
      <returns>The channel specified</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="T:Utilities.IO.FileFormats.RSS.Enclosure">
      <summary>
            Enclosure class for RSS feeds (used for pod casting)
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Enclosure.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Enclosure.#ctor(System.Xml.XPath.IXPathNavigable)">
      <summary>
            Constructor
            </summary>
      <param name="Doc">XML element holding info for the enclosure</param>
      <requires description="Doc" exception="T:System.ArgumentNullException" csharp="Doc != null" vb="Doc &lt;&gt; Nothing">Doc != null</requires>
      <exception cref="T:System.ArgumentNullException">Doc == null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Enclosure.ToString">
      <summary>
            to string item. Used for outputting the item to RSS.
            </summary>
      <returns>A string formatted for RSS output</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Enclosure.Length">
      <summary>
            Size in bytes
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Enclosure.Type">
      <summary>
            File type
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Enclosure.Url">
      <summary>
            Location of the item
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.RSS.GUID">
      <summary>
            GUID info holder
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.GUID.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.GUID.#ctor(System.Xml.XPath.IXPathNavigable)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XML element holding info for the enclosure</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.GUID.ToString">
      <summary>
            to string item. Used for outputting the item to RSS.
            </summary>
      <returns>A string formatted for RSS output</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.GUID.GUIDText">
      <summary>
            GUID Text
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.GUID.PermaLink">
      <summary>
            Is this a perma link?
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.RSS.Item">
      <summary>
            Item class for RSS feeds
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Item.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Item.#ctor(System.Xml.XPath.IXPathNavigable)">
      <summary>
            Constructor
            </summary>
      <param name="Doc">XML element containing the item content</param>
      <requires description="Doc" exception="T:System.ArgumentNullException" csharp="Doc != null" vb="Doc &lt;&gt; Nothing">Doc != null</requires>
      <exception cref="T:System.ArgumentNullException">Doc == null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Item.ToString">
      <summary>
            Outputs a string ready for RSS
            </summary>
      <returns>A string formatted for RSS</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Item.Author">
      <summary>
            Author
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Item.Categories">
      <summary>
            Categories
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Item.Description">
      <summary>
            Description
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Item.Enclosure">
      <summary>
            Enclosure
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Item.GUID">
      <summary>
            GUID for the item
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Item.Link">
      <summary>
            Link
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Item.PubDate">
      <summary>
            Publication date
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Item.Thumbnail">
      <summary>
            Thumbnail
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Item.Title">
      <summary>
            Title
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.RSS.Utils">
      <summary>
            Utility class used by RSS classes.
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Utils.StripIllegalCharacters(System.String)">
      <summary>
            Strips illegal characters from RSS items
            </summary>
      <param name="Original">Original text</param>
      <returns>string stripped of certain characters.</returns>
      <requires description="Original" exception="T:System.ArgumentNullException" csharp="Original != null" vb="Original &lt;&gt; Nothing">Original != null</requires>
      <exception cref="T:System.ArgumentNullException">Original == null</exception>
    </member>
    <member name="T:Utilities.IO.FileFormats.RSS.Thumbnail">
      <summary>
            Thumbnail info holder
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Thumbnail.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Thumbnail.#ctor(System.Xml.XPath.IXPathNavigable)">
      <summary>
            Constructor
            </summary>
      <param name="Doc">XML element holding info for the enclosure</param>
      <requires description="Doc" exception="T:System.ArgumentNullException" csharp="Doc != null" vb="Doc &lt;&gt; Nothing">Doc != null</requires>
      <exception cref="T:System.ArgumentNullException">Doc == null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Thumbnail.ToString">
      <summary>
            to string item. Used for outputting the item to RSS.
            </summary>
      <returns>A string formatted for RSS output</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Thumbnail.Height">
      <summary>
            Image height
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Thumbnail.Url">
      <summary>
            Location of the item
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.RSS.Thumbnail.Width">
      <summary>
            Image width
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.VCalendar">
      <summary>
            Creates a VCalendar item
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCalendar.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCalendar.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCalendar.GetHCalendar">
      <summary>
            Returns the HCalendar item
            </summary>
      <returns>A string output of the HCalendar item</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCalendar.GetICalendar">
      <summary>
            Returns the ICalendar item
            </summary>
      <returns>a string output of the ICalendar item</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCalendar.GetText">
      <summary>
            Returns the text version of the appointment
            </summary>
      <returns>A text version of the appointement</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCalendar.GetVCalendar">
      <summary>
            Returns the VCalendar item
            </summary>
      <returns>a string output of the VCalendar item</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCalendar.ToString">
      <summary>
            Returns the text version of the appointment
            </summary>
      <returns>A text version of the appointement</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.AttendeeList">
      <summary>
            List of attendees
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.Cancel">
      <summary>
            Determines if the calendar item is being canceled
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.CurrentTimeZone">
      <summary>
            The time zone for the calendar event
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.Description">
      <summary>
            The description of the event
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.EndTime">
      <summary>
            The end time
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.Location">
      <summary>
            The location of the event
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.Organizer">
      <summary>
            Organizer
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.StartTime">
      <summary>
            The start time
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.Status">
      <summary>
            Sets the status for the appointment (FREE, BUSY, etc.)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCalendar.Subject">
      <summary>
            The subject of the item to send
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.VCard">
      <summary>
            VCard class
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCard.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCard.HCard">
      <summary>
            Gets the hCard version of the vCard
            </summary>
      <returns>A hCard in string format</returns>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCard.ToString">
      <summary>
            Gets the VCard as a string
            </summary>
      <returns>VCard as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileFormats.VCard.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.DirectDial">
      <summary>
            Work phone number of the individual
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.Email">
      <summary>
            Email of the individual
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.FirstName">
      <summary>
            First name
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.LastName">
      <summary>
            Last name
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.MiddleName">
      <summary>
            Middle name
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.Organization">
      <summary>
            Organization the person belongs to
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.Prefix">
      <summary>
            Prefix
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.Relationships">
      <summary>
            Relationship to the person (uses XFN)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.Suffix">
      <summary>
            Suffix
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.Title">
      <summary>
            Title of the person
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.Url">
      <summary>
            Url to the person's site
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.FullName">
      <summary>
            Full name
            </summary>
    </member>
    <member name="P:Utilities.IO.FileFormats.VCard.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.FileFormats.Relationship">
      <summary>
            Enum defining relationships (used for XFN markup)
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Friend">
      <summary>
            Friend
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Acquaintance">
      <summary>
            Acquaintance
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Contact">
      <summary>
            Contact
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Met">
      <summary>
            Met
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.CoWorker">
      <summary>
            Coworker
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Colleague">
      <summary>
            Colleague
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.CoResident">
      <summary>
            Coresident
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Neighbor">
      <summary>
            Neighbor
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Child">
      <summary>
            Child
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Parent">
      <summary>
            Parent
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Sibling">
      <summary>
            Sibling
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Spouse">
      <summary>
            Spouse
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Kin">
      <summary>
            Kin
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Muse">
      <summary>
            Muse
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Crush">
      <summary>
            Crush
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Date">
      <summary>
            Date
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Sweetheart">
      <summary>
            Sweetheart
            </summary>
    </member>
    <member name="F:Utilities.IO.FileFormats.Relationship.Me">
      <summary>
            Me
            </summary>
    </member>
    <member name="T:Utilities.IO.FileInfo">
      <summary>
            File info class
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Interfaces.IFile">
      <summary>
            Represents an individual file
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFile.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,System.Boolean)">
      <summary>
            Copies the file to another directory
            </summary>
      <param name="Directory">Directory to copy the file to</param>
      <param name="Overwrite">Should the file overwrite another file if found</param>
      <returns>The newly created file</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFile.Delete">
      <summary>
            Deletes the file
            </summary>
      <returns>Any response for deleting the resource (usually FTP, HTTP, etc)</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFile.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves the file to another directory
            </summary>
      <param name="Directory">Directory to move the file to</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFile.Read">
      <summary>
            Reads the file to the end as a string
            </summary>
      <returns>A string containing the contents of the file</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFile.ReadBinary">
      <summary>
            Reads the file to the end as a byte array
            </summary>
      <returns>A byte array containing the contents of the file</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFile.Rename(System.String)">
      <summary>
            Renames the file
            </summary>
      <param name="NewName">New file name</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFile.Write(System.String,System.IO.FileMode,System.Text.Encoding)">
      <summary>
            Writes content to the file
            </summary>
      <param name="Content">Content to write</param>
      <param name="Mode">File mode</param>
      <param name="Encoding">
            Encoding that the content should be saved as (default is UTF8)
            </param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFile.Write(System.Byte[],System.IO.FileMode)">
      <summary>
            Writes content to the file
            </summary>
      <param name="Content">Content to write</param>
      <param name="Mode">File mode</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFile.Accessed">
      <summary>
            Last time the file was accessed
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFile.Created">
      <summary>
            When the file was created
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFile.Directory">
      <summary>
            Directory the file is in
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFile.Exists">
      <summary>
            Does the file exist currently
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFile.Extension">
      <summary>
            File extension
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFile.FullName">
      <summary>
            Full path to the file
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFile.Length">
      <summary>
            Size of the file in bytes
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFile.Modified">
      <summary>
            When the file was last modified
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFile.Name">
      <summary>
            File name
            </summary>
    </member>
    <member name="M:Utilities.IO.FileInfo.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Path">Path to the file</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileInfo.#ctor(Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Constructor
            </summary>
      <param name="InternalFile">Internal file</param>
    </member>
    <member name="M:Utilities.IO.FileInfo.Clone">
      <summary>
            Clones the file object
            </summary>
      <returns>The cloned object</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileInfo.CompareTo(Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Compares this to another file
            </summary>
      <param name="other">File to compare to</param>
      <returns />
    </member>
    <member name="M:Utilities.IO.FileInfo.CompareTo(System.Object)">
      <summary>
            Compares this object to another object
            </summary>
      <param name="obj">Object to compare it to</param>
      <returns />
    </member>
    <member name="M:Utilities.IO.FileInfo.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,System.Boolean)">
      <summary>
            Copies the file to another directory
            </summary>
      <param name="Directory">Directory to copy the file to</param>
      <param name="Overwrite">Should the file overwrite another file if found</param>
      <returns>The newly created file</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.Delete">
      <summary>
            Deletes the file
            </summary>
      <returns>Any response for deleting the resource (usually FTP, HTTP, etc)</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.Equals(Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Determines if the files are equal
            </summary>
      <param name="other">Other file</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.Execute(System.Diagnostics.ProcessStartInfo)">
      <summary>
            Executes the file
            </summary>
      <param name="Info">Info used to execute the file</param>
      <returns>The process object created when the executable is started</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.GetHashCode">
      <summary>
            Gets the hash code for the file
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves the file to a new directory
            </summary>
      <param name="Directory">Directory to move to</param>
    </member>
    <member name="M:Utilities.IO.FileInfo.Read">
      <summary>
            Reads the file in as a string
            </summary>
      <returns>The file contents as a string</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.ReadBinary">
      <summary>
            Reads a file as binary
            </summary>
      <returns>The file contents as a byte array</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.Rename(System.String)">
      <summary>
            Renames the file
            </summary>
      <param name="NewName">New name for the file</param>
    </member>
    <member name="M:Utilities.IO.FileInfo.To``1">
      <summary>
            Converts the file to the specified file format
            </summary>
      <typeparam name="T">File format</typeparam>
      <returns>The file as the file format object</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.To``2">
      <summary>
            Converts the file to the specified file format
            </summary>
      <typeparam name="T">File format</typeparam>
      <typeparam name="R">Record type</typeparam>
      <returns>The file as the file format object</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.To">
      <summary>
            Converts the file to the specified file format
            </summary>
      <returns>The file as the file format object</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.ToString">
      <summary>
            Returns the name of the file
            </summary>
      <returns>The name of the file</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileInfo.Write(System.String,System.IO.FileMode,System.Text.Encoding)">
      <summary>
            Writes content to the file
            </summary>
      <param name="Content">Content to write</param>
      <param name="Mode">Mode to open the file as</param>
      <param name="Encoding">Encoding to use for the content</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.Write(System.Byte[],System.IO.FileMode)">
      <summary>
            Writes content to the file
            </summary>
      <param name="Content">Content to write</param>
      <param name="Mode">Mode to open the file as</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.op_Implicit(Utilities.IO.FileInfo)~System.Byte[]">
      <summary>
            Reads the file and converts it to a byte array
            </summary>
      <param name="File">File to read</param>
      <returns>The file as a byte array</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.op_Implicit(Utilities.IO.FileInfo)~System.String">
      <summary>
            Reads the file and converts it to a string
            </summary>
      <param name="File">File to read</param>
      <returns>The file as a string</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.op_Inequality(Utilities.IO.FileInfo,Utilities.IO.FileInfo)">
      <summary>
            Determines if two directories are not equal
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.op_LessThan(Utilities.IO.FileInfo,Utilities.IO.FileInfo)">
      <summary>
            Less than
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.op_LessThanOrEqual(Utilities.IO.FileInfo,Utilities.IO.FileInfo)">
      <summary>
            Less than or equal
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.op_Equality(Utilities.IO.FileInfo,Utilities.IO.FileInfo)">
      <summary>
            Determines if two directories are equal
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.op_GreaterThan(Utilities.IO.FileInfo,Utilities.IO.FileInfo)">
      <summary>
            Greater than
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.FileInfo.op_GreaterThanOrEqual(Utilities.IO.FileInfo,Utilities.IO.FileInfo)">
      <summary>
            Greater than or equal
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>The result</returns>
    </member>
    <member name="P:Utilities.IO.FileInfo.Accessed">
      <summary>
            Last time accessed (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileInfo.Created">
      <summary>
            Time created (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileInfo.Directory">
      <summary>
            Directory the file is within
            </summary>
    </member>
    <member name="P:Utilities.IO.FileInfo.Exists">
      <summary>
            Does the file exist?
            </summary>
    </member>
    <member name="P:Utilities.IO.FileInfo.Extension">
      <summary>
            File extension
            </summary>
    </member>
    <member name="P:Utilities.IO.FileInfo.FullName">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileInfo.Length">
      <summary>
            Size of the file
            </summary>
    </member>
    <member name="P:Utilities.IO.FileInfo.Modified">
      <summary>
            Time modified (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileInfo.Name">
      <summary>
            Name of the file
            </summary>
    </member>
    <member name="P:Utilities.IO.FileInfo.InternalFile">
      <summary>
            Internal directory
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2">
      <summary>
            Directory base class
            </summary>
      <typeparam name="InternalDirectoryType">
            Data type internally to hold true directory info
            </typeparam>
      <typeparam name="DirectoryType">Directory type</typeparam>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.#ctor(`0,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="InternalDirectory">Internal directory object</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Clone">
      <summary>
            Clones the directory object
            </summary>
      <returns>The cloned object</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.CompareTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Compares this to another directory
            </summary>
      <param name="other">Directory to compare to</param>
      <returns />
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.CompareTo(System.Object)">
      <summary>
            Compares this object to another object
            </summary>
      <param name="obj">Object to compare it to</param>
      <returns />
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,Utilities.IO.Enums.CopyOptions)">
      <summary>
            Copies the directory to the specified parent directory
            </summary>
      <param name="Directory">Directory to copy to</param>
      <param name="Options">Copy options</param>
      <returns>Returns the new directory</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Create">
      <summary>
            Creates the directory
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Delete">
      <summary>
            Deletes the directory
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.EnumerateDirectories(System.String,System.IO.SearchOption)">
      <summary>
            Enumerates directories under this directory
            </summary>
      <param name="SearchPattern">Search pattern</param>
      <param name="Options">Search options</param>
      <returns>List of directories under this directory</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.EnumerateDirectories(System.Predicate{Utilities.IO.FileSystem.Interfaces.IDirectory},System.IO.SearchOption)">
      <summary>
            Enumerates sub directories (defaults to top level sub directories)
            </summary>
      <param name="Predicate">Predicate used to filter directories</param>
      <param name="Options">Search options to use</param>
      <returns>The list of directories</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.EnumerateFiles(System.String,System.IO.SearchOption)">
      <summary>
            Enumerates files under this directory
            </summary>
      <param name="SearchPattern">Search pattern</param>
      <param name="Options">Search options</param>
      <returns>List of files under this directory</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.EnumerateFiles(System.Predicate{Utilities.IO.FileSystem.Interfaces.IFile},System.IO.SearchOption)">
      <summary>
            Enumerates files within the directory (defaults to top level directory and not the sub directories)
            </summary>
      <param name="Predicate">Predicate used to filter files</param>
      <param name="Options">Search options to use</param>
      <returns>The list of files</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Equals(System.Object)">
      <summary>
            Determines if the two directories are the same
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they're the same, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Equals(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Determines if the directories are equal
            </summary>
      <param name="other">Other directory</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.GetEnumerator">
      <summary>
            Enumerates the files in the directory
            </summary>
      <returns>The files in the directory</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.GetHashCode">
      <summary>
            Returns the hash code for the directory
            </summary>
      <returns>The hash code for the directory</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves this directory under another directory
            </summary>
      <param name="Directory">Directory to move to</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Rename(System.String)">
      <summary>
            Renames the directory
            </summary>
      <param name="Name">Name of the new directory</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Enumerates the files and directories in the directory
            </summary>
      <returns>The files and directories</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.ToString">
      <summary>
            Gets info for the directory
            </summary>
      <returns>The full path to the directory</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.op_Inequality(Utilities.IO.FileSystem.BaseClasses.DirectoryBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Determines if two directories are not equal
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.op_LessThan(Utilities.IO.FileSystem.BaseClasses.DirectoryBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Less than
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.op_LessThanOrEqual(Utilities.IO.FileSystem.BaseClasses.DirectoryBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Less than or equal
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.op_Equality(Utilities.IO.FileSystem.BaseClasses.DirectoryBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Determines if two directories are equal
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.op_GreaterThan(Utilities.IO.FileSystem.BaseClasses.DirectoryBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Greater than
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.op_GreaterThanOrEqual(Utilities.IO.FileSystem.BaseClasses.DirectoryBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Greater than or equal
            </summary>
      <param name="Directory1">Directory 1</param>
      <param name="Directory2">Directory 2</param>
      <returns>The result</returns>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Accessed">
      <summary>
            Last time accessed (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Created">
      <summary>
            Date created (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Exists">
      <summary>
            Does it exist?
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.FullName">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Modified">
      <summary>
            Date modified (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Parent">
      <summary>
            Parent directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Root">
      <summary>
            Root directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Size">
      <summary>
            Size of the directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Domain">
      <summary>
            Domain
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.InternalDirectory">
      <summary>
            Internal directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.Password">
      <summary>
            Password
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.DirectoryBase`2.UserName">
      <summary>
            User name
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.BaseClasses.FileBase`2">
      <summary>
            Directory base class
            </summary>
      <typeparam name="FileType">File type</typeparam>
      <typeparam name="InternalFileType">Internal file type</typeparam>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.#ctor(`0)">
      <summary>
            Constructor
            </summary>
      <param name="InternalFile">Internal file</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.#ctor(`0,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="InternalFile">Internal file</param>
      <param name="UserName">User name</param>
      <param name="Password">Password</param>
      <param name="Domain">User's domain</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Clone">
      <summary>
            Clones the file object
            </summary>
      <returns>The cloned object</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.CompareTo(Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Compares this to another file
            </summary>
      <param name="other">File to compare to</param>
      <returns />
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.CompareTo(System.Object)">
      <summary>
            Compares this object to another object
            </summary>
      <param name="obj">Object to compare it to</param>
      <returns />
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,System.Boolean)">
      <summary>
            Copies the file to another directory
            </summary>
      <param name="Directory">Directory to copy the file to</param>
      <param name="Overwrite">Should the file overwrite another file if found</param>
      <returns>The newly created file</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Delete">
      <summary>
            Deletes the file
            </summary>
      <returns>Any response for deleting the resource (usually FTP, HTTP, etc)</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Equals(Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Determines if the files are equal
            </summary>
      <param name="other">Other file</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.GetHashCode">
      <summary>
            Gets the hash code for the file
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves the file to a new directory
            </summary>
      <param name="Directory">Directory to move to</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Read">
      <summary>
            Reads the file in as a string
            </summary>
      <returns>The file contents as a string</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.ReadBinary">
      <summary>
            Reads a file as binary
            </summary>
      <returns>The file contents as a byte array</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Rename(System.String)">
      <summary>
            Renames the file
            </summary>
      <param name="NewName">New name for the file</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.ToString">
      <summary>
            Returns the name of the file
            </summary>
      <returns>The name of the file</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Write(System.String,System.IO.FileMode,System.Text.Encoding)">
      <summary>
            Writes content to the file
            </summary>
      <param name="Content">Content to write</param>
      <param name="Mode">Mode to open the file as</param>
      <param name="Encoding">Encoding to use for the content</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Write(System.Byte[],System.IO.FileMode)">
      <summary>
            Writes content to the file
            </summary>
      <param name="Content">Content to write</param>
      <param name="Mode">Mode to open the file as</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.op_Implicit(Utilities.IO.FileSystem.BaseClasses.FileBase{`0,`1})~System.Byte[]">
      <summary>
            Reads the file and converts it to a byte array
            </summary>
      <param name="File">File to read</param>
      <returns>The file as a byte array</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.op_Implicit(Utilities.IO.FileSystem.BaseClasses.FileBase{`0,`1})~System.String">
      <summary>
            Reads the file and converts it to a string
            </summary>
      <param name="File">File to read</param>
      <returns>The file as a string</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.op_Inequality(Utilities.IO.FileSystem.BaseClasses.FileBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Determines if two directories are not equal
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.op_LessThan(Utilities.IO.FileSystem.BaseClasses.FileBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Less than
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.op_LessThanOrEqual(Utilities.IO.FileSystem.BaseClasses.FileBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Less than or equal
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.op_Equality(Utilities.IO.FileSystem.BaseClasses.FileBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Determines if two directories are equal
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.op_GreaterThan(Utilities.IO.FileSystem.BaseClasses.FileBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Greater than
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileBase`2.op_GreaterThanOrEqual(Utilities.IO.FileSystem.BaseClasses.FileBase{`0,`1},Utilities.IO.FileSystem.Interfaces.IFile)">
      <summary>
            Greater than or equal
            </summary>
      <param name="File1">File 1</param>
      <param name="File2">File 2</param>
      <returns>The result</returns>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Accessed">
      <summary>
            Last time accessed (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Created">
      <summary>
            Time created (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Directory">
      <summary>
            Directory the file is within
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Exists">
      <summary>
            Does the file exist?
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Extension">
      <summary>
            File extension
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.FullName">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Length">
      <summary>
            Size of the file
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Modified">
      <summary>
            Time modified (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Name">
      <summary>
            Name of the file
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Domain">
      <summary>
            Domain of the user
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.InternalFile">
      <summary>
            Internal directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.Password">
      <summary>
            Password
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileBase`2.UserName">
      <summary>
            User name used
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.BaseClasses.FileSystemBase">
      <summary>
            File system base class
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Interfaces.IFileSystem">
      <summary>
            Interface for the file system
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFileSystem.CanHandle(System.String)">
      <summary>
            Returns true if it can handle the path, false otherwise
            </summary>
      <param name="Path">The path to check against</param>
      <returns>True if it can handle the path, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFileSystem.Directory(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the directory representation for the directory
            </summary>
      <param name="Path">Path to the directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
      <returns>The directory object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Interfaces.IFileSystem.File(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the class representation for the file
            </summary>
      <param name="Path">Path to the file</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
      <returns>The file object</returns>
    </member>
    <member name="P:Utilities.IO.FileSystem.Interfaces.IFileSystem.Name">
      <summary>
            Name of the file system
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileSystemBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileSystemBase.CanHandle(System.String)">
      <summary>
            Returns true if it can handle the path, false otherwise
            </summary>
      <param name="Path">The path to check against</param>
      <returns>True if it can handle the path, false otherwise</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileSystemBase.Directory(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the directory representation for the directory
            </summary>
      <param name="Path">Path to the directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
      <returns>The directory object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileSystemBase.File(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the class representation for the file
            </summary>
      <param name="Path">Path to the file</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
      <returns>The file object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.FileSystemBase.AbsolutePath(System.String)">
      <summary>
            Gets the absolute path of the variable passed in
            </summary>
      <param name="Path">Path to convert to absolute</param>
      <returns>The absolute path of the path passed in</returns>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileSystemBase.Name">
      <summary>
            Name of the file system
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileSystemBase.HandleRegex">
      <summary>
            Regex used to determine if the file system can handle the path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.BaseClasses.FileSystemBase.HandleRegexString">
      <summary>
            Regex string used to determine if the file system can handle the path
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.BaseClasses.LocalFileSystemBase">
      <summary>
            Local file system base class
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.LocalFileSystemBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.LocalFileSystemBase.Directory(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the directory representation for the directory
            </summary>
      <param name="Path">Path to the directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
      <returns>The directory object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.LocalFileSystemBase.File(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the class representation for the file
            </summary>
      <param name="Path">Path to the file</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
      <returns>The file object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.BaseClasses.LocalFileSystemBase.Dispose(System.Boolean)">
      <summary>
            Function to override in order to dispose objects
            </summary>
      <param name="Managed">
            If true, managed and unmanaged objects should be disposed. Otherwise unmanaged objects only.
            </param>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.AbsoluteLocalFileSystem">
      <summary>
            Absolute local file system
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.AbsoluteLocalFileSystem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.AbsoluteLocalFileSystem.AbsolutePath(System.String)">
      <summary>
            Gets the absolute path of the variable passed in
            </summary>
      <param name="Path">Path to convert to absolute</param>
      <returns>The absolute path of the path passed in</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.AbsoluteLocalFileSystem.Dispose(System.Boolean)">
      <summary>
            Function to override in order to dispose objects
            </summary>
      <param name="Managed">
            If true, managed and unmanaged objects should be disposed. Otherwise unmanaged objects only.
            </param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.AbsoluteLocalFileSystem.Name">
      <summary>
            Name of the file system
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.AbsoluteLocalFileSystem.HandleRegexString">
      <summary>
            Relative starter
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.FtpDirectory">
      <summary>
            Directory class
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Path">Path to the directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.#ctor(System.Uri,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Directory">Internal directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,Utilities.IO.Enums.CopyOptions)">
      <summary>
            Copies the directory to the specified parent directory
            </summary>
      <param name="Directory">Directory to copy to</param>
      <param name="Options">Options</param>
      <returns>Newly created directory</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.Create">
      <summary>
            Not used
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.Delete">
      <summary>
            Not used
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.EnumerateDirectories(System.String,System.IO.SearchOption)">
      <summary>
            Not used
            </summary>
      <param name="SearchPattern" />
      <param name="Options" />
      <returns />
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.EnumerateFiles(System.String,System.IO.SearchOption)">
      <summary>
            Not used
            </summary>
      <param name="SearchPattern" />
      <param name="Options" />
      <returns />
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Not used
            </summary>
      <param name="Directory" />
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.Rename(System.String)">
      <summary>
            Not used
            </summary>
      <param name="Name" />
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.SendRequest(System.Net.FtpWebRequest)">
      <summary>
            Sends the request to the URL specified
            </summary>
      <param name="Request">The web request object</param>
      <returns>The string returned by the service</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.SetupCredentials(System.Net.FtpWebRequest)">
      <summary>
            Sets up any credentials (basic authentication, for OAuth, please use the OAuth class to
            create the
            URL)
            </summary>
      <param name="Request">The web request object</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpDirectory.SetupData(System.Net.FtpWebRequest,System.Byte[])">
      <summary>
            Sets up any data that needs to be sent
            </summary>
      <param name="Request">The web request object</param>
      <param name="Data">Data to send with the request</param>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpDirectory.Accessed">
      <summary>
            returns now
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpDirectory.Created">
      <summary>
            returns now
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpDirectory.Exists">
      <summary>
            returns true
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpDirectory.FullName">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpDirectory.Modified">
      <summary>
            returns now
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpDirectory.Name">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpDirectory.Parent">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpDirectory.Root">
      <summary>
            Root
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpDirectory.Size">
      <summary>
            Size (returns 0)
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.FtpFile">
      <summary>
            Basic ftp file class
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Path">Path to the file</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.#ctor(System.Uri,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="File">File to use</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,System.Boolean)">
      <summary>
            Copies the file to another directory
            </summary>
      <param name="Directory">Directory to copy the file to</param>
      <param name="Overwrite">Should the file overwrite another file if found</param>
      <returns>The newly created file</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.Delete">
      <summary>
            Delete (does nothing)
            </summary>
      <returns>Any response for deleting the resource (usually FTP, HTTP, etc)</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves the file (not used)
            </summary>
      <param name="Directory">Not used</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.Read">
      <summary>
            Reads the web page
            </summary>
      <returns>The content as a string</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.ReadBinary">
      <summary>
            Reads the web page
            </summary>
      <returns>The content as a byte array</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.Rename(System.String)">
      <summary>
            Renames the file (not used)
            </summary>
      <param name="NewName">Not used</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.Write(System.String,System.IO.FileMode,System.Text.Encoding)">
      <summary>
            Not used
            </summary>
      <param name="Content">Not used</param>
      <param name="Mode">Not used</param>
      <param name="Encoding">Not used</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.Write(System.Byte[],System.IO.FileMode)">
      <summary>
            Not used
            </summary>
      <param name="Content">Not used</param>
      <param name="Mode">Not used</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.SendRequest(System.Net.FtpWebRequest)">
      <summary>
            Sends the request to the URL specified
            </summary>
      <param name="Request">The web request object</param>
      <returns>The string returned by the service</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.SetupCredentials(System.Net.FtpWebRequest)">
      <summary>
            Sets up any credentials (basic authentication, for OAuth, please use the OAuth class to
            create the
            URL)
            </summary>
      <param name="Request">The web request object</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFile.SetupData(System.Net.FtpWebRequest,System.Byte[])">
      <summary>
            Sets up any data that needs to be sent
            </summary>
      <param name="Request">The web request object</param>
      <param name="Data">Data to send with the request</param>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFile.Accessed">
      <summary>
            Time accessed (Just returns now)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFile.Created">
      <summary>
            Time created (Just returns now)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFile.Directory">
      <summary>
            Directory base path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFile.Exists">
      <summary>
            Does it exist? Always true.
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFile.Extension">
      <summary>
            Extension (always empty)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFile.FullName">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFile.Length">
      <summary>
            Size of the file (always 0)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFile.Modified">
      <summary>
            Time modified (just returns now)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFile.Name">
      <summary>
            Absolute path of the file (same as FullName)
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.FtpFileSystem">
      <summary>
            FTP file system
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFileSystem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFileSystem.Directory(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the directory representation for the directory
            </summary>
      <param name="Path">Path to the directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
      <returns>The directory object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFileSystem.File(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the class representation for the file
            </summary>
      <param name="Path">Path to the file</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
      <returns>The file object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFileSystem.AbsolutePath(System.String)">
      <summary>
            Gets the absolute path of the variable passed in
            </summary>
      <param name="Path">Path to convert to absolute</param>
      <returns>The absolute path of the path passed in</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.FtpFileSystem.Dispose(System.Boolean)">
      <summary>
            Used to dispose of any resources
            </summary>
      <param name="Managed">Should managed resources be disposed</param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFileSystem.Name">
      <summary>
            Name of the file system
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.FtpFileSystem.HandleRegexString">
      <summary>
            Relative starter
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.HttpFileSystem">
      <summary>
            HTTP file system
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.HttpFileSystem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.HttpFileSystem.Directory(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the directory representation for the directory
            </summary>
      <param name="Path">Path to the directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
      <returns>The directory object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.HttpFileSystem.File(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the class representation for the file
            </summary>
      <param name="Path">Path to the file</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
      <returns>The file object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.HttpFileSystem.AbsolutePath(System.String)">
      <summary>
            Gets the absolute path of the variable passed in
            </summary>
      <param name="Path">Path to convert to absolute</param>
      <returns>The absolute path of the path passed in</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.HttpFileSystem.Dispose(System.Boolean)">
      <summary>
            Used to dispose of any resources
            </summary>
      <param name="Managed">Should managed resources be disposed</param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.HttpFileSystem.Name">
      <summary>
            Name of the file system
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.HttpFileSystem.HandleRegexString">
      <summary>
            Relative starter
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.LocalDirectory">
      <summary>
            Local directory class
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Path">Path to the directory</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.#ctor(System.IO.DirectoryInfo)">
      <summary>
            Constructor
            </summary>
      <param name="Directory">Internal directory</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,Utilities.IO.Enums.CopyOptions)">
      <summary>
            Copies the directory to the specified parent directory
            </summary>
      <param name="Directory">Directory to copy to</param>
      <param name="Options">Copy options</param>
      <returns>The newly created directory</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.Create">
      <summary>
            Creates the directory
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.Delete">
      <summary>
            Deletes the directory
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.EnumerateDirectories(System.String,System.IO.SearchOption)">
      <summary>
            Enumerates directories under this directory
            </summary>
      <param name="SearchPattern">Search pattern</param>
      <param name="Options">Search options</param>
      <returns>List of directories under this directory</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.EnumerateFiles(System.String,System.IO.SearchOption)">
      <summary>
            Enumerates files under this directory
            </summary>
      <param name="SearchPattern">Search pattern</param>
      <param name="Options">Search options</param>
      <returns>List of files under this directory</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves this directory under another directory
            </summary>
      <param name="Directory">Directory to move to</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalDirectory.Rename(System.String)">
      <summary>
            Renames the directory
            </summary>
      <param name="Name">Name of the new directory</param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalDirectory.Accessed">
      <summary>
            Time accessed (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalDirectory.Created">
      <summary>
            Time created (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalDirectory.Exists">
      <summary>
            Does the directory exist?
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalDirectory.FullName">
      <summary>
            Full path of the directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalDirectory.Modified">
      <summary>
            Time modified (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalDirectory.Name">
      <summary>
            Name of the directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalDirectory.Parent">
      <summary>
            Parent directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalDirectory.Root">
      <summary>
            Root directory
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalDirectory.Size">
      <summary>
            Size of the directory
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.LocalFile">
      <summary>
            Basic local file class
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Path">Path to the file</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.#ctor(System.IO.FileInfo)">
      <summary>
            Constructor
            </summary>
      <param name="File">File to use</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,System.Boolean)">
      <summary>
            Copies the file to another directory
            </summary>
      <param name="Directory">Directory to copy the file to</param>
      <param name="Overwrite">Should the file overwrite another file if found</param>
      <returns>The newly created file</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.Delete">
      <summary>
            Deletes the file
            </summary>
      <returns>Any response for deleting the resource (usually FTP, HTTP, etc)</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves the file to a new directory
            </summary>
      <param name="Directory">Directory to move to</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.Read">
      <summary>
            Reads the file in as a string
            </summary>
      <returns>The file contents as a string</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.ReadBinary">
      <summary>
            Reads a file as binary
            </summary>
      <returns>The file contents as a byte array</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.Rename(System.String)">
      <summary>
            Renames the file
            </summary>
      <param name="NewName">New name for the file</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.Write(System.String,System.IO.FileMode,System.Text.Encoding)">
      <summary>
            Writes content to the file
            </summary>
      <param name="Content">Content to write</param>
      <param name="Mode">Mode to open the file as</param>
      <param name="Encoding">Encoding to use for the content</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.LocalFile.Write(System.Byte[],System.IO.FileMode)">
      <summary>
            Writes content to the file
            </summary>
      <param name="Content">Content to write</param>
      <param name="Mode">Mode to open the file as</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalFile.Accessed">
      <summary>
            Last time accessed (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalFile.Created">
      <summary>
            Time created (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalFile.Directory">
      <summary>
            Directory the file is within
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalFile.Exists">
      <summary>
            Does the file exist?
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalFile.Extension">
      <summary>
            File extension
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalFile.FullName">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalFile.Length">
      <summary>
            Size of the file
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalFile.Modified">
      <summary>
            Time modified (UTC time)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.LocalFile.Name">
      <summary>
            Name of the file
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.NetworkFileSystem">
      <summary>
            Network file system
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.NetworkFileSystem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.NetworkFileSystem.AbsolutePath(System.String)">
      <summary>
            Gets the absolute path of the variable passed in
            </summary>
      <param name="Path">Path to convert to absolute</param>
      <returns>The absolute path of the path passed in</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.NetworkFileSystem.Dispose(System.Boolean)">
      <summary>
            Function to override in order to dispose objects
            </summary>
      <param name="Managed">
            If true, managed and unmanaged objects should be disposed. Otherwise unmanaged objects only.
            </param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.NetworkFileSystem.Name">
      <summary>
            Name of the file system
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.NetworkFileSystem.HandleRegexString">
      <summary>
            Relative starter
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.RelativeLocalFileSystem">
      <summary>
            Relative local file system
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.RelativeLocalFileSystem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.RelativeLocalFileSystem.AbsolutePath(System.String)">
      <summary>
            Gets the absolute path of the variable passed in
            </summary>
      <param name="Path">Path to convert to absolute</param>
      <returns>The absolute path of the path passed in</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.RelativeLocalFileSystem.Dispose(System.Boolean)">
      <summary>
            Function to override in order to dispose objects
            </summary>
      <param name="Managed">
            If true, managed and unmanaged objects should be disposed. Otherwise unmanaged objects only.
            </param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.RelativeLocalFileSystem.Name">
      <summary>
            Name of the file system
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.RelativeLocalFileSystem.HandleRegexString">
      <summary>
            Relative starter
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.WebDirectory">
      <summary>
            Directory class
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Path">Path to the directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.#ctor(System.Uri,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Directory">Internal directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,Utilities.IO.Enums.CopyOptions)">
      <summary>
            Copies the directory to the specified parent directory
            </summary>
      <param name="Directory">Directory to copy to</param>
      <param name="Options">Options</param>
      <returns>Newly created directory</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.Create">
      <summary>
            Not used
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.Delete">
      <summary>
            Not used
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.EnumerateDirectories(System.String,System.IO.SearchOption)">
      <summary>
            Not used
            </summary>
      <param name="SearchPattern" />
      <param name="Options" />
      <returns />
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.EnumerateFiles(System.String,System.IO.SearchOption)">
      <summary>
            Not used
            </summary>
      <param name="SearchPattern" />
      <param name="Options" />
      <returns />
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Not used
            </summary>
      <param name="Directory" />
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.Rename(System.String)">
      <summary>
            Not used
            </summary>
      <param name="Name" />
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.SendRequest(System.Net.HttpWebRequest)">
      <summary>
            Sends the request to the URL specified
            </summary>
      <param name="Request">The web request object</param>
      <returns>The string returned by the service</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.SetupData(System.Net.HttpWebRequest,System.String)">
      <summary>
            Sets up any data that needs to be sent
            </summary>
      <param name="Request">The web request object</param>
      <param name="Data">Data to send with the request</param>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebDirectory.SetupCredentials(System.Net.HttpWebRequest)">
      <summary>
            Sets up any credentials (basic authentication, for OAuth, please use the OAuth class to
            create the
            URL)
            </summary>
      <param name="Request">The web request object</param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebDirectory.Accessed">
      <summary>
            returns now
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebDirectory.Created">
      <summary>
            returns now
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebDirectory.Exists">
      <summary>
            returns true
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebDirectory.FullName">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebDirectory.Modified">
      <summary>
            returns now
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebDirectory.Name">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebDirectory.Parent">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebDirectory.Root">
      <summary>
            Root
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebDirectory.Size">
      <summary>
            Size (returns 0)
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Default.WebFile">
      <summary>
            Basic web file class
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Path">Path to the file</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.#ctor(System.Uri,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="File">File to use</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.CopyTo(Utilities.IO.FileSystem.Interfaces.IDirectory,System.Boolean)">
      <summary>
            Copies the file to another directory
            </summary>
      <param name="Directory">Directory to copy the file to</param>
      <param name="Overwrite">Should the file overwrite another file if found</param>
      <returns>The newly created file</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.Delete">
      <summary>
            Delete (does nothing)
            </summary>
      <returns>Any response for deleting the resource (usually FTP, HTTP, etc)</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.MoveTo(Utilities.IO.FileSystem.Interfaces.IDirectory)">
      <summary>
            Moves the file (not used)
            </summary>
      <param name="Directory">Not used</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.Read">
      <summary>
            Reads the web page
            </summary>
      <returns>The content as a string</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.ReadBinary">
      <summary>
            Reads the web page
            </summary>
      <returns>The content as a byte array</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.Rename(System.String)">
      <summary>
            Renames the file (not used)
            </summary>
      <param name="NewName">Not used</param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.Write(System.String,System.IO.FileMode,System.Text.Encoding)">
      <summary>
            Not used
            </summary>
      <param name="Content">Not used</param>
      <param name="Mode">Not used</param>
      <param name="Encoding">Not used</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.Write(System.Byte[],System.IO.FileMode)">
      <summary>
            Not used
            </summary>
      <param name="Content">Not used</param>
      <param name="Mode">Not used</param>
      <returns>The result of the write or original content</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.SendRequest(System.Net.HttpWebRequest)">
      <summary>
            Sends the request to the URL specified
            </summary>
      <param name="Request">The web request object</param>
      <returns>The string returned by the service</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.SetupData(System.Net.HttpWebRequest,System.String)">
      <summary>
            Sets up any data that needs to be sent
            </summary>
      <param name="Request">The web request object</param>
      <param name="Data">Data to send with the request</param>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.IO.FileSystem.Default.WebFile.SetupCredentials(System.Net.HttpWebRequest)">
      <summary>
            Sets up any credentials (basic authentication, for OAuth, please use the OAuth class to
            create the
            URL)
            </summary>
      <param name="Request">The web request object</param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebFile.Accessed">
      <summary>
            Time accessed (Just returns now)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebFile.Created">
      <summary>
            Time created (Just returns now)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebFile.Directory">
      <summary>
            Directory base path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebFile.Exists">
      <summary>
            Does it exist? Always true.
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebFile.Extension">
      <summary>
            Extension (always empty)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebFile.FullName">
      <summary>
            Full path
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebFile.Length">
      <summary>
            Size of the file (always 0)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebFile.Modified">
      <summary>
            Time modified (just returns now)
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Default.WebFile.Name">
      <summary>
            Absolute path of the file (same as FullName)
            </summary>
    </member>
    <member name="T:Utilities.IO.FileSystem.Manager">
      <summary>
            File system manager
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Manager.Directory(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the directory representation for the directory
            </summary>
      <param name="Path">Path to the directory</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the directory (optional)</param>
      <param name="UserName">User name to be used to access the directory (optional)</param>
      <returns>The directory object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Manager.File(System.String,System.String,System.String,System.String)">
      <summary>
            Gets the class representation for the file
            </summary>
      <param name="Path">Path to the file</param>
      <param name="Domain">Domain of the user (optional)</param>
      <param name="Password">Password to be used to access the file (optional)</param>
      <param name="UserName">User name to be used to access the file (optional)</param>
      <returns>The file object</returns>
    </member>
    <member name="M:Utilities.IO.FileSystem.Manager.ToString">
      <summary>
            Outputs the file system information in string format
            </summary>
      <returns>The list of file systems that are available</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.FileSystem.Manager.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">
            Determines if all objects should be disposed or just managed objects
            </param>
    </member>
    <member name="M:Utilities.IO.FileSystem.Manager.FindSystem(System.String)">
      <summary>
            Finds a file system compatible with the path
            </summary>
      <param name="Path">Path to search for</param>
      <returns>The file system associated with the path</returns>
    </member>
    <member name="P:Utilities.IO.FileSystem.Manager.FileSystems">
      <summary>
            File systems that the library can use
            </summary>
    </member>
    <member name="P:Utilities.IO.FileSystem.Manager.Item(System.String)">
      <summary>
            Gets the file system by name
            </summary>
      <param name="Name">Name of the file system</param>
      <returns>The file system specified</returns>
    </member>
    <member name="T:Utilities.IO.FileSystem.Module.FileSystemModule">
      <summary>
            File system module
            </summary>
    </member>
    <member name="M:Utilities.IO.FileSystem.Module.FileSystemModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.IO.FileSystem.Module.FileSystemModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.IO.Log">
      <summary>
            Logging class
            </summary>
    </member>
    <member name="M:Utilities.IO.Log.Get(System.String)">
      <summary>
            Gets the log specified
            </summary>
      <param name="Name">Name of the log</param>
      <returns>The log specified</returns>
    </member>
    <member name="T:Utilities.IO.Logging.BaseClasses.Format">
      <summary>
            Delegate used to format the message
            </summary>
      <param name="Message">Message to format</param>
      <param name="Type">Type of message</param>
      <param name="args">Args to insert into the message</param>
      <returns>The formatted message</returns>
    </member>
    <member name="T:Utilities.IO.Logging.BaseClasses.LogBase`1">
      <summary>
            Base class for logs
            </summary>
      <typeparam name="LogType">Log type</typeparam>
    </member>
    <member name="T:Utilities.IO.Logging.Interfaces.ILog">
      <summary>
            Log interface
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.Interfaces.ILog.LogMessage(System.String,Utilities.IO.Logging.Enums.MessageType,System.Object[])">
      <summary>
            Logs a message
            </summary>
      <param name="Message">Message text</param>
      <param name="Type">Message type</param>
      <param name="args">
            Any additional arguments that will be used in formatting the message
            </param>
    </member>
    <member name="P:Utilities.IO.Logging.Interfaces.ILog.Name">
      <summary>
            Name of the logger
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name of the log</param>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.Dispose">
      <summary>
            Disposes the object
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.LogMessage(System.String,Utilities.IO.Logging.Enums.MessageType,System.Object[])">
      <summary>
            Logs a message
            </summary>
      <param name="Message">Message to log</param>
      <param name="Type">Type of message</param>
      <param name="args">args to format/insert into the message</param>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.ToString">
      <summary>
            String representation of the logger
            </summary>
      <returns>The name of the logger</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">
            True to dispose of all resources, false only disposes of native resources
            </param>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LogBase`1.Name">
      <summary>
            Name of the log
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LogBase`1.End">
      <summary>
            Called when the log is "closed"
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LogBase`1.FormatMessage">
      <summary>
            Format message function
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LogBase`1.Log">
      <summary>
            Called to log the current message
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LogBase`1.Start">
      <summary>
            Called when the log is "opened"
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.BaseClasses.LoggerBase">
      <summary>
            Logger base
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.Interfaces.ILogger">
      <summary>
            Logger interface
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.Interfaces.ILogger.AddLog(System.String)">
      <summary>
            Adds a log object or replaces one already in use
            </summary>
      <param name="Name">The name of the log file</param>
    </member>
    <member name="M:Utilities.IO.Logging.Interfaces.ILogger.GetLog(System.String)">
      <summary>
            Gets a specified log
            </summary>
      <param name="Name">The name of the log file</param>
      <returns>The log file specified</returns>
    </member>
    <member name="P:Utilities.IO.Logging.Interfaces.ILogger.Logs">
      <summary>
            Logs held by the logger
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.Interfaces.ILogger.Name">
      <summary>
            Name of the logger
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LoggerBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LoggerBase.AddLog(System.String)">
      <summary>
            Adds a log object or replaces one already in use
            </summary>
      <param name="Name">The name of the log file</param>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LoggerBase.Dispose">
      <summary>
            Disposes the object
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LoggerBase.GetLog(System.String)">
      <summary>
            Gets a specified log
            </summary>
      <param name="Name">The name of the log file</param>
      <returns>The log file specified</returns>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LoggerBase.ToString">
      <summary>
            String representation of the logger
            </summary>
      <returns>The name of the logger</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LoggerBase.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">
            True to dispose of all resources, false only disposes of native resources
            </param>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LoggerBase.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LoggerBase.Logs">
      <summary>
            Called to log the current message
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LoggerBase.Name">
      <summary>
            Name of the logger
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.Default.DefaultLog">
      <summary>
            Outputs messages to a file in ~/App_Data/Logs/ if a web app or ~/Logs/ if windows app with
            the format Name+DateTime.Now+".log"
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.Default.DefaultLog.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.Default.DefaultLog.FileName">
      <summary>
            File name
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.Default.DefaultLogger">
      <summary>
            Default logger if one isn't found
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.Default.DefaultLogger.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.Default.DefaultLogger.AddLog(System.String)">
      <summary>
            Adds a log to the logger
            </summary>
      <param name="Name">Name of the log</param>
    </member>
    <member name="P:Utilities.IO.Logging.Default.DefaultLogger.Name">
      <summary>
            Name of the logger
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.Enums.MessageType">
      <summary>
            Message type
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.General">
      <summary>
            General message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Debug">
      <summary>
            Debug message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Trace">
      <summary>
            Trace message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Info">
      <summary>
            Info message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Warn">
      <summary>
            Warn message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Error">
      <summary>
            Error message
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.Manager">
      <summary>
            Logging manager
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.Manager.GetLog(System.String)">
      <summary>
            Gets a specified log
            </summary>
      <param name="Name">The name of the log file</param>
      <returns>The log file specified</returns>
    </member>
    <member name="M:Utilities.IO.Logging.Manager.ToString">
      <summary>
            Outputs the logging information
            </summary>
      <returns>The logger information</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.IO.Logging.Manager.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">
            Determines if all objects should be disposed or just managed objects
            </param>
    </member>
    <member name="P:Utilities.IO.Logging.Manager.LoggerUsing">
      <summary>
            Logger that the system uses
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.Module.LoggingModule">
      <summary>
            Logging module
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.Module.LoggingModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.IO.Logging.Module.LoggingModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.IO.Messaging.BaseClasses.MessageBase">
      <summary>
            Message base
            </summary>
    </member>
    <member name="T:Utilities.IO.Messaging.Interfaces.IMessage">
      <summary>
            Message interface
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.Interfaces.IMessage.Send``1(``0)">
      <summary>
            Sends a message
            </summary>
      <typeparam name="T">Model type</typeparam>
      <param name="Model">Model object</param>
      <returns>The async task</returns>
    </member>
    <member name="M:Utilities.IO.Messaging.Interfaces.IMessage.Send">
      <summary>
            Sends a message
            </summary>
      <returns>The async task</returns>
    </member>
    <member name="P:Utilities.IO.Messaging.Interfaces.IMessage.Body">
      <summary>
            Body of the text (may be combined with the model object if one is supplied)
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.Interfaces.IMessage.From">
      <summary>
            Whom the message is from
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.Interfaces.IMessage.Subject">
      <summary>
            The subject of the message
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.Interfaces.IMessage.To">
      <summary>
            Whom the message is to
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.BaseClasses.MessageBase.#ctor(Utilities.IO.Messaging.Interfaces.IMessagingSystem)">
      <summary>
            Constructor
            </summary>
      <param name="MessagingSystem">Messaging system used to create the message</param>
    </member>
    <member name="M:Utilities.IO.Messaging.BaseClasses.MessageBase.Send``1(``0)">
      <summary>
            Send a message
            </summary>
      <typeparam name="T">Model type</typeparam>
      <param name="Model">Model object</param>
      <returns>The async task object</returns>
    </member>
    <member name="M:Utilities.IO.Messaging.BaseClasses.MessageBase.Send">
      <summary>
            Send a message
            </summary>
      <returns>The async task object</returns>
    </member>
    <member name="P:Utilities.IO.Messaging.BaseClasses.MessageBase.Body">
      <summary>
            Body of the text
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.BaseClasses.MessageBase.From">
      <summary>
            Whom the message is from
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.BaseClasses.MessageBase.Subject">
      <summary>
            The subject of the Communicator
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.BaseClasses.MessageBase.To">
      <summary>
            Whom the message is to
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.BaseClasses.MessageBase.MessagingSystem">
      <summary>
            Messaging system
            </summary>
    </member>
    <member name="T:Utilities.IO.Messaging.BaseClasses.MessagingSystemBase">
      <summary>
            Messaging system base class
            </summary>
    </member>
    <member name="T:Utilities.IO.Messaging.Interfaces.IMessagingSystem">
      <summary>
            Messaging system interface
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.Interfaces.IMessagingSystem.Send``1(Utilities.IO.Messaging.Interfaces.IMessage,``0)">
      <summary>
            Sends a message asynchronously
            </summary>
      <typeparam name="T">Model type</typeparam>
      <param name="Message">Message to send</param>
      <param name="Model">Model object</param>
      <returns>The async task</returns>
    </member>
    <member name="M:Utilities.IO.Messaging.Interfaces.IMessagingSystem.Send(Utilities.IO.Messaging.Interfaces.IMessage)">
      <summary>
            Sends a message asynchronously
            </summary>
      <param name="Message">Message to send</param>
      <returns>The async task</returns>
    </member>
    <member name="P:Utilities.IO.Messaging.Interfaces.IMessagingSystem.MessageType">
      <summary>
            Message type used by the communicator
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.Interfaces.IMessagingSystem.Name">
      <summary>
            Name of the communicator
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.BaseClasses.MessagingSystemBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.BaseClasses.MessagingSystemBase.Initialize(System.Collections.Generic.IEnumerable{Utilities.IO.Messaging.Interfaces.IFormatter})">
      <summary>
            Initializes the system
            </summary>
      <param name="Formatters">Passes in the list of formatters that the system has found</param>
      <requires description="Formatters" exception="T:System.ArgumentNullException" csharp="Formatters != null" vb="Formatters &lt;&gt; Nothing">Formatters != null</requires>
      <exception cref="T:System.ArgumentNullException">Formatters == null</exception>
    </member>
    <member name="M:Utilities.IO.Messaging.BaseClasses.MessagingSystemBase.Send``1(Utilities.IO.Messaging.Interfaces.IMessage,``0)">
      <summary>
            Sends a message asynchronously
            </summary>
      <typeparam name="T">Model type</typeparam>
      <param name="Message">Message to send</param>
      <param name="Model">Model object</param>
      <returns>The async task</returns>
    </member>
    <member name="M:Utilities.IO.Messaging.BaseClasses.MessagingSystemBase.Send(Utilities.IO.Messaging.Interfaces.IMessage)">
      <summary>
            Sends a message asynchronously
            </summary>
      <param name="Message">Message to send</param>
      <returns>The async task</returns>
    </member>
    <member name="M:Utilities.IO.Messaging.BaseClasses.MessagingSystemBase.InternalSend(Utilities.IO.Messaging.Interfaces.IMessage)">
      <summary>
            Internal function
            </summary>
      <param name="Message">Message to send</param>
    </member>
    <member name="P:Utilities.IO.Messaging.BaseClasses.MessagingSystemBase.Formatters">
      <summary>
            Formatters that the system have available
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.BaseClasses.MessagingSystemBase.MessageType">
      <summary>
            Message type that this handles
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.BaseClasses.MessagingSystemBase.Name">
      <summary>
            Name of the messaging system
            </summary>
    </member>
    <member name="T:Utilities.IO.EmailMessage">
      <summary>
            Email message class
            </summary>
    </member>
    <member name="M:Utilities.IO.EmailMessage.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.EmailMessage.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">
            True to dispose of all resources, false only disposes of native resources
            </param>
    </member>
    <member name="P:Utilities.IO.EmailMessage.Attachments">
      <summary>
            Attachments
            </summary>
    </member>
    <member name="P:Utilities.IO.EmailMessage.Bcc">
      <summary>
            BCC
            </summary>
    </member>
    <member name="P:Utilities.IO.EmailMessage.CC">
      <summary>
            CC
            </summary>
    </member>
    <member name="P:Utilities.IO.EmailMessage.EmbeddedResources">
      <summary>
            Embedded resource
            </summary>
    </member>
    <member name="P:Utilities.IO.EmailMessage.Password">
      <summary>
            Password for the user
            </summary>
    </member>
    <member name="P:Utilities.IO.EmailMessage.Port">
      <summary>
            Port to use
            </summary>
    </member>
    <member name="P:Utilities.IO.EmailMessage.Priority">
      <summary>
            Priority
            </summary>
    </member>
    <member name="P:Utilities.IO.EmailMessage.Server">
      <summary>
            Server
            </summary>
    </member>
    <member name="P:Utilities.IO.EmailMessage.UserName">
      <summary>
            User name for the user
            </summary>
    </member>
    <member name="P:Utilities.IO.EmailMessage.UseSSL">
      <summary>
            Use SSL?
            </summary>
    </member>
    <member name="T:Utilities.IO.Messaging.Default.SMTPSystem">
      <summary>
            SMTP emailer
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.Default.SMTPSystem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.Default.SMTPSystem.InternalSend(Utilities.IO.Messaging.Interfaces.IMessage)">
      <summary>
            Internal send message
            </summary>
      <param name="Message2">Message</param>
    </member>
    <member name="M:Utilities.IO.Messaging.Default.SMTPSystem.SendMessage(System.Net.Mail.SmtpClient,Utilities.IO.EmailMessage,System.Net.Mail.MailMessage)">
      <summary>
            Sends the message
            </summary>
      <param name="smtpClient">SMTP client object</param>
      <param name="Message">Email message object</param>
      <param name="message">Mail message object</param>
      <requires description="Message" exception="T:System.ArgumentNullException" csharp="Message != null" vb="Message &lt;&gt; Nothing">Message != null</requires>
      <exception cref="T:System.ArgumentNullException">Message == null</exception>
      <requires description="smtpClient" exception="T:System.ArgumentNullException" csharp="smtpClient != null" vb="smtpClient &lt;&gt; Nothing">smtpClient != null</requires>
      <exception cref="T:System.ArgumentNullException">smtpClient == null</exception>
      <requires description="message" exception="T:System.ArgumentNullException" csharp="message != null" vb="message &lt;&gt; Nothing">message != null</requires>
      <exception cref="T:System.ArgumentNullException">message == null</exception>
    </member>
    <member name="P:Utilities.IO.Messaging.Default.SMTPSystem.MessageType">
      <summary>
            Message type accepts
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.Default.SMTPSystem.Name">
      <summary>
            Name of the system
            </summary>
    </member>
    <member name="T:Utilities.IO.Messaging.Interfaces.IFormatter">
      <summary>
            Formatter interface
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.Interfaces.IFormatter.Format``1(Utilities.IO.Messaging.Interfaces.IMessage,``0)">
      <summary>
            Formats the message
            </summary>
      <param name="Message">Message to format</param>
      <param name="Model">Model object used to format the message</param>
      <returns>The formatted message</returns>
    </member>
    <member name="P:Utilities.IO.Messaging.Interfaces.IFormatter.Name">
      <summary>
            Name of the formatter
            </summary>
    </member>
    <member name="T:Utilities.IO.Messaging.Manager">
      <summary>
            Messaging manager
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.Manager.ToString">
      <summary>
            String info for the manager
            </summary>
      <returns>The string info that the manager contains</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.Messaging.Manager.Formatters">
      <summary>
            Formatters
            </summary>
    </member>
    <member name="P:Utilities.IO.Messaging.Manager.MessagingSystems">
      <summary>
            Messaging systems
            </summary>
    </member>
    <member name="T:Utilities.IO.Messaging.Module.MessagingModule">
      <summary>
            Messaging module
            </summary>
    </member>
    <member name="M:Utilities.IO.Messaging.Module.MessagingModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.IO.Messaging.Module.MessagingModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.BaseClasses.SerializerBase`1">
      <summary>
            Serializer base class
            </summary>
      <typeparam name="T">Serialized data type</typeparam>
    </member>
    <member name="T:Utilities.IO.Serializers.Interfaces.ISerializer`1">
      <summary>
            Serializer interface
            </summary>
      <typeparam name="T">Object type returned</typeparam>
    </member>
    <member name="T:Utilities.IO.Serializers.Interfaces.ISerializer">
      <summary>
            Serializer interface
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Interfaces.ISerializer.ContentType">
      <summary>
            Content type associated with this serializer (MIME type)
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Interfaces.ISerializer.FileType">
      <summary>
            File ending associated with the serializer
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Interfaces.ISerializer.Name">
      <summary>
            Name of the serializer
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Interfaces.ISerializer.ReturnType">
      <summary>
            Return type for the serialized data
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Interfaces.ISerializer`1.Deserialize(System.Type,`0)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The deserialized data</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.Interfaces.ISerializer`1.Serialize(System.Type,System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to serialize</param>
      <returns>The serialized data</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.BaseClasses.SerializerBase`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.BaseClasses.SerializerBase`1.Deserialize(System.Type,`0)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The deserialized data</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.BaseClasses.SerializerBase`1.Serialize(System.Type,System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to serialize</param>
      <returns>The serialized data</returns>
    </member>
    <member name="P:Utilities.IO.Serializers.BaseClasses.SerializerBase`1.ContentType">
      <summary>
            Content type (MIME type)
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.BaseClasses.SerializerBase`1.FileType">
      <summary>
            Common file type (extension)
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.BaseClasses.SerializerBase`1.Name">
      <summary>
            Name of the serializer
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.BaseClasses.SerializerBase`1.ReturnType">
      <summary>
            Return type
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.Default.BinarySerializer">
      <summary>
            Binary serializer
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.BinarySerializer.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.BinarySerializer.Deserialize(System.Type,System.Byte[])">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The deserialized data</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.BinarySerializer.Serialize(System.Type,System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to serialize</param>
      <returns>The serialized data</returns>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.BinarySerializer.ContentType">
      <summary>
            Content type (MIME type)
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.BinarySerializer.FileType">
      <summary>
            File type
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.BinarySerializer.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.Default.JSONSerializer">
      <summary>
            JSON serializer
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.JSONSerializer.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="F:Utilities.IO.Serializers.Default.JSONSerializer.JsonPRegex">
      <summary>
            JSONP regex filter
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.JSONSerializer.Deserialize(System.Type,System.String)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The deserialized data</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.JSONSerializer.Serialize(System.Type,System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to serialize</param>
      <returns>The serialized data</returns>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.JSONSerializer.ContentType">
      <summary>
            Content type (MIME type)
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.JSONSerializer.FileType">
      <summary>
            File type
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.JSONSerializer.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.Default.SOAPSerializer">
      <summary>
            SOAP serializer
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.SOAPSerializer.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.SOAPSerializer.Deserialize(System.Type,System.String)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The deserialized data</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.SOAPSerializer.Serialize(System.Type,System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to serialize</param>
      <returns>The serialized data</returns>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.SOAPSerializer.ContentType">
      <summary>
            Content type (MIME type)
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.SOAPSerializer.FileType">
      <summary>
            File type
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.SOAPSerializer.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.Default.XMLSerializer">
      <summary>
            XML serializer
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.XMLSerializer.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.XMLSerializer.Deserialize(System.Type,System.String)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The deserialized data</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.Default.XMLSerializer.Serialize(System.Type,System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to serialize</param>
      <returns>The serialized data</returns>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.XMLSerializer.ContentType">
      <summary>
            Content type (MIME type)
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.XMLSerializer.FileType">
      <summary>
            File type
            </summary>
    </member>
    <member name="P:Utilities.IO.Serializers.Default.XMLSerializer.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.Manager">
      <summary>
            Serialization manager class
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Manager.Deserialize``2(``0,System.String)">
      <summary>
            Deserializes the data to an object
            </summary>
      <typeparam name="T">Data type</typeparam>
      <typeparam name="R">Return object type</typeparam>
      <param name="Data">Data to deserialize</param>
      <param name="ContentType">Content type (MIME type)</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.Manager.Deserialize``1(``0,System.Type,System.String)">
      <summary>
            Deserializes the data to an object
            </summary>
      <typeparam name="T">Type of the data</typeparam>
      <param name="Data">Data to deserialize</param>
      <param name="ObjectType">Object type requested</param>
      <param name="ContentType">Content type (MIME type)</param>
      <returns>The deserialized object</returns>
      <requires description="ObjectType" exception="T:System.ArgumentNullException" csharp="ObjectType != (System.Type)null" vb="ObjectType &lt;&gt; ((System.Type)Nothing) ">ObjectType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!ObjectType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.IO.Serializers.Manager.Serialize``2(``0,System.String)">
      <summary>
            Serializes the object based on the content type specified
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to serialize</param>
      <param name="ContentType">Content type (MIME type)</param>
      <typeparam name="R">Return type</typeparam>
      <returns>The serialized object as a string</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.Manager.Serialize``1(System.Object,System.Type,System.String)">
      <summary>
            Serializes the object based on the content type specified
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Object">Object to serialize</param>
      <param name="ContentType">Content type (MIME type)</param>
      <typeparam name="T">Return type</typeparam>
      <returns>The serialized object as a string</returns>
      <requires description="ObjectType" exception="T:System.ArgumentNullException" csharp="ObjectType != (System.Type)null" vb="ObjectType &lt;&gt; ((System.Type)Nothing) ">ObjectType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!ObjectType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.IO.Serializers.Manager.ToString">
      <summary>
            Outputs information about the serializers the system is using
            </summary>
      <returns>String version of the object</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IO.Serializers.Manager.Serializers">
      <summary>
            Serializers
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.Module.SerializationModule">
      <summary>
            Serialization module
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.Module.SerializationModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.IO.Serializers.Module.SerializationModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.Media.ColorMatrix">
      <summary>
            Helper class for setting up and applying a color matrix
            </summary>
    </member>
    <member name="M:Utilities.Media.ColorMatrix.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Media.ColorMatrix.Apply(System.Drawing.Bitmap)">
      <summary>
            Applies the color matrix
            </summary>
      <param name="OriginalImage">Image sent in</param>
      <returns>An image with the color matrix applied</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="OriginalImage != null" vb="OriginalImage &lt;&gt; Nothing">OriginalImage != null</requires>
      <exception cref="T:System.ArgumentNullException">OriginalImage == null</exception>
    </member>
    <member name="P:Utilities.Media.ColorMatrix.Matrix">
      <summary>
            Matrix containing the values of the ColorMatrix
            </summary>
    </member>
    <member name="T:Utilities.Media.BitmapExtensions">
      <summary>
            Bitmap extensions
            </summary>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.AddNoise(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            adds noise to the image
            </summary>
      <param name="OriginalImage">Image to add noise to</param>
      <param name="FileName">Location to save the Bitmap to (optional)</param>
      <param name="Amount">Amount of noise to add (defaults to 10)</param>
      <returns>New Bitmap object with the noise added</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1().Amount = Amount;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1().Amount = Amount&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1().Amount = Amount;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1().Amount = Amount);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.AdjustBrightness(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Adjusts the brightness
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <param name="Value" />
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.AdjustContrast(System.Drawing.Bitmap,System.Single,System.String)">
      <summary>
            Adjusts the Contrast
            </summary>
      <param name="OriginalImage">Image to change</param>
      <param name="Value">Used to set the contrast (-100 to 100)</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4().Value = Value;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4().Value = Value&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4().Value = Value;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4().Value = Value);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.AdjustGamma(System.Drawing.Bitmap,System.Single,System.String)">
      <summary>
            Adjusts the Gamma
            </summary>
      <param name="OriginalImage">Image to change</param>
      <param name="Value">Used to build the gamma ramp (usually .2 to 5)</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass8().Value = Value;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass8().Value = Value&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass8().Value = Value;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass8().Value = Value);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.And(System.Drawing.Bitmap,System.Drawing.Bitmap,System.String)">
      <summary>
            ands two images
            </summary>
      <param name="Image1">Image to manipulate</param>
      <param name="Image2">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image1" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClassb local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClassb();&#xD;&#xA;    }&#xD;&#xA;    return Image1 != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClassb local_3 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClassb();&#xD;&#xA;    return Image1 &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClassb local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClassb();
    }
    return Image1 != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClassb local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClassb();
    }
    return (Image1 != null); })()</exception>
      <requires description="Image2" exception="T:System.ArgumentNullException" csharp="Image2 != null" vb="Image2 &lt;&gt; Nothing">Image2 != null</requires>
      <exception cref="T:System.ArgumentNullException">Image2 == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.BlackAndWhite(System.Drawing.Bitmap,System.String)">
      <summary>
            Converts an Bitmap to black and white
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object of the black and white image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.BlueFilter(System.Drawing.Bitmap,System.String)">
      <summary>
            Gets the blue filter for an image
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.BoxBlur(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a box blur
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="Size">Size of the aperture</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.BumpMap(System.Drawing.Bitmap,Utilities.Media.Direction,System.Boolean)">
      <summary>
            Creates the bump map
            </summary>
      <param name="Direction">Direction of the bump map</param>
      <param name="Image">Image to create a bump map from</param>
      <param name="Invert">Inverts the direction of the bump map</param>
      <returns>The resulting bump map</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Colorize(System.Drawing.Bitmap,System.Drawing.Color[],System.String)">
      <summary>
            Colorizes a black and white image
            </summary>
      <param name="OriginalImage">Black and white image</param>
      <param name="Colors">Color array to use for the image</param>
      <param name="FileName">File to save to</param>
      <returns>The colorized image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClasse().Colors = Colors;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClasse().Colors = Colors&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClasse().Colors = Colors;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClasse().Colors = Colors);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Crop(System.Drawing.Bitmap,System.Int32,System.Int32,Utilities.Media.Align,Utilities.Media.Align,System.String)">
      <summary>
            Crops an image
            </summary>
      <param name="ImageUsing">Image to crop</param>
      <param name="Width">Width of the cropped image</param>
      <param name="Height">Height of the cropped image</param>
      <param name="VAlignment">The verticle alignment of the cropping (top or bottom)</param>
      <param name="HAlignment">The horizontal alignment of the cropping (left or right)</param>
      <param name="FileName">File to save to</param>
      <returns>A Bitmap object of the cropped image</returns>
      <requires description="ImageUsing" exception="T:System.ArgumentNullException" csharp="ImageUsing != null" vb="ImageUsing &lt;&gt; Nothing">ImageUsing != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageUsing == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Dilate(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does dilation
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="Size">Size of the aperture</param>
      <param name="FileName">File to save to</param>
      <returns>A Bitmap object of the resulting image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass11 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass11();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass11 local_2 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass11();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass11 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass11();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass11 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass11();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.DrawRoundedRectangle(System.Drawing.Bitmap,System.Drawing.Color,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
      <summary>
            Draws a rounded rectangle on a bitmap
            </summary>
      <param name="Image">Image to draw on</param>
      <param name="BoxColor">The color that the box should be</param>
      <param name="XPosition">The upper right corner's x position</param>
      <param name="YPosition">The upper right corner's y position</param>
      <param name="Height">Height of the box</param>
      <param name="Width">Width of the box</param>
      <param name="CornerRadius">Radius of the corners</param>
      <param name="FileName">File to save to</param>
      <returns>The bitmap with the rounded box on it</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
      <requires description="BoxColor" exception="T:System.ArgumentNullException" csharp="true" vb="True">true</requires>
      <exception cref="T:System.ArgumentNullException">!true</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.DrawText(System.Drawing.Bitmap,System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF,System.String)">
      <summary>
            Draws text on an Bitmap within the bounding box specified.
            </summary>
      <param name="Image">Image to draw on</param>
      <param name="TextToDraw">The text to draw on the image</param>
      <param name="FontToUse">Font in which to draw the text</param>
      <param name="BrushUsing">Defines the brush using</param>
      <param name="BoxToDrawWithin">Rectangle to draw the Bitmap within</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object with the text drawn on it</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
      <requires description="FontToUse" exception="T:System.ArgumentNullException" csharp="FontToUse != null" vb="FontToUse &lt;&gt; Nothing">FontToUse != null</requires>
      <exception cref="T:System.ArgumentNullException">FontToUse == null</exception>
      <requires description="BrushUsing" exception="T:System.ArgumentNullException" csharp="BrushUsing != null" vb="BrushUsing &lt;&gt; Nothing">BrushUsing != null</requires>
      <exception cref="T:System.ArgumentNullException">BrushUsing == null</exception>
      <requires description="BoxToDrawWithin" exception="T:System.ArgumentNullException" csharp="true" vb="True">true</requires>
      <exception cref="T:System.ArgumentNullException">!true</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.EdgeDetection(System.Drawing.Bitmap,System.Single,System.Drawing.Color,System.String)">
      <summary>
            Does basic edge detection on an image
            </summary>
      <param name="OriginalImage">Image to do edge detection on</param>
      <param name="Threshold">Decides what is considered an edge</param>
      <param name="EdgeColor">Color of the edge</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap which has the edges drawn on it</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass14 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass14();&#xD;&#xA;        local_2.Threshold = Threshold;&#xD;&#xA;        local_2.EdgeColor = EdgeColor;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass14 local_2 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass14();&#xD;&#xA;    local_2.Threshold = Threshold&#xD;&#xA;    local_2.EdgeColor = EdgeColor&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass14 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass14();
        local_2.Threshold = Threshold;
        local_2.EdgeColor = EdgeColor;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass14 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass14();
        (local_2.Threshold = Threshold);
        (local_2.EdgeColor = EdgeColor);
    }
    return (OriginalImage != null); })()</exception>
      <requires description="EdgeColor" exception="T:System.ArgumentNullException" csharp="true" vb="True">true</requires>
      <exception cref="T:System.ArgumentNullException">!true</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Emboss(System.Drawing.Bitmap,System.String)">
      <summary>
            Emboss function
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Equalize(System.Drawing.Bitmap,System.String)">
      <summary>
            Uses an RGB histogram to equalize the image
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>The resulting bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass17 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass17();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass17 local_3 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass17();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass17 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass17();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass17 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass17();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Flip(System.Drawing.Bitmap,System.Boolean,System.Boolean,System.String)">
      <summary>
            Flips an image
            </summary>
      <param name="Image">Image to flip</param>
      <param name="FlipX">Flips an Bitmap along the X axis</param>
      <param name="FlipY">Flips an Bitmap along the Y axis</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap which is flipped</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.GaussianBlur(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a gaussian blur
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <param name="Size">Size of the aperture</param>
      <returns>The resulting bitmap</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.GetHTMLPalette(System.Drawing.Bitmap)">
      <summary>
            Gets a palette listing in HTML string format
            </summary>
      <param name="OriginalImage">Image to get the palette of</param>
      <returns>A list containing HTML color values (ex: #041845)</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Func&lt;System.Drawing.Color, bool&gt; local_3 = (System.Func&lt;System.Drawing.Color, bool&gt;)null;&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1b local_4 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1b();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    System.Func&lt;System.Drawing.Color, bool&gt; local_3 = ((System.Func(Of System.Drawing.Color, Boolean))Nothing);&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1b local_4 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1b();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        System.Func&lt;System.Drawing.Color, bool&gt; local_3 = (System.Func&lt;System.Drawing.Color, bool&gt;)null;
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1b local_4 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1b();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        System.Func&lt;System.Drawing.Color, bool&gt; local_3 = (System.Func&lt;System.Drawing.Color, bool&gt;)null;
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1b local_4 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1b();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.GreenFilter(System.Drawing.Bitmap,System.String)">
      <summary>
            Gets the Green filter for an image
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.GetImageFormat(System.String)">
      <summary>
            Returns the Bitmap format this file is using
            </summary>
      <param name="FileName" />
      <returns />
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.GetPixelSize(System.Drawing.Imaging.BitmapData)">
      <summary>
            Gets the pixel size (in bytes)
            </summary>
      <param name="Data">Bitmap data</param>
      <returns>The pixel size (in bytes)</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="Data != null" vb="Data &lt;&gt; Nothing">Data != null</requires>
      <exception cref="T:System.ArgumentNullException">Data == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.GetPixel(System.Drawing.Imaging.BitmapData,System.Int32,System.Int32,System.Int32)">
      <summary>
            Gets a pixel from an x,y coordinate
            </summary>
      <param name="Data">Bitmap data</param>
      <param name="x">X coord</param>
      <param name="y">Y coord</param>
      <param name="PixelSizeInBytes">Pixel size in bytes</param>
      <returns>The pixel at the x,y coords</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="Data != null" vb="Data &lt;&gt; Nothing">Data != null</requires>
      <exception cref="T:System.ArgumentNullException">Data == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Jitter(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Causes a "Jitter" effect
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="MaxJitter">Maximum number of pixels the item can move</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1e().MaxJitter = MaxJitter;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1e().MaxJitter = MaxJitter&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1e().MaxJitter = MaxJitter;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass1e().MaxJitter = MaxJitter);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.KuwaharaBlur(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a kuwahara blur
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="Size">Size of the aperture</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass21 local_6 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass21();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass21 local_6 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass21();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass21 local_6 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass21();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass21 local_6 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass21();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.LaplaceEdgeDetection(System.Drawing.Bitmap,System.String)">
      <summary>
            Laplace edge detection function
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.LockImage(System.Drawing.Bitmap)">
      <summary>
            Locks an image
            </summary>
      <param name="Image">Image to lock</param>
      <returns>The bitmap data for the image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.MedianFilter(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a median filter
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <param name="Size">Size of the aperture</param>
      <returns>A bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass24 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass24();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass24 local_2 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass24();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass24 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass24();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass24 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass24();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.MotionDetection(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Int32,System.Drawing.Color)">
      <summary>
            Runs a simplistic motion detection algorithm
            </summary>
      <param name="NewImage">The "new" frame</param>
      <param name="OldImage">The "old" frame</param>
      <param name="Threshold">The threshold used to detect changes in the image</param>
      <param name="DetectionColor">Color to display changes in the images as</param>
      <returns>
            A bitmap indicating where changes between frames have occurred overlayed on top of the
            new image.
            </returns>
      <requires description="NewImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass28 local_1 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass28();&#xD;&#xA;        local_1.Threshold = Threshold;&#xD;&#xA;        local_1.DetectionColor = DetectionColor;&#xD;&#xA;    }&#xD;&#xA;    return NewImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass28 local_1 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass28();&#xD;&#xA;    local_1.Threshold = Threshold&#xD;&#xA;    local_1.DetectionColor = DetectionColor&#xD;&#xA;    return NewImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass28 local_1 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass28();
        local_1.Threshold = Threshold;
        local_1.DetectionColor = DetectionColor;
    }
    return NewImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass28 local_1 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass28();
        (local_1.Threshold = Threshold);
        (local_1.DetectionColor = DetectionColor);
    }
    return (NewImage != null); })()</exception>
      <requires description="OldImage" exception="T:System.ArgumentNullException" csharp="OldImage != null" vb="OldImage &lt;&gt; Nothing">OldImage != null</requires>
      <exception cref="T:System.ArgumentNullException">OldImage == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Negative(System.Drawing.Bitmap,System.String)">
      <summary>
            gets the negative of the image
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass2f local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass2f();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass2f local_3 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass2f();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass2f local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass2f();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass2f local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass2f();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.NormalMap(System.Drawing.Bitmap,System.Boolean,System.Boolean)">
      <summary>
            Creates the normal map
            </summary>
      <param name="ImageUsing">Image to create the normal map from</param>
      <param name="InvertX">Invert the X direction</param>
      <param name="InvertY">Invert the Y direction</param>
      <returns>Returns the resulting normal map</returns>
      <requires description="ImageUsing" exception="T:System.ArgumentNullException" csharp="ImageUsing != null" vb="ImageUsing &lt;&gt; Nothing">ImageUsing != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageUsing == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Or(System.Drawing.Bitmap,System.Drawing.Bitmap,System.String)">
      <summary>
            Ors two images
            </summary>
      <param name="Image1">Image to manipulate</param>
      <param name="Image2">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image1" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass35 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass35();&#xD;&#xA;    }&#xD;&#xA;    return Image1 != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass35 local_3 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass35();&#xD;&#xA;    return Image1 &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass35 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass35();
    }
    return Image1 != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass35 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass35();
    }
    return (Image1 != null); })()</exception>
      <requires description="Image2" exception="T:System.ArgumentNullException" csharp="Image2 != null" vb="Image2 &lt;&gt; Nothing">Image2 != null</requires>
      <exception cref="T:System.ArgumentNullException">Image2 == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.OilPainting(System.Drawing.Bitmap,System.Int32,System.Int32)">
      <summary>
            Slow but interesting function that applies an oil painting effect
            </summary>
      <param name="Image">Image to create the oil painting effect from</param>
      <param name="Seed">Randomization seed</param>
      <param name="NumberOfPoints">Number of points for the painting</param>
      <returns>The resulting bitmap</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass38 local_1 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass38();&#xD;&#xA;    }&#xD;&#xA;    return Image != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass38 local_1 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass38();&#xD;&#xA;    return Image &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass38 local_1 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass38();
    }
    return Image != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass38 local_1 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass38();
    }
    return (Image != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Pixelate(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Pixelates an image
            </summary>
      <param name="OriginalImage">Image to pixelate</param>
      <param name="PixelSize">Size of the "pixels" in pixels</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass3b local_4 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass3b();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass3b local_4 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass3b();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass3b local_4 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass3b();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass3b local_4 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass3b();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.RedFilter(System.Drawing.Bitmap,System.String)">
      <summary>
            Gets the Red filter for an image
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Resize(System.Drawing.Bitmap,System.Int32,Utilities.Media.Quality,System.String)">
      <summary>
            Resizes an Bitmap to a certain height
            </summary>
      <param name="Image">Image to resize</param>
      <param name="MaxSide">Max height/width for the final image</param>
      <param name="Quality">Quality of the resizing</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object of the resized image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Resize(System.Drawing.Bitmap,System.Int32,System.Int32,Utilities.Media.Quality,System.String)">
      <summary>
            Resizes an Bitmap to a certain height
            </summary>
      <param name="Image">Image to resize</param>
      <param name="Width">New width for the final image</param>
      <param name="Height">New height for the final image</param>
      <param name="Quality">Quality of the resizing</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object of the resized image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Rotate(System.Drawing.Bitmap,System.Single,System.String)">
      <summary>
            Rotates an image
            </summary>
      <param name="Image">Image to rotate</param>
      <param name="DegreesToRotate">Degrees to rotate the image</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object containing the rotated image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.SepiaTone(System.Drawing.Bitmap,System.String)">
      <summary>
            Converts an Bitmap to sepia tone
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object of the sepia tone image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.SetPixel(System.Drawing.Imaging.BitmapData,System.Int32,System.Int32,System.Drawing.Color,System.Int32)">
      <summary>
            Sets a pixel at the x,y coords
            </summary>
      <param name="Data">Bitmap data</param>
      <param name="x">X coord</param>
      <param name="y">Y coord</param>
      <param name="PixelColor">Pixel color information</param>
      <param name="PixelSizeInBytes">Pixel size in bytes</param>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="Data != null" vb="Data &lt;&gt; Nothing">Data != null</requires>
      <exception cref="T:System.ArgumentNullException">Data == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Sharpen(System.Drawing.Bitmap,System.String)">
      <summary>
            Sharpens an image
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.SharpenLess(System.Drawing.Bitmap,System.String)">
      <summary>
            Sharpens an image
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.SinWave(System.Drawing.Bitmap,System.Single,System.Single,System.Boolean,System.Boolean,System.String)">
      <summary>
            Does a "wave" effect on the image
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="Amplitude">Amplitude of the sine wave</param>
      <param name="Frequency">Frequency of the sine wave</param>
      <param name="XDirection">Determines if this should be done in the X direction</param>
      <param name="YDirection">Determines if this should be done in the Y direction</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap which has been modified</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass40 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass40();&#xD;&#xA;        local_2.Amplitude = Amplitude;&#xD;&#xA;        local_2.Frequency = Frequency;&#xD;&#xA;        local_2.XDirection = XDirection;&#xD;&#xA;        local_2.YDirection = YDirection;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass40 local_2 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass40();&#xD;&#xA;    local_2.Amplitude = Amplitude&#xD;&#xA;    local_2.Frequency = Frequency&#xD;&#xA;    local_2.XDirection = XDirection&#xD;&#xA;    local_2.YDirection = YDirection&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass40 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass40();
        local_2.Amplitude = Amplitude;
        local_2.Frequency = Frequency;
        local_2.XDirection = XDirection;
        local_2.YDirection = YDirection;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass40 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass40();
        (local_2.Amplitude = Amplitude);
        (local_2.Frequency = Frequency);
        (local_2.XDirection = XDirection);
        (local_2.YDirection = YDirection);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.SobelEdgeDetection(System.Drawing.Bitmap,System.String)">
      <summary>
            Sobel edge detection function
            </summary>
      <param name="Input">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.SobelEmboss(System.Drawing.Bitmap,System.String)">
      <summary>
            Sobel emboss function
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.SNNBlur(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a SNN blur
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <param name="Size">Size of the aperture</param>
      <returns>The resulting bitmap</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass46 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass46();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass46 local_2 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass46();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass46 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass46();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass46 local_2 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass46();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.StretchContrast(System.Drawing.Bitmap,System.String)">
      <summary>
            Stretches the contrast
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass49 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass49();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass49 local_3 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass49();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass49 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass49();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass49 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass49();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Threshold(System.Drawing.Bitmap,System.Single,System.String)">
      <summary>
            Does threshold manipulation of the image
            </summary>
      <param name="OriginalImage">Image to transform</param>
      <param name="Threshold">
            Float defining the threshold at which to set the pixel to black vs white.
            </param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object containing the new image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4c().Threshold = Threshold;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4c().Threshold = Threshold&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4c().Threshold = Threshold;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4c().Threshold = Threshold);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.ToASCIIArt(System.Drawing.Bitmap)">
      <summary>
            Converts an Bitmap to ASCII art
            </summary>
      <param name="Input">The Bitmap you wish to convert</param>
      <returns>A string containing the art</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.ToBase64(System.Drawing.Image,System.Drawing.Imaging.ImageFormat)">
      <summary>
            Converts an Bitmap to a base64 string and returns it
            </summary>
      <param name="Image">Image to convert</param>
      <param name="DesiredFormat">Desired Bitmap format (defaults to Jpeg)</param>
      <returns>The Bitmap in base64 string format</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Turbulence(System.Drawing.Bitmap,System.Int32,System.Single,System.Int32,System.String)">
      <summary>
            Does turbulence manipulation of the image
            </summary>
      <param name="OriginalImage">Image to transform</param>
      <param name="Roughness">Roughness of the movement</param>
      <param name="Power">How strong the movement is</param>
      <param name="Seed">Random seed</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object containing the new image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4f().Power = Power;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4f().Power = Power&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4f().Power = Power;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass4f().Power = Power);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.UnlockImage(System.Drawing.Bitmap,System.Drawing.Imaging.BitmapData)">
      <summary>
            Unlocks the image's data
            </summary>
      <param name="Image">Image to unlock</param>
      <param name="ImageData">The Bitmap data</param>
      <returns>Returns the image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
      <requires description="ImageData" exception="T:System.ArgumentNullException" csharp="ImageData != null" vb="ImageData &lt;&gt; Nothing">ImageData != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageData == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Watermark(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Single,System.Int32,System.Int32,System.Drawing.Color,System.String)">
      <summary>
            Adds a watermark to an image
            </summary>
      <param name="Image">image to add the watermark to</param>
      <param name="WatermarkImage">Watermark image</param>
      <param name="Opacity">
            Opacity of the watermark (1.0 to 0.0 with 1 being completely visible and 0 being invisible)
            </param>
      <param name="X">X position in pixels for the watermark</param>
      <param name="Y">Y position in pixels for the watermark</param>
      <param name="KeyColor">
            Transparent color used in watermark image, set to null if not used
            </param>
      <param name="FileName">File to save to</param>
      <returns>The results in the form of a bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
      <requires description="WatermarkImage" exception="T:System.ArgumentNullException" csharp="WatermarkImage != null" vb="WatermarkImage &lt;&gt; Nothing">WatermarkImage != null</requires>
      <exception cref="T:System.ArgumentNullException">WatermarkImage == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.Xor(System.Drawing.Bitmap,System.Drawing.Bitmap,System.String)">
      <summary>
            Xors two images
            </summary>
      <param name="Image1">Image to manipulate</param>
      <param name="Image2">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image1" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass56 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass56();&#xD;&#xA;    }&#xD;&#xA;    return Image1 != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass56 local_3 = New Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass56();&#xD;&#xA;    return Image1 &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass56 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass56();
    }
    return Image1 != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass56 local_3 = new Utilities.Media.BitmapExtensions.&lt;&gt;c__DisplayClass56();
    }
    return (Image1 != null); })()</exception>
      <requires description="Image2" exception="T:System.ArgumentNullException" csharp="Image2 != null" vb="Image2 &lt;&gt; Nothing">Image2 != null</requires>
      <exception cref="T:System.ArgumentNullException">Image2 == null</exception>
    </member>
    <member name="F:Utilities.Media.BitmapExtensions._ASCIICharacters">
      <summary>
            Characters used for ASCII art
            </summary>
    </member>
    <member name="T:Utilities.Media.Align">
      <summary>
            Enum defining alignment
            </summary>
    </member>
    <member name="F:Utilities.Media.Align.Top">
      <summary>
            Top
            </summary>
    </member>
    <member name="F:Utilities.Media.Align.Bottom">
      <summary>
            Bottom
            </summary>
    </member>
    <member name="F:Utilities.Media.Align.Left">
      <summary>
            Left
            </summary>
    </member>
    <member name="F:Utilities.Media.Align.Right">
      <summary>
            Right
            </summary>
    </member>
    <member name="T:Utilities.Media.Direction">
      <summary>
            Direction
            </summary>
    </member>
    <member name="F:Utilities.Media.Direction.TopBottom">
      <summary>
            Top to bottom
            </summary>
    </member>
    <member name="F:Utilities.Media.Direction.LeftRight">
      <summary>
            Left to right
            </summary>
    </member>
    <member name="T:Utilities.Media.Quality">
      <summary>
            Enum defining quality
            </summary>
    </member>
    <member name="F:Utilities.Media.Quality.High">
      <summary>
            High
            </summary>
    </member>
    <member name="F:Utilities.Media.Quality.Low">
      <summary>
            Low
            </summary>
    </member>
    <member name="T:Utilities.Media.ScreenExtensions">
      <summary>
            Screen extensions
            </summary>
    </member>
    <member name="M:Utilities.Media.ScreenExtensions.TakeScreenShot(System.Windows.Forms.Screen,System.String)">
      <summary>
            Takes a screenshot of the screen as a whole (if multiple screens are attached, it takes
            an image containing them all)
            </summary>
      <param name="Screen">Screen to get the screenshot from</param>
      <param name="FileName">Name of the file to save the screenshot (optional)</param>
      <returns>Returns a bitmap containing the screen shot</returns>
      <requires description="Screen" exception="T:System.ArgumentNullException" csharp="Screen != null" vb="Screen &lt;&gt; Nothing">Screen != null</requires>
      <exception cref="T:System.ArgumentNullException">Screen == null</exception>
    </member>
    <member name="M:Utilities.Media.ScreenExtensions.TakeScreenShot(System.Collections.Generic.IEnumerable{System.Windows.Forms.Screen},System.String)">
      <summary>
            Takes a screenshot of the screen as a whole (if multiple screens are attached, it takes
            an image containing them all)
            </summary>
      <param name="Screens">Screens to get the screenshot from</param>
      <param name="FileName">Name of the file to save the screenshot (optional)</param>
      <returns>Returns a bitmap containing the screen shot</returns>
      <requires description="Screens" exception="T:System.ArgumentNullException" csharp="Screens != null" vb="Screens &lt;&gt; Nothing">Screens != null</requires>
      <exception cref="T:System.ArgumentNullException">Screens == null</exception>
    </member>
    <member name="T:Utilities.Media.Filter">
      <summary>
            Used when applying convolution filters to an image
            </summary>
    </member>
    <member name="M:Utilities.Media.Filter.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Width">Width</param>
      <param name="Height">Height</param>
    </member>
    <member name="M:Utilities.Media.Filter.ApplyFilter(System.Drawing.Bitmap)">
      <summary>
            Applies the filter to the input image
            </summary>
      <param name="Input">input image</param>
      <returns>Returns a separate image with the filter applied</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.Filter.&lt;&gt;c__DisplayClass1().&lt;&gt;4__this = this;&#xD;&#xA;    }&#xD;&#xA;    return Input != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.Filter.&lt;&gt;c__DisplayClass1().&lt;&gt;4__this = Me&#xD;&#xA;    return Input &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.Filter.&lt;&gt;c__DisplayClass1().&lt;&gt;4__this = this;
    }
    return Input != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.Filter.&lt;&gt;c__DisplayClass1().&lt;&gt;4__this = this);
    }
    return (Input != null); })()</exception>
    </member>
    <member name="P:Utilities.Media.Filter.Absolute">
      <summary>
            Determines if we should take the absolute value prior to clamping
            </summary>
    </member>
    <member name="P:Utilities.Media.Filter.Height">
      <summary>
            Height of the filter box
            </summary>
    </member>
    <member name="P:Utilities.Media.Filter.MyFilter">
      <summary>
            The actual filter array
            </summary>
    </member>
    <member name="P:Utilities.Media.Filter.Offset">
      <summary>
            Amount to add to the red, blue, and green values
            </summary>
    </member>
    <member name="P:Utilities.Media.Filter.Width">
      <summary>
            Width of the filter box
            </summary>
    </member>
    <member name="T:Utilities.Media.Procedural.CellularMap">
      <summary>
            A cellular map creator
            </summary>
    </member>
    <member name="M:Utilities.Media.Procedural.CellularMap.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Seed">Seed for random generation</param>
      <param name="Width">Width of the image</param>
      <param name="Height">Height of the image</param>
      <param name="NumberOfPoints">Number of cells</param>
    </member>
    <member name="M:Utilities.Media.Procedural.CellularMap.CalculateDistances">
      <summary>
            Calculate the distance between the points
            </summary>
    </member>
    <member name="M:Utilities.Media.Procedural.CellularMap.FindClosestPoint(System.Int32,System.Int32)">
      <summary>
            Finds the closest cell center
            </summary>
      <param name="x">x axis</param>
      <param name="y">y axis</param>
    </member>
    <member name="P:Utilities.Media.Procedural.CellularMap.ClosestPoint">
      <summary>
            List of closest cells
            </summary>
    </member>
    <member name="P:Utilities.Media.Procedural.CellularMap.Distances">
      <summary>
            Distances to the closest cell
            </summary>
    </member>
    <member name="P:Utilities.Media.Procedural.CellularMap.MaxDistance">
      <summary>
            Maximum distance to a point
            </summary>
    </member>
    <member name="P:Utilities.Media.Procedural.CellularMap.MinDistance">
      <summary>
            Minimum distance to a point
            </summary>
    </member>
    <member name="T:Utilities.Media.Procedural.Point">
      <summary>
            Individual point
            </summary>
    </member>
    <member name="M:Utilities.Media.Procedural.Point.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Media.Procedural.Point.X">
      <summary>
            X axis
            </summary>
    </member>
    <member name="P:Utilities.Media.Procedural.Point.Y">
      <summary>
            Y axis
            </summary>
    </member>
    <member name="T:Utilities.Media.Procedural.CellularTexture">
      <summary>
            Cellular texture helper
            </summary>
    </member>
    <member name="M:Utilities.Media.Procedural.CellularTexture.Generate(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Generates a cellular texture image
            </summary>
      <param name="Width">Width</param>
      <param name="Height">Height</param>
      <param name="NumberOfPoints">Number of points</param>
      <param name="Seed">Random seed</param>
      <returns>Returns an image of a cellular texture</returns>
    </member>
    <member name="T:Utilities.Media.Procedural.FaultFormation">
      <summary>
            Helper class for doing fault formations
            </summary>
    </member>
    <member name="M:Utilities.Media.Procedural.FaultFormation.Generate(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Generates a number of faults, returning an image
            </summary>
      <param name="Width">Width of the resulting image</param>
      <param name="Height">Height of the resulting image</param>
      <param name="NumberFaults">Number of faults</param>
      <param name="Seed">Random seed</param>
      <returns>An image from the resulting faults</returns>
    </member>
    <member name="T:Utilities.Media.Procedural.MidpointDisplacement">
      <summary>
            Helper class for generating cracks by midpoint displacement
            </summary>
    </member>
    <member name="M:Utilities.Media.Procedural.MidpointDisplacement.Generate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Generates an image that contains cracks
            </summary>
      <param name="Width">Image width</param>
      <param name="Height">Image height</param>
      <param name="NumberOfCracks">Number of cracks</param>
      <param name="Iterations">Iterations</param>
      <param name="MaxChange">Maximum height change of the cracks</param>
      <param name="MaxLength">Maximum length of the cracks</param>
      <param name="Seed">Random seed</param>
      <returns>An image containing "cracks"</returns>
      <requires description="Number of cracks should be greater than 0" exception="T:System.ArgumentException" csharp="NumberOfCracks &gt;= 0" vb="NumberOfCracks &gt;= 0">NumberOfCracks &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">NumberOfCracks &lt; 0</exception>
      <requires description="Width must be greater than or equal to 0" exception="T:System.ArgumentException" csharp="Width &gt;= 0" vb="Width &gt;= 0">Width &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">Width &lt; 0</exception>
      <requires description="Height must be greater than or equal to 0" exception="T:System.ArgumentException" csharp="Height &gt;= 0" vb="Height &gt;= 0">Height &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">Height &lt; 0</exception>
    </member>
    <member name="T:Utilities.Media.Procedural.PerlinNoise">
      <summary>
            Perlin noise helper class
            </summary>
    </member>
    <member name="M:Utilities.Media.Procedural.PerlinNoise.Generate(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
      <summary>
            Generates perlin noise
            </summary>
      <param name="Width">Width of the resulting image</param>
      <param name="Height">Height of the resulting image</param>
      <param name="MaxRGBValue">MaxRGBValue</param>
      <param name="MinRGBValue">MinRGBValue</param>
      <param name="Frequency">Frequency</param>
      <param name="Amplitude">Amplitude</param>
      <param name="Persistance">Persistance</param>
      <param name="Octaves">Octaves</param>
      <param name="Seed">Random seed</param>
      <returns>An image containing perlin noise</returns>
    </member>
    <member name="T:Utilities.Media.RGBHistogram">
      <summary>
            Class used to create an RGB Histogram
            </summary>
    </member>
    <member name="M:Utilities.Media.RGBHistogram.#ctor(System.Drawing.Bitmap)">
      <summary>
            Constructor
            </summary>
      <param name="Image">Image to load</param>
    </member>
    <member name="M:Utilities.Media.RGBHistogram.Equalize">
      <summary>
            Equalizes the histogram
            </summary>
    </member>
    <member name="M:Utilities.Media.RGBHistogram.LoadImage(System.Drawing.Bitmap)">
      <summary>
            Loads an image
            </summary>
      <param name="ImageUsing">Image to load</param>
      <requires description="ImageUsing" exception="T:System.ArgumentNullException" csharp="ImageUsing != null" vb="ImageUsing &lt;&gt; Nothing">ImageUsing != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageUsing == null</exception>
    </member>
    <member name="M:Utilities.Media.RGBHistogram.Normalize">
      <summary>
            Normalizes the histogram
            </summary>
    </member>
    <member name="P:Utilities.Media.RGBHistogram.B">
      <summary>
            Blue values
            </summary>
    </member>
    <member name="P:Utilities.Media.RGBHistogram.G">
      <summary>
            Green values
            </summary>
    </member>
    <member name="P:Utilities.Media.RGBHistogram.R">
      <summary>
            Red values
            </summary>
    </member>
    <member name="T:Utilities.ORM.BaseClasses.MappingBaseClass`2">
      <summary>
            Mapping base class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DatabaseType">Database type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IMapping">
      <summary>
            Mapping interface
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.SetDeleteCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default delete command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.SetInsertCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default insert command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.SetSelectAllCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default select all command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.SetSelectAnyCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default select any command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the mapping
            </summary>
      <param name="Source">Source info</param>
      <param name="QueryProvider">Query provider</param>
      <param name="MappingProvider">Mapping provider</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.SetUpdateCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default update command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.DatabaseConfigType">
      <summary>
            Database config type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.DeleteCommand">
      <summary>
            Delete command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.DeleteCommandType">
      <summary>
            Delete command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.IDProperties">
      <summary>
            ID properties
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.InsertCommand">
      <summary>
            Insert command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.InsertCommandType">
      <summary>
            Insert command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.ObjectType">
      <summary>
            The object type associated with the mapping
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.Order">
      <summary>
            Order that the mappings are initialized
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.Prefix">
      <summary>
            Prefix used for defining properties/table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.Properties">
      <summary>
            Properties list
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.SelectAllCommand">
      <summary>
            Select all command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.SelectAllCommandType">
      <summary>
            Select all command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.SelectAnyCommand">
      <summary>
            Select any command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.SelectAnyCommandType">
      <summary>
            Select any command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.Suffix">
      <summary>
            Suffix used for defining properties/table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.TableName">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.UpdateCommand">
      <summary>
            Update command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IMapping.UpdateCommandType">
      <summary>
            Update command type
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IMapping`1">
      <summary>
            Class mapping interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping`1.ID``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Declares a property as an ID
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the property</param>
      <returns>the ID object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping`1.ManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            Many to many mapping
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the many to many property</param>
      <returns>The many to many object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping`1.ManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{``0}}})">
      <summary>
            Many to many mapping
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the many to many property</param>
      <returns>The many to many object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping`1.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the property</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping`1.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            IEnumerable many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointint to the property</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping`1.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{``0}}})">
      <summary>
            IEnumerable many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointint to the property</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping`1.Map``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Sets a property as a map type
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the property</param>
      <returns>the map object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IMapping`1.Reference``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Sets a property as a reference type
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the property</param>
      <returns>the reference object</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.#ctor(System.String,System.String,System.String,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="TableName">Table name</param>
      <param name="Suffix">Suffix used to define names of properties/table name</param>
      <param name="Prefix">Prefix used to define names of properties/table name</param>
      <param name="Order">
            The order in which the mappings are initialized (lower items are initialized prior to
            higher number items)
            </param>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.op_Inequality(Utilities.ORM.BaseClasses.MappingBaseClass{`0,`1},Utilities.ORM.BaseClasses.MappingBaseClass{`0,`1})">
      <summary>
            Determines if the two items are not equal
            </summary>
      <param name="Item1">Item 1</param>
      <param name="Item2">Item 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.op_Equality(Utilities.ORM.BaseClasses.MappingBaseClass{`0,`1},Utilities.ORM.BaseClasses.MappingBaseClass{`0,`1})">
      <summary>
            Determines if the two items are equal
            </summary>
      <param name="Item1">Item 1</param>
      <param name="Item2">Item 2</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.Equals(System.Object)">
      <summary>
            determines if the mappings are equal
            </summary>
      <param name="obj" />
      <returns />
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.GetHashCode">
      <summary>
            Gets the mapping's hash code
            </summary>
      <returns>Hash code for the mapping</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.ID``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates an ID object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>ID object</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.ManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            Creates a many to many object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to many object</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.ManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{``0}}})">
      <summary>
            Creates a many to many object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to many object</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates a many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            Creates a many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{``0}}})">
      <summary>
            Creates a many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.Map``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates a map object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The map object</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.Reference``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates a reference object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>A reference object</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.SetDeleteCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default delete command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.SetInsertCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default insert command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.SetSelectAllCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default select all command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.SetSelectAnyCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default select any command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the mapping
            </summary>
      <param name="Source">Source info</param>
      <param name="QueryProvider">Query provider</param>
      <param name="MappingProvider">Mapping provider</param>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.SetUpdateCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the default update command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.BaseClasses.MappingBaseClass`2.ToString">
      <summary>
            Converts the mapping to a string
            </summary>
      <returns>The table name</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.DatabaseConfigType">
      <summary>
            Database config type
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.DeleteCommand">
      <summary>
            Delete command
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.DeleteCommandType">
      <summary>
            Delete command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.IDProperties">
      <summary>
            ID Properties
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.InsertCommand">
      <summary>
            Insert command
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.InsertCommandType">
      <summary>
            Insert command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.ObjectType">
      <summary>
            Object type
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.Order">
      <summary>
            The order in which the mappings are initialized (lower items are initialized prior to
            higher number items)
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.Prefix">
      <summary>
            Prefix used to define names of properties/table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.Properties">
      <summary>
            List of properties
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.SelectAllCommand">
      <summary>
            Select all command
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.SelectAllCommandType">
      <summary>
            Select all command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.SelectAnyCommand">
      <summary>
            Select any command
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.SelectAnyCommandType">
      <summary>
            Select any command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.Suffix">
      <summary>
            Suffix used to define names of properties/table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.TableName">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.UpdateCommand">
      <summary>
            Update command
            </summary>
    </member>
    <member name="P:Utilities.ORM.BaseClasses.MappingBaseClass`2.UpdateCommandType">
      <summary>
            Update command type
            </summary>
    </member>
    <member name="T:Utilities.ORM.ObjectBaseClass`2">
      <summary>
            Object base class helper. This is not required but automatically sets up basic functions and
            properties to simplify things a bit.
            </summary>
      <typeparam name="IDType">ID type</typeparam>
      <typeparam name="ObjectType">Object type (must be the child object type)</typeparam>
    </member>
    <member name="T:Utilities.ORM.Interfaces.IObject`1">
      <summary>
            Object interface
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IObject`1.Active">
      <summary>
            Is this item active?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IObject`1.DateCreated">
      <summary>
            Date created
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IObject`1.DateModified">
      <summary>
            Date last modified
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IObject`1.ID">
      <summary>
            ID
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Any(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Loads the item based on the ID
            </summary>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>The specified item</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.All(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Paged(System.Int32,System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (0 based)</param>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.PageCount(System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Gets the page count based on page size
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Save(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Saves a list of objects
            </summary>
      <param name="Objects">List of objects</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Delete">
      <summary>
            Deletes the item
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Save">
      <summary>
            Saves the item (if it already exists, it updates the item. Otherwise it inserts the item)
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.SetupObject">
      <summary>
            Sets up the object for saving purposes
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.op_Inequality(Utilities.ORM.ObjectBaseClass{`0,`1},Utilities.ORM.ObjectBaseClass{`0,`1})">
      <summary>
            != operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>returns true if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.op_LessThan(Utilities.ORM.ObjectBaseClass{`0,`1},Utilities.ORM.ObjectBaseClass{`0,`1})">
      <summary>
            The &lt; operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>True if the first item is less than the second, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.op_Equality(Utilities.ORM.ObjectBaseClass{`0,`1},Utilities.ORM.ObjectBaseClass{`0,`1})">
      <summary>
            The == operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>true if the first and second item are the same, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.op_GreaterThan(Utilities.ORM.ObjectBaseClass{`0,`1},Utilities.ORM.ObjectBaseClass{`0,`1})">
      <summary>
            The &gt; operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>True if the first item is greater than the second, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Equals(System.Object)">
      <summary>
            Determines if two items are equal
            </summary>
      <param name="obj">The object to compare this to</param>
      <returns>true if they are the same, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.GetHashCode">
      <summary>
            Returns the hash of this item
            </summary>
      <returns>the int hash of the item</returns>
    </member>
    <member name="F:Utilities.ORM.ObjectBaseClass`2.Loading">
      <summary>
            Called prior to an object is loading
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnLoading(System.Object,Utilities.DataTypes.EventArgs.LoadingEventArgs)">
      <summary>
            Called when the item is Loading
            </summary>
      <param name="e">LoadingEventArgs item</param>
      <param name="sender">Sender item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnDeleted(Utilities.DataTypes.EventArgs.DeletedEventArgs)">
      <summary>
            Called when the item is Deleted
            </summary>
      <param name="e">DeletedEventArgs item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnDeleting(Utilities.DataTypes.EventArgs.DeletingEventArgs)">
      <summary>
            Called when the item is Deleting
            </summary>
      <param name="e">DeletingEventArgs item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnLoaded(Utilities.DataTypes.EventArgs.LoadedEventArgs)">
      <summary>
            Called when the item is Loaded
            </summary>
      <param name="e">LoadedEventArgs item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnLoading(Utilities.DataTypes.EventArgs.LoadingEventArgs)">
      <summary>
            Called when the item is Loading
            </summary>
      <param name="e">LoadingEventArgs item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnSaved(Utilities.DataTypes.EventArgs.SavedEventArgs)">
      <summary>
            Called when the item is Saved
            </summary>
      <param name="e">SavedEventArgs item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnSaving(Utilities.DataTypes.EventArgs.SavingEventArgs)">
      <summary>
            Called when the item is Saving
            </summary>
      <param name="e">SavingEventArgs item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.CompareTo(System.Object)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.CompareTo(`0)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="other">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.Active">
      <summary>
            Is the object active?
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.DateCreated">
      <summary>
            Date object was created
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.DateModified">
      <summary>
            Date last modified
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.ID">
      <summary>
            ID for the object
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.Deleted">
      <summary>
            Called when the object is deleted
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.Deleting">
      <summary>
            Called prior to an object is deleting
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.Loaded">
      <summary>
            Called prior to an object being loaded
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.Saved">
      <summary>
            Called when the object is saved
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.Saving">
      <summary>
            Called prior to an object is saving
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Aspect.Interfaces.IORMObject">
      <summary>
            ORM object interface
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Aspect.Interfaces.IORMObject.Session0">
      <summary>
            ORM session that this item came from (used for lazy loading)
            </summary>
    </member>
    <member name="T:Utilities.ORM.Aspect.ORMAspect">
      <summary>
            ORM Aspect (used internally)
            </summary>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.Setup(System.Object)">
      <summary>
            Sets up the aspect
            </summary>
      <param name="Object">Object to set up</param>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupDefaultConstructor(System.Type)">
      <summary>
            Sets up the default constructor
            </summary>
      <param name="BaseType">Base type</param>
      <returns>The code used</returns>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupEndMethod(System.Reflection.MethodInfo,System.Type,System.String)">
      <summary>
            Sets up the end of a method
            </summary>
      <param name="Method">Method information</param>
      <param name="BaseType">Base type</param>
      <param name="ReturnValueName">Return value name</param>
      <returns>The code used</returns>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupExceptionMethod(System.Reflection.MethodInfo,System.Type)">
      <summary>
            Sets up exception method
            </summary>
      <param name="Method">Method information</param>
      <param name="BaseType">Base type</param>
      <returns>The code used</returns>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupInterfaces(System.Type)">
      <summary>
            Sets up the interfaces used
            </summary>
      <param name="Type">The object type</param>
      <returns>The code used</returns>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupStartMethod(System.Reflection.MethodInfo,System.Type)">
      <summary>
            Sets up the start of the method
            </summary>
      <param name="Method">Method information</param>
      <param name="BaseType">Base type</param>
      <returns>The code used</returns>
    </member>
    <member name="P:Utilities.ORM.Aspect.ORMAspect.Mapper">
      <summary>
            Mapper
            </summary>
    </member>
    <member name="P:Utilities.ORM.Aspect.ORMAspect.AssembliesUsing">
      <summary>
            Assemblies using
            </summary>
    </member>
    <member name="P:Utilities.ORM.Aspect.ORMAspect.InterfacesUsing">
      <summary>
            Interfaces using
            </summary>
    </member>
    <member name="P:Utilities.ORM.Aspect.ORMAspect.Usings">
      <summary>
            Usings using
            </summary>
    </member>
    <member name="P:Utilities.ORM.Aspect.ORMAspect.Fields">
      <summary>
            Fields that have been completed already
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IIEnumerableManyToOne">
      <summary>
            IEnumerableManyToOne interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IID">
      <summary>
            ID interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IListManyToMany">
      <summary>
            ListManyToMany interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IListManyToOne">
      <summary>
            ListManyToOne interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IManyToMany">
      <summary>
            ManyToMany interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IManyToOne">
      <summary>
            ManyToOne interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IMap">
      <summary>
            Map interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IReference">
      <summary>
            Reference interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Module.ORMModule">
      <summary>
            ORM module
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Module.ORMModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.ORM.Manager.Module.ORMModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.ORMManager">
      <summary>
            ORM Manager class
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.ORMManager.#ctor(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Constructor
            </summary>
      <requires description="Bootstrapper" exception="T:System.ArgumentNullException" csharp="Bootstrapper != null" vb="Bootstrapper &lt;&gt; Nothing">Bootstrapper != null</requires>
      <exception cref="T:System.ArgumentNullException">Bootstrapper == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.ORMManager.ToString">
      <summary>
            Outputs information from the manager
            </summary>
      <returns>String version of the ORMManager</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Manager.ORMManager.MapperProvider">
      <summary>
            Mapper provider
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.ORMManager.Mappings">
      <summary>
            Mappings associate with a source
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.ORMManager.QueryProvider">
      <summary>
            Query provider
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.ORMManager.SchemaProvider">
      <summary>
            Schema provider
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.ORMManager.SourceProvider">
      <summary>
            Source provider
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Session">
      <summary>
            Session object
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.All``1(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Returns all items that match the criteria
            </summary>
      <typeparam name="ObjectType">Type of the object</typeparam>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>All items that match the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.Any``1(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Returns a single item matching the criteria
            </summary>
      <typeparam name="ObjectType">Type of the object</typeparam>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A single object matching the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.Delete``1(``0)">
      <summary>
            Deletes an object from the database
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Object">Object to delete</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.LoadProperties``2(``0,System.String)">
      <summary>
            Loads a property (primarily used internally for lazy loading)
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Object">Object</param>
      <param name="PropertyName">Property name</param>
      <returns>The appropriate property value</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.LoadProperty``2(``0,System.String)">
      <summary>
            Loads a property (primarily used internally for lazy loading)
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Object">Object</param>
      <param name="PropertyName">Property name</param>
      <returns>The appropriate property value</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.PageCount``1(System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Gets the number of pages based on the specified
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameters to search by</param>
      <typeparam name="ObjectType">Object type to get the page count of</typeparam>
      <returns>The number of pages that the table contains for the specified page size</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.Paged``1(System.Int32,System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Returns a paged list of items
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (starting with 0)</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A paged list of items that match the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.Save``2(``0)">
      <summary>
            Saves an object to the database
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="PrimaryKeyType">Primary key type</typeparam>
      <param name="Object">Object to save</param>
    </member>
    <member name="P:Utilities.ORM.Manager.Session.MapperProvider">
      <summary>
            Mapper provider
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Session.QueryProvider">
      <summary>
            Query provider
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Session.SourceProvider">
      <summary>
            Source provider
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.SourceProvider.DefaultDatabase">
      <summary>
            Default database object
            </summary>
    </member>
    <member name="T:Utilities.ORM.Interfaces.IDatabase">
      <summary>
            Database configuration interface
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IDatabase.Audit">
      <summary>
            Determines if audit tables are generated
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IDatabase.Name">
      <summary>
            Name associated with the database
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IDatabase.Order">
      <summary>
            Order that this database should be in (if only one database is being used, it is ignored)
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IDatabase.Readable">
      <summary>
            Should this database be used to read data?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IDatabase.Update">
      <summary>
            Should the structure of the database be updated?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IDatabase.Writable">
      <summary>
            Should this database be used to write data?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.DefaultDatabase.Audit">
      <summary>
            Should the database be auditted
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.DefaultDatabase.Name">
      <summary>
            The name of the connection string
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.DefaultDatabase.Order">
      <summary>
            Order of the database (used when running commands to save/select objects)
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.DefaultDatabase.Readable">
      <summary>
            Is this readable?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.DefaultDatabase.Update">
      <summary>
            Should we update the database
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.DefaultDatabase.Writable">
      <summary>
            Is this writable?
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.SourceProvider.Manager">
      <summary>
            Database manager
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.SourceProvider.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.SourceProvider.Manager.GetEnumerator">
      <summary>
            Gets the enumerator for the sources
            </summary>
      <returns>The source enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.ORM.Manager.SourceProvider.Manager.GetSource(System.String)">
      <summary>
            Gets the source info specified
            </summary>
      <param name="Name">Name of the source to get</param>
      <returns>The source specified</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.SourceProvider.Manager.GetSource(System.Type)">
      <summary>
            Getsthe source info specified
            </summary>
      <param name="DatabaseType">Database type</param>
      <returns>The source specified</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.SourceProvider.Manager.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the sources
            </summary>
      <returns>The source enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.ORM.Manager.SourceProvider.Manager.ToString">
      <summary>
            Outputs the source information as a string
            </summary>
      <returns>The source information as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Manager.Sources">
      <summary>
            Source information
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.SourceProvider.Module.SourceProviderModule">
      <summary>
            Schema module
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.SourceProvider.Module.SourceProviderModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Module.SourceProviderModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.SourceProvider.SourceInfo">
      <summary>
            Source info class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo">
      <summary>
            Source information
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo.Connection">
      <summary>
            Connection string
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo.Database">
      <summary>
            The database object associated with the source info (if one is associated with it)
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo.Name">
      <summary>
            Name of the source
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo.Order">
      <summary>
            Order that the source should be used in
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo.ParameterPrefix">
      <summary>
            Parameter prefix that the source uses
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo.Readable">
      <summary>
            Should this source be used to read data?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo.SourceType">
      <summary>
            Source type, based on ADO.Net provider name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo.Writable">
      <summary>
            Should this source be used to write data?
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.SourceProvider.SourceInfo.#ctor(System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,Utilities.ORM.Interfaces.IDatabase)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.SourceInfo.Connection">
      <summary>
            Connection string
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.SourceInfo.Database">
      <summary>
            The database object associated with the source info (if one is associated with it)
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.SourceInfo.Name">
      <summary>
            Name of the source
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.SourceInfo.Order">
      <summary>
            Order that the source is generally used in
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.SourceInfo.ParameterPrefix">
      <summary>
            Parameter prefix that the source uses
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.SourceInfo.Readable">
      <summary>
            Should this source be used to read data?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.SourceInfo.SourceType">
      <summary>
            Source type, based on ADO.Net provider name or identifier used by CUL
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.SourceProvider.SourceInfo.Writable">
      <summary>
            Should this source be used to write data?
            </summary>
    </member>
    <member name="T:Utilities.ORM.Parameters.BetweenParameter`1">
      <summary>
            Parameter class that checks if a value is between two other values
            </summary>
      <typeparam name="DataType">Type of the parameter</typeparam>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1">
      <summary>
            Parameter base class
            </summary>
      <typeparam name="DataType">Data type of the parameter</typeparam>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter`1">
      <summary>
            Parameter interface
            </summary>
      <typeparam name="T">Value type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter">
      <summary>
            Parameter interface
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds this parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter.DatabaseType">
      <summary>
            Database type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter.Direction">
      <summary>
            Direction of the parameter
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter.ID">
      <summary>
            The name that the parameter goes by
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter`1.Value">
      <summary>
            The value that the parameter is associated with
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.#ctor(System.String,`0,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">
            What the database expects as the parameter starting string ("@" for SQL Server, ":" for
            Oracle, etc.)
            </param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.#ctor(System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Type">Database type</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">
            What the database expects as the parameter starting string ("@" for SQL Server, ":" for
            Oracle, etc.)
            </param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.#ctor(System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Type">Database type</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">
            What the database expects as the parameter starting string ("@" for SQL Server, ":" for
            Oracle, etc.)
            </param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.op_Inequality(Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase{`0},Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase{`0})">
      <summary>
            != operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>returns true if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.op_Equality(Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase{`0},Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase{`0})">
      <summary>
            The == operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>true if the first and second item are the same, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds this parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.GetHashCode">
      <summary>
            Gets the hash code for the object
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.ToString">
      <summary>
            Returns the string version of the parameter
            </summary>
      <returns>The string representation of the parameter</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.DatabaseType">
      <summary>
            Database type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.Direction">
      <summary>
            Direction of the parameter
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.ID">
      <summary>
            The Name that the parameter goes by
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.ParameterStarter">
      <summary>
            Starting string of the parameter
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.Value">
      <summary>
            Parameter value
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.BaseClasses.ParameterBase`1.BatchID">
      <summary>
            Batch ID
            </summary>
    </member>
    <member name="M:Utilities.ORM.Parameters.BetweenParameter`1.#ctor(`0,`0,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value of the parameter</param>
      <param name="Max">Max value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">
            What the database expects as the parameter starting string ("@" for SQL Server, ":" for
            Oracle, etc.)
            </param>
    </member>
    <member name="M:Utilities.ORM.Parameters.BetweenParameter`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.BetweenParameter`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Parameters.BetweenParameter`1.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Parameters.BetweenParameter`1.Max">
      <summary>
            Max value of the parameter
            </summary>
    </member>
    <member name="P:Utilities.ORM.Parameters.BetweenParameter`1.Min">
      <summary>
            Min value of the parameter
            </summary>
    </member>
    <member name="T:Utilities.ORM.Parameters.EqualParameter`1">
      <summary>
            Parameter class that checks for equality
            </summary>
      <typeparam name="DataType">Type of the parameter</typeparam>
    </member>
    <member name="M:Utilities.ORM.Parameters.EqualParameter`1.#ctor(`0,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">
            What the database expects as the parameter starting string ("@" for SQL Server, ":" for
            Oracle, etc.)
            </param>
    </member>
    <member name="M:Utilities.ORM.Parameters.EqualParameter`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.EqualParameter`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Parameters.EqualParameter`1.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.ORM.DbCommandExtensions">
      <summary>
            Extension methods for DbCommand objects
            </summary>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.AddParameter(System.Data.Common.DbCommand,System.String,System.String,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for strings only)
            </summary>
      <param name="Command">Command object</param>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Direction">Direction that the parameter goes (in or out)</param>
      <returns>The DbCommand object</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="Command != null" vb="Command &lt;&gt; Nothing">Command != null</requires>
      <exception cref="T:System.ArgumentNullException">Command == null</exception>
      <requires description="ID" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ID)" vb="Not IsNullOrEmpty(ID)">!string.IsNullOrEmpty(ID)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ID)</exception>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.AddParameter(System.Data.Common.DbCommand,System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Direction">Direction that the parameter goes (in or out)</param>
      <param name="Command">Command object</param>
      <param name="Type">SQL type of the parameter</param>
      <returns>The DbCommand object</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="Command != null" vb="Command &lt;&gt; Nothing">Command != null</requires>
      <exception cref="T:System.ArgumentNullException">Command == null</exception>
      <requires description="ID" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ID)" vb="Not IsNullOrEmpty(ID)">!string.IsNullOrEmpty(ID)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ID)</exception>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.AddParameter``1(System.Data.Common.DbCommand,System.String,``0,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <typeparam name="DataType">Data type of the parameter</typeparam>
      <param name="ID">Name of the parameter</param>
      <param name="Direction">Direction that the parameter goes (in or out)</param>
      <param name="Command">Command object</param>
      <param name="Value">Value to add</param>
      <returns>The DbCommand object</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="Command != null" vb="Command &lt;&gt; Nothing">Command != null</requires>
      <exception cref="T:System.ArgumentNullException">Command == null</exception>
      <requires description="ID" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ID)" vb="Not IsNullOrEmpty(ID)">!string.IsNullOrEmpty(ID)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ID)</exception>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.AddParameter(System.Data.Common.DbCommand,System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Direction">Direction that the parameter goes (in or out)</param>
      <param name="Command">Command object</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <returns>The DbCommand object</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="Command != null" vb="Command &lt;&gt; Nothing">Command != null</requires>
      <exception cref="T:System.ArgumentNullException">Command == null</exception>
      <requires description="ID" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ID)" vb="Not IsNullOrEmpty(ID)">!string.IsNullOrEmpty(ID)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ID)</exception>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.BeginTransaction(System.Data.Common.DbCommand)">
      <summary>
            Begins a transaction
            </summary>
      <param name="Command">Command object</param>
      <returns>A transaction object</returns>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.ClearParameters(System.Data.Common.DbCommand)">
      <summary>
            Clears the parameters
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.Close(System.Data.Common.DbCommand)">
      <summary>
            Closes the connection
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.Commit(System.Data.Common.DbCommand)">
      <summary>
            Commits a transaction
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.ExecuteDataSet(System.Data.Common.DbCommand,System.Data.Common.DbProviderFactory)">
      <summary>
            Executes the query and returns a data set
            </summary>
      <param name="Command">Command object</param>
      <param name="Factory">DbProviderFactory being used</param>
      <returns>A dataset filled with the results of the query</returns>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.ExecuteScalar``1(System.Data.Common.DbCommand,``0)">
      <summary>
            Executes the stored procedure as a scalar query
            </summary>
      <param name="Command">Command object</param>
      <param name="Default">Default value if there is an issue</param>
      <returns>The object of the first row and first column</returns>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.GetOrCreateParameter(System.Data.Common.DbCommand,System.String)">
      <summary>
            Gets a parameter or creates it, if it is not found
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Command">Command object</param>
      <returns>The DbParameter associated with the ID</returns>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.GetOutputParameter``1(System.Data.Common.DbCommand,System.String,``0)">
      <summary>
            Returns an output parameter's value
            </summary>
      <typeparam name="DataType">Data type of the object</typeparam>
      <param name="ID">Parameter name</param>
      <param name="Command">Command object</param>
      <param name="Default">Default value for the parameter</param>
      <returns>
            if the parameter exists (and isn't null or empty), it returns the parameter's value.
            Otherwise the default value is returned.
            </returns>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.Open(System.Data.Common.DbCommand)">
      <summary>
            Opens the connection
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="M:Utilities.ORM.DbCommandExtensions.Rollback(System.Data.Common.DbCommand)">
      <summary>
            Rolls back a transaction
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="T:Utilities.ORM.IDataReaderExtensions">
      <summary>
            Extension methods for DbDataReader objects
            </summary>
    </member>
    <member name="M:Utilities.ORM.IDataReaderExtensions.GetParameter``1(System.Data.IDataRecord,System.String,``0)">
      <summary>
            Returns a parameter's value
            </summary>
      <param name="Reader">Reader object</param>
      <param name="ID">Parameter name</param>
      <param name="Default">Default value for the parameter</param>
      <returns>
            if the parameter exists (and isn't null or empty), it returns the parameter's value.
            Otherwise the default value is returned.
            </returns>
    </member>
    <member name="M:Utilities.ORM.IDataReaderExtensions.GetParameter``1(System.Data.IDataRecord,System.Int32,``0)">
      <summary>
            Returns a parameter's value
            </summary>
      <param name="Reader">Reader object</param>
      <param name="Position">Position in the reader row</param>
      <param name="Default">Default value for the parameter</param>
      <returns>
            if the parameter exists (and isn't null or empty), it returns the parameter's value.
            Otherwise the default value is returned.
            </returns>
    </member>
    <member name="T:Utilities.ORM.Parameters.AndParameter">
      <summary>
            Parameter class that ANDs two other parameters together
            </summary>
    </member>
    <member name="M:Utilities.ORM.Parameters.AndParameter.#ctor(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Parameters.AndParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.AndParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Parameters.AndParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Parameters.AndParameter.Left">
      <summary>
            Left parameter
            </summary>
    </member>
    <member name="P:Utilities.ORM.Parameters.AndParameter.Right">
      <summary>
            Right parameter
            </summary>
    </member>
    <member name="T:Utilities.ORM.Parameters.LikeParameter">
      <summary>
            Parameter class handling strings that instead of looking for equality, uses the SQL Like command
            </summary>
    </member>
    <member name="M:Utilities.ORM.Parameters.LikeParameter.#ctor(System.String,System.String,System.Int32,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">
            What the database expects as the parameter starting string ("@" for SQL Server, ":" for
            Oracle, etc.)
            </param>
      <param name="Length">Max length allowed for the string</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.LikeParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.LikeParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Parameters.LikeParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Parameters.LikeParameter.Length">
      <summary>
            Max length of the string
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3">
      <summary>
            Property base class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3">
      <summary>
            Property interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
      <typeparam name="ReturnType">Return type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetAutoIncrement">
      <summary>
            Turns on autoincrement for this property
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetCascade">
      <summary>
            Turns on cascade for saving/deleting
            </summary>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetDefaultValue(System.Func{`1})">
      <summary>
            Sets the default value of the property
            </summary>
      <param name="Value">Default value</param>
      <returns>This IProperty object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetFieldName(System.String)">
      <summary>
            Sets the name of the field in the database
            </summary>
      <param name="FieldName">Field name</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetIndex">
      <summary>
            Turns on indexing for this property
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetLoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Allows you to load a property based on a specified command
            </summary>
      <param name="Command">Command used to load the property</param>
      <param name="CommandType">Command type</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetMaxLength(System.Int32)">
      <summary>
            Sets the max length for the property (or precision for items like decimal values)
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetNotNull">
      <summary>
            Sets the field such that null values are not allowed
            </summary>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetTableName(System.String)">
      <summary>
            Set database table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`3.SetUnique">
      <summary>
            Ensures the field is unique
            </summary>
      <returns>this</returns>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`2">
      <summary>
            Property interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType" />
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`1">
      <summary>
            Property interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Interfaces.IProperty">
      <summary>
            Property interface
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.GetValue(System.Object)">
      <summary>
            Gets the property's value from the object sent in
            </summary>
      <param name="Object">Object to get the value from</param>
      <returns>The value of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property (used internally)
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source to use</param>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.AutoIncrement">
      <summary>
            Auto increment
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.Cascade">
      <summary>
            Cascade
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.DerivedFieldName">
      <summary>
            Derived field name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.FieldName">
      <summary>
            Field name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.ForeignMapping">
      <summary>
            If the property is a class, this is the foreign mapping
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.Index">
      <summary>
            Index
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.LoadCommand">
      <summary>
            Load command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.LoadCommandType">
      <summary>
            Load command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.Mapping">
      <summary>
            Mapping
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.MaxLength">
      <summary>
            Max length
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.Name">
      <summary>
            Property name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.NotNull">
      <summary>
            Not null
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.TableName">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.Type">
      <summary>
            Property type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty.Unique">
      <summary>
            Unique
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`1.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been visited thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`1.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been visited thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`1.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been visited thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`1.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been visited thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`1.GetValue(`0)">
      <summary>
            Gets the property's value from the object sent in
            </summary>
      <param name="Object">Object to get the value from</param>
      <returns>The value of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`1.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been visited thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`1.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been visited thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`2.CompiledExpression">
      <summary>
            Compiled version of the expression
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`2.DefaultValue">
      <summary>
            Default value for this property
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Interfaces.IProperty`2.Expression">
      <summary>
            Expression pointing to the property
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression used to point to the property</param>
      <param name="Mapping">Mapping the StringID is added to</param>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.op_Inequality(Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase{`0,`1,`2},Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase{`0,`1,`2})">
      <summary>
            != operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>returns true if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.op_LessThan(Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase{`0,`1,`2},Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase{`0,`1,`2})">
      <summary>
            The &lt; operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>True if the first item is less than the second, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.op_Equality(Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase{`0,`1,`2},Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase{`0,`1,`2})">
      <summary>
            The == operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>true if the first and second item are the same, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.op_GreaterThan(Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase{`0,`1,`2},Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase{`0,`1,`2})">
      <summary>
            The &gt; operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>True if the first item is greater than the second, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.Equals(System.Object)">
      <summary>
            Determines if the two objects are equal and returns true if they are, false otherwise
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.GetHashCode">
      <summary>
            Returns the hash code for the property
            </summary>
      <returns>The hash code for the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.GetValue(`0)">
      <summary>
            Gets the property's value from the object sent in
            </summary>
      <param name="Object">Object to get the value from</param>
      <returns>The value of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.GetValue(System.Object)">
      <summary>
            Gets the property's value from the object sent in
            </summary>
      <param name="Object">Object to get the value from</param>
      <returns>The value of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been visited thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been visited thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetAutoIncrement">
      <summary>
            Turns on autoincrement for this property
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetCascade">
      <summary>
            Turns on cascade for saving/deleting
            </summary>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetDefaultValue(System.Func{`1})">
      <summary>
            Sets the default value of the property
            </summary>
      <param name="Value">Default value</param>
      <returns>This IProperty object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetFieldName(System.String)">
      <summary>
            Sets the name of the field in the database
            </summary>
      <param name="FieldName">Field name</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetIndex">
      <summary>
            Turns on indexing for this property
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetLoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Allows you to load a property based on a specified command
            </summary>
      <param name="Command">Command used to load the property</param>
      <param name="CommandType">Command type</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetMaxLength(System.Int32)">
      <summary>
            Sets the max length for the property (or precision for items like decimal values)
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetNotNull">
      <summary>
            Sets the field such that null values are not allowed
            </summary>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetTableName(System.String)">
      <summary>
            Set database table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.SetUnique">
      <summary>
            Ensures the field is unique
            </summary>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property, is used internally
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.ToString">
      <summary>
            Gets the property as a string
            </summary>
      <returns>The string representation of the property</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.AutoIncrement">
      <summary>
            Auto increment
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.Cascade">
      <summary>
            Cascade
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.CompiledExpression">
      <summary>
            Compiled expression
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.DefaultValue">
      <summary>
            Default value
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.DerivedFieldName">
      <summary>
            Derived field name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.Expression">
      <summary>
            Expression
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.FieldName">
      <summary>
            Field name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.ForeignMapping">
      <summary>
            Foreign mapping
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.Index">
      <summary>
            Index
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.LoadCommand">
      <summary>
            Command used to load the property
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.LoadCommandType">
      <summary>
            Command type for the load command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.Mapping">
      <summary>
            Mapping
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.MaxLength">
      <summary>
            Max length
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.Name">
      <summary>
            Property name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.NotNull">
      <summary>
            Not null
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.TableName">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.Type">
      <summary>
            Property type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.BaseClasses.PropertyBase`3.Unique">
      <summary>
            Unique
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Default.ID`2">
      <summary>
            ID class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ID`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the ID</param>
      <param name="Mapping">Mapping the StringID is added to</param>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ID`2.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ID`2.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ID`2.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ID`2.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects that have been seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ID`2.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ID`2.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ID`2.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ID`2.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2">
      <summary>
            Many to one class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{`1}}},Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to one</param>
      <param name="Mapping">Mapping the StringID is added to</param>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne`2.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2">
      <summary>
            Many to many class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{`1}}},Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to many</param>
      <param name="Mapping">Mapping the StringID is added to</param>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToMany`2.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2">
      <summary>
            Many to one class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{`1}}},Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to one</param>
      <param name="Mapping">Mapping the StringID is added to</param>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ListManyToOne`2.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2">
      <summary>
            Many to many class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{`1}}},Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to many</param>
      <param name="Mapping">Mapping the StringID is added to</param>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToMany`2.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2">
      <summary>
            Many to one class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to one</param>
      <param name="Mapping">Mapping the StringID is added to</param>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.ManyToOne`2.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Default.Map`2">
      <summary>
            Map class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Map`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the Map</param>
      <param name="Mapping">Mapping the StringID is added to</param>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Map`2.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Map`2.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Map`2.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Map`2.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Map`2.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Map`2.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Map`2.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Map`2.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Default.Reference`2">
      <summary>
            Reference class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Reference`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the property</param>
      <param name="Mapping">Mapping the StringID is added to</param>
      <requires description="Expression" exception="T:System.ArgumentNullException" csharp="Expression != null" vb="Expression &lt;&gt; Nothing">Expression != null</requires>
      <exception cref="T:System.ArgumentNullException">Expression == null</exception>
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Reference`2.CascadeDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade delete of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Reference`2.CascadeJoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Reference`2.CascadeJoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining tables
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Reference`2.CascadeSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Does a cascade save of an object for this property
            </summary>
      <param name="Object">Object</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <param name="Source">Source info</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Reference`2.GetParameter(System.Object)">
      <summary>
            Gets the property as a parameter (for classes, this will return the ID of the property)
            </summary>
      <param name="Object">Object to get the parameter from</param>
      <returns>The parameter version of the property</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Reference`2.JoinsDelete(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that deletes items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Reference`2.JoinsSave(`0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,System.Collections.Generic.IList{System.Object})">
      <summary>
            Called to create a batch that saves items from the joining table
            </summary>
      <param name="Object">Object</param>
      <param name="Source">Source info</param>
      <param name="ObjectsSeen">Objects seen thus far</param>
      <returns>Batch object with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Default.Reference`2.Setup(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Manager,Utilities.ORM.Manager.QueryProvider.Manager)">
      <summary>
            Sets up the property
            </summary>
      <param name="MappingProvider">Mapping provider</param>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Manager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Manager.GetEnumerator">
      <summary>
            Gets the enumerator for the mappings
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Manager.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the mappings
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Manager.ToString">
      <summary>
            Outputs the mapping information as a string
            </summary>
      <returns>The mapping information as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Manager.Mappings">
      <summary>
            Mappings
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Manager.Item(System.Type)">
      <summary>
            Gets the mapping specified by the object type
            </summary>
      <param name="Key">The object type</param>
      <returns>The mapping specified</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Manager.Item(System.Type,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Gets the mapping specified by the object type and source
            </summary>
      <param name="Key">The object type</param>
      <param name="Source">Source information</param>
      <returns>The mapping specified</returns>
    </member>
    <member name="T:Utilities.ORM.Manager.Mapper.Module.MapperModule">
      <summary>
            Mapper module
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Mapper.Module.MapperModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.ORM.Manager.Mapper.Module.MapperModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.BaseClasses.DatabaseQueryProviderBase">
      <summary>
            Database query provider base class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Interfaces.IQueryProvider">
      <summary>
            Query provider
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IQueryProvider.Batch(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Creates a batch for running commands
            </summary>
      <param name="Source">Source info</param>
      <returns>A batch object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IQueryProvider.Generate``1(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Creates a generator object
            </summary>
      <typeparam name="T">Class type to create the generator for</typeparam>
      <param name="Source">Source info</param>
      <param name="Mapping">Mapping info</param>
      <returns>Generator object</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Interfaces.IQueryProvider.ProviderName">
      <summary>
            Provider name associated with the query provider
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.DatabaseQueryProviderBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.DatabaseQueryProviderBase.Batch(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Returns a batch object
            </summary>
      <param name="Source">Source info</param>
      <returns>Batch object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.BaseClasses.DatabaseQueryProviderBase.Generate``1(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Creates a generator class for the appropriate provider
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Source">Source info</param>
      <param name="Mapping">Mapping info</param>
      <returns>A generator class</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.BaseClasses.DatabaseQueryProviderBase.ProviderName">
      <summary>
            Provider name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.BaseClasses.DatabaseQueryProviderBase.ParameterPrefix">
      <summary>
            Parameter prefix
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Default.Command">
      <summary>
            Command class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Interfaces.ICommand">
      <summary>
            Command interface
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Interfaces.ICommand.CommandType">
      <summary>
            Command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Interfaces.ICommand.Parameters">
      <summary>
            Parameters associated with the command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Interfaces.ICommand.SQLCommand">
      <summary>
            Actual SQL command
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Command.#ctor(System.Action{System.Object,System.Collections.Generic.IList{System.Object}},System.Object,System.String,System.Data.CommandType,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Constructor
            </summary>
      <param name="SQLCommand">SQL Command</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters</param>
      <param name="CallBack">Called when command has been executed</param>
      <param name="Object">Object</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Command.#ctor(System.Action{System.Object,System.Collections.Generic.IList{System.Object}},System.Object,System.String,System.Data.CommandType,System.String,System.Object[])">
      <summary>
            Constructor
            </summary>
      <param name="SQLCommand">SQL Command</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters</param>
      <param name="ParameterStarter">Parameter starter</param>
      <param name="CallBack">Called when command has been executed</param>
      <param name="Object">Object</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Command.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>Determines if the commands are equal</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Command.Finalize(System.Collections.Generic.IList{System.Object})">
      <summary>
            Called after the command is run
            </summary>
      <param name="Result">Result of the command</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Command.GetHashCode">
      <summary>
            Returns the hash code for the command
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Command.ToString">
      <summary>
            Returns the string representation of the command
            </summary>
      <returns>The string representation of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.Command.CallBack">
      <summary>
            Call back
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.Command.CommandType">
      <summary>
            Command type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.Command.Finalizable">
      <summary>
            Used to determine if Finalize should be called.
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.Command.Object">
      <summary>
            Object
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.Command.Parameters">
      <summary>
            Parameters
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.Command.SQLCommand">
      <summary>
            SQL command
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch">
      <summary>
            Database batch class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch">
      <summary>
            Batch interface, used to add commands and executes them
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch.AddCommand(System.Action{System.Object,System.Collections.Generic.IList{System.Object}},System.Object,System.Data.CommandType,System.String)">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="CallBack">Callback action</param>
      <param name="Object">Object used in the callback action</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch.AddCommand(System.Action{System.Object,System.Collections.Generic.IList{System.Object}},System.Object,System.String,System.Data.CommandType,System.Object[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to add</param>
      <param name="CallBack">Callback action</param>
      <param name="Object">Object used in the callback action</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch.AddCommand(System.Action{System.Object,System.Collections.Generic.IList{System.Object}},System.Object,System.String,System.Data.CommandType,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to add</param>
      <param name="CallBack">Callback action</param>
      <param name="Object">Object used in the callback action</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch.AddCommand(Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch)">
      <summary>
            Adds a batch's commands to the current batch
            </summary>
      <param name="Batch">Batch to add</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch.Execute">
      <summary>
            Executes the commands and returns the results
            </summary>
      <returns>The results of the batched commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch.RemoveDuplicateCommands">
      <summary>
            Removes duplicate commands from the batch
            </summary>
      <returns>This</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch.CommandCount">
      <summary>
            Number of commands being batched
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.#ctor(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Constructor
            </summary>
      <param name="Source">Source info</param>
    </member>
    <member name="F:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.ParameterRegex">
      <summary>
            Used to parse SQL commands to find parameters (when batching)
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.AddCommand(System.Action{System.Object,System.Collections.Generic.IList{System.Object}},System.Object,System.Data.CommandType,System.String)">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="CallBack">Callback action</param>
      <param name="Object">Object used in the callback action</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.AddCommand(System.Action{System.Object,System.Collections.Generic.IList{System.Object}},System.Object,System.String,System.Data.CommandType,System.Object[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to add</param>
      <param name="CallBack">Callback action</param>
      <param name="Object">Object used in the callback action</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.AddCommand(System.Action{System.Object,System.Collections.Generic.IList{System.Object}},System.Object,System.String,System.Data.CommandType,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to add</param>
      <param name="CallBack">Callback action</param>
      <param name="Object">Object used in the callback action</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.AddCommand(Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch)">
      <summary>
            Adds a batch's commands to the current batch
            </summary>
      <param name="Batch">Batch to add</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.Execute">
      <summary>
            Executes the commands and returns the results
            </summary>
      <returns>The results of the batched commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.RemoveDuplicateCommands">
      <summary>
            Removes duplicate commands from the batch
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.ToString">
      <summary>
            Converts the batch to a string
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.CommandCount">
      <summary>
            Command count
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.Commands">
      <summary>
            Commands to batch
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.Source">
      <summary>
            Connection string
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Default.Parameter`1">
      <summary>
            Holds parameter information
            </summary>
      <typeparam name="DataType">Data type of the parameter</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Parameter`1.#ctor(System.String,`0,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Parameter`1.#ctor(System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Type">Database type</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Parameter`1.#ctor(System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Type">Database type</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Parameter`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds this parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.Parameter`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1">
      <summary>
            SQL Server generator
            </summary>
      <typeparam name="T">Class type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1">
      <summary>
            Generator interface, used to generate commands
            </summary>
      <typeparam name="T">Class type to generate</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.All(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get all items for the given type the parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.All(System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get all items for the given type the parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <param name="Limit">Max number of items to return</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.Any(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get the first item that satisfies the parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.Delete(`0)">
      <summary>
            Generates a batch that will delete the object
            </summary>
      <param name="Object">Object to delete</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.Delete(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Generates a batch that will delete the object
            </summary>
      <param name="Objects">Objects to delete</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.Insert(`0)">
      <summary>
            Generates a batch that will insert the data from the object
            </summary>
      <param name="Object">Object to insert</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.Insert(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Generates a batch that will insert the data from the objects
            </summary>
      <param name="Objects">Objects to insert</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.JoinsDelete``1(Utilities.ORM.Manager.Mapper.Interfaces.IProperty{`0,``0},`0)">
      <summary>
            Deletes items from the joining table for the property
            </summary>
      <param name="Property">Property</param>
      <param name="Object">Object</param>
      <typeparam name="P">Property type</typeparam>
      <returns>The batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.JoinsSave``2(Utilities.ORM.Manager.Mapper.Interfaces.IProperty{`0,``0},`0)">
      <summary>
            Saves items to the joining table for the property
            </summary>
      <param name="Property">Property</param>
      <param name="Object">Object</param>
      <typeparam name="P">Property type</typeparam>
      <typeparam name="ItemType">Item type</typeparam>
      <returns>The batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.LoadProperty``1(`0,Utilities.ORM.Manager.Mapper.Interfaces.IProperty)">
      <summary>
            Generates a batch that will get the specific property for the object
            </summary>
      <typeparam name="P">Property type</typeparam>
      <param name="Object">Object to get the property for</param>
      <param name="Property">Property to get</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.PageCount(System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get the number of pages for a given page size given the
            parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <param name="PageSize">Page size</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.Paged(System.Int32,System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get a specific page of data that satisfies the parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <param name="CurrentPage">The current page (starting at 0)</param>
      <param name="PageSize">Page size</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.Save``1(`0)">
      <summary>
            Saves the object to the source
            </summary>
      <typeparam name="PrimaryKeyType">Primary key type</typeparam>
      <param name="Object">Object to save</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.SetupCommands(Utilities.ORM.Manager.Mapper.Interfaces.IMapping{`0})">
      <summary>
            Sets up the commands for the mapping
            </summary>
      <param name="Mapping">Mapping to set up</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.Map{`0,``0})">
      <summary>
            Sets up the default load command for a map property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">Map property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne{`0,``0})">
      <summary>
            Sets up the default load command for a IEnumerableManyToOne property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">IEnumerableManyToOne property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.ListManyToOne{`0,``0})">
      <summary>
            Sets up the default load command for a ListManyToOne property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">ListManyToOne property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.ListManyToMany{`0,``0})">
      <summary>
            Sets up the default load command for a ListManyToMany property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">ListManyToMany property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.ManyToMany{`0,``0})">
      <summary>
            Sets up the default load command for a ManyToMany property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">ManyToMany property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.ManyToOne{`0,``0})">
      <summary>
            Sets up the default load command for a ManyToOne property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">ManyToOne property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.Update(`0)">
      <summary>
            Generates a batch that will update the data from the object
            </summary>
      <param name="Object">Object to update</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Interfaces.IGenerator`1.Update(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Generates a batch that will update the data from the objects
            </summary>
      <param name="Objects">Objects to update</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.#ctor(Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerQueryProvider,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="QueryProvider">Query provider</param>
      <param name="Source">Source info</param>
      <param name="Mapping">Mapping info</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.All(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get all items for the given type the parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.All(System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get all items for the given type the parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <param name="Limit">Max number of items to return</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Any(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get the first item that satisfies the parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Delete(`0)">
      <summary>
            Generates a batch that will delete the object
            </summary>
      <param name="Object">Object to delete</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Delete(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Generates a batch that will delete the object
            </summary>
      <param name="Objects">Objects to delete</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Insert(`0)">
      <summary>
            Generates a batch that will insert the data from the object
            </summary>
      <param name="Object">Object to insert</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Insert(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Generates a batch that will insert the data from the objects
            </summary>
      <param name="Objects">Objects to insert</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.JoinsDelete``1(Utilities.ORM.Manager.Mapper.Interfaces.IProperty{`0,``0},`0)">
      <summary>
            Deletes items from the joining table for the property
            </summary>
      <param name="Property">Property</param>
      <param name="Object">Object</param>
      <typeparam name="P">Property type</typeparam>
      <returns>The batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.JoinsSave``2(Utilities.ORM.Manager.Mapper.Interfaces.IProperty{`0,``0},`0)">
      <summary>
            Saves items to the joining table for the property
            </summary>
      <param name="Property">Property</param>
      <param name="Object">Object</param>
      <typeparam name="P">Property type</typeparam>
      <typeparam name="ItemType">Item type</typeparam>
      <returns>The batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.LoadProperty``1(`0,Utilities.ORM.Manager.Mapper.Interfaces.IProperty)">
      <summary>
            Generates a batch that will get the specific property for the object
            </summary>
      <typeparam name="P">Property type</typeparam>
      <param name="Object">Object to get the property for</param>
      <param name="Property">Property to get</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.PageCount(System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get the number of pages for a given page size given the
            parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <param name="PageSize">Page size</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Paged(System.Int32,System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Generates a batch that will get a specific page of data that satisfies the parameters specified
            </summary>
      <param name="Parameters">Parameters</param>
      <param name="CurrentPage">The current page (starting at 0)</param>
      <param name="PageSize">Page size</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Save``1(`0)">
      <summary>
            Saves the object to the source
            </summary>
      <typeparam name="PrimaryKeyType">Primary key type</typeparam>
      <param name="Object">Object to save</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupCommands(Utilities.ORM.Manager.Mapper.Interfaces.IMapping{`0})">
      <summary>
            Sets up the various default commands for the mapping
            </summary>
      <param name="Mapping" />
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.Map{`0,``0})">
      <summary>
            Sets up the default load command for a map property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">Map property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.IEnumerableManyToOne{`0,``0})">
      <summary>
            Sets up the default load command for a IEnumerableManyToOne property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">IEnumerableManyToOne property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.ListManyToOne{`0,``0})">
      <summary>
            Sets up the default load command for a ListManyToOne property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">ListManyToOne property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.ListManyToMany{`0,``0})">
      <summary>
            Sets up the default load command for a ListManyToMany property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">ListManyToMany property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.ManyToOne{`0,``0})">
      <summary>
            Sets up the default load command for a ManyToOne property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">ManyToOne property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupLoadCommands``1(Utilities.ORM.Manager.Mapper.Default.ManyToMany{`0,``0})">
      <summary>
            Sets up the default load command for a ManyToMany property
            </summary>
      <typeparam name="D">Data type</typeparam>
      <param name="Property">ManyToMany property</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Update(`0)">
      <summary>
            Generates a batch that will update the data from the object
            </summary>
      <param name="Object">Object to update</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Update(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Generates a batch that will update the data from the objects
            </summary>
      <param name="Objects">Objects to update</param>
      <returns>Batch with the appropriate commands</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Mapping">
      <summary>
            Mapping that the generator uses
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.QueryProvider">
      <summary>
            Query provider that the system uses
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.Source">
      <summary>
            Source used to connect
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerQueryProvider">
      <summary>
            SQL Server query provider
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerQueryProvider.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerQueryProvider.Generate``1(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Creates a generator class for the appropriate provider
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Source">Source information</param>
      <param name="Mapping">Mapping information</param>
      <returns>A generator class</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerQueryProvider.ProviderName">
      <summary>
            Provider name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerQueryProvider.ParameterPrefix">
      <summary>
            Parameter prefix
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Default.StringParameter">
      <summary>
            Holds parameter information
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.StringParameter.#ctor(System.String,System.String,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.StringParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds this parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper</param>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.StringParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Manager">
      <summary>
            Query provider manager
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Manager.Batch(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Creates a batch object
            </summary>
      <param name="Source">Source to use</param>
      <returns>The batch object</returns>
      <requires description="Source" exception="T:System.ArgumentNullException" csharp="Source != null" vb="Source &lt;&gt; Nothing">Source != null</requires>
      <exception cref="T:System.ArgumentNullException">Source == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Manager.Generate``1(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <summary>
            Creates a generator object
            </summary>
      <typeparam name="T">Class type the generator uses</typeparam>
      <param name="Source">Source to use</param>
      <param name="Mapping">Mapping info</param>
      <returns>The generator object</returns>
      <requires description="Source" exception="T:System.ArgumentNullException" csharp="Source != null" vb="Source &lt;&gt; Nothing">Source != null</requires>
      <exception cref="T:System.ArgumentNullException">Source == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Manager.ToString">
      <summary>
            Outputs the provider information as a string
            </summary>
      <returns>The provider information as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Manager.Providers">
      <summary>
            Providers
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.QueryProvider.Module.QueryProviderModule">
      <summary>
            Query provider module
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Module.QueryProviderModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.ORM.Manager.QueryProvider.Module.QueryProviderModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase">
      <summary>
            Source base class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Interfaces.ISource">
      <summary>
            Interface for source objects (like databases)
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISource.AddFunction(System.String,System.String)">
      <summary>
            Adds a function to the database
            </summary>
      <param name="Name">Function name</param>
      <param name="Definition">Function definition</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISource.AddStoredProcedure(System.String,System.String)">
      <summary>
            Adds a stored procedure to the database
            </summary>
      <param name="ProcedureName">Procedure name</param>
      <param name="Definition">Definition</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISource.AddTable(System.String)">
      <summary>
            Adds a table to the database
            </summary>
      <param name="TableName">Table name</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISource.AddView(System.String)">
      <summary>
            Adds a view to the database
            </summary>
      <param name="ViewName">View name</param>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ISource.Functions">
      <summary>
            List of functions
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ISource.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ISource.StoredProcedures">
      <summary>
            List of stored procedures
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ISource.Tables">
      <summary>
            List of tables
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ISource.Views">
      <summary>
            List of views
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ISource.Item(System.String)">
      <summary>
            Returns a table with the given name
            </summary>
      <param name="Name">Table name</param>
      <returns>The table specified</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.AddFunction(System.String,System.String)">
      <summary>
            Adds a function to the source
            </summary>
      <param name="Name">Name of the function</param>
      <param name="Definition">Definition of the function</param>
      <returns>Function that was created/added</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.AddStoredProcedure(System.String,System.String)">
      <summary>
            Adds a stored procedure to the source
            </summary>
      <param name="ProcedureName">Procedure name</param>
      <param name="Definition">Definition of the stored procedure</param>
      <returns>Stored procedure that was created/added</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.AddTable(System.String)">
      <summary>
            Adds a table to the source
            </summary>
      <param name="TableName">Table name</param>
      <returns>Table that was created/added</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.AddView(System.String)">
      <summary>
            Adds a view to the source
            </summary>
      <param name="ViewName">View name</param>
      <returns>View that was created/added</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.Functions">
      <summary>
            Functions with the source
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.Name">
      <summary>
            Name of the source
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.StoredProcedures">
      <summary>
            Stored procedures within the source
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.Tables">
      <summary>
            Tables within the source
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.Views">
      <summary>
            Views within the source
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.SourceBase.Item(System.String)">
      <summary>
            Gets a specific table based on the name
            </summary>
      <param name="Name">Name of the table</param>
      <returns>The table specified</returns>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.BaseClasses.TableBase">
      <summary>
            Table base class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Interfaces.ITable">
      <summary>
            Interface for table like structures
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ITable.AddColumn``1(System.String,System.Data.DbType,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,``0,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Adds a column
            </summary>
      <param name="ColumnName">Column Name</param>
      <param name="ColumnType">Data type</param>
      <param name="Length">Data length</param>
      <param name="Nullable">Nullable?</param>
      <param name="Identity">Identity?</param>
      <param name="Index">Index?</param>
      <param name="PrimaryKey">Primary key?</param>
      <param name="Unique">Unique?</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
      <param name="DefaultValue">Default value</param>
      <param name="OnDeleteCascade">On Delete Cascade</param>
      <param name="OnUpdateCascade">On Update Cascade</param>
      <param name="OnDeleteSetNull">On Delete Set Null</param>
      <typeparam name="T">Column type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ITable.AddForeignKey(System.String,System.String,System.String)">
      <summary>
            Adds a foreign key
            </summary>
      <param name="ColumnName">Column name</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ITable.AddTrigger(System.String,System.String,Utilities.ORM.Manager.Schema.Enums.TriggerType)">
      <summary>
            Adds a trigger to the table
            </summary>
      <param name="Name">Name of the trigger</param>
      <param name="Definition">Trigger definition</param>
      <param name="Type">Trigger type</param>
      <returns>Trigger added to the table</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ITable.ContainsColumn(System.String)">
      <summary>
            Determines if a column exists in the table
            </summary>
      <param name="ColumnName">Column name</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ITable.SetupForeignKeys">
      <summary>
            Sets up foreign keys
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ITable.Columns">
      <summary>
            Columns
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ITable.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ITable.Source">
      <summary>
            Parent of the table structure
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ITable.Triggers">
      <summary>
            Triggers associated with the table (if source supports them)
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ITable.Item(System.String)">
      <summary>
            Returns the specified column
            </summary>
      <param name="Name">Name of the column</param>
      <returns>Column specified</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.#ctor(System.String,Utilities.ORM.Manager.Schema.Interfaces.ISource)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name of the table</param>
      <param name="Source">Source that the table is from</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.AddColumn``1(System.String,System.Data.DbType,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,``0,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Adds a column
            </summary>
      <param name="ColumnName">Column Name</param>
      <param name="ColumnType">Data type</param>
      <param name="Length">Data length</param>
      <param name="Nullable">Nullable?</param>
      <param name="Identity">Identity?</param>
      <param name="Index">Index?</param>
      <param name="PrimaryKey">Primary key?</param>
      <param name="Unique">Unique?</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
      <param name="DefaultValue">Default value</param>
      <param name="OnDeleteCascade">On Delete Cascade</param>
      <param name="OnUpdateCascade">On Update Cascade</param>
      <param name="OnDeleteSetNull">On Delete Set Null</param>
      <typeparam name="T">Column type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.AddForeignKey(System.String,System.String,System.String)">
      <summary>
            Adds a foreign key
            </summary>
      <param name="ColumnName">Column name</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.AddTrigger(System.String,System.String,Utilities.ORM.Manager.Schema.Enums.TriggerType)">
      <summary>
            Adds a trigger to the table
            </summary>
      <param name="Name">Name of the trigger</param>
      <param name="Definition">Definition of the trigger</param>
      <param name="Type">Trigger type</param>
      <returns>The trigger specified</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.ContainsColumn(System.String)">
      <summary>
            Determines if a column exists in the table
            </summary>
      <param name="ColumnName">Column name</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.SetupForeignKeys">
      <summary>
            Sets up foreign keys
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.Columns">
      <summary>
            Columns
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.Name">
      <summary>
            Name of the table
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.Source">
      <summary>
            Source/Parent
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.Triggers">
      <summary>
            List of triggers associated with the table
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.BaseClasses.TableBase.Item(System.String)">
      <summary>
            The column specified
            </summary>
      <param name="Name">Name of the column</param>
      <returns>The column specified</returns>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Default.Database.Column`1">
      <summary>
            Column class
            </summary>
      <typeparam name="T">Data type of the column</typeparam>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Interfaces.IColumn">
      <summary>
            Column interface
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.IColumn.AddForeignKey(System.String,System.String)">
      <summary>
            Add foreign key
            </summary>
      <param name="ForeignKeyTable">Table of the foreign key</param>
      <param name="ForeignKeyColumn">Column of the foreign key</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.IColumn.SetupForeignKeys">
      <summary>
            Sets up the foreign key list
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.AutoIncrement">
      <summary>
            Auto increment?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.DataType">
      <summary>
            Data type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.Default">
      <summary>
            Default value
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.ForeignKey">
      <summary>
            Foreign keys
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.Index">
      <summary>
            Index?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.Length">
      <summary>
            Data length
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.Nullable">
      <summary>
            Nullable?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.OnDeleteCascade">
      <summary>
            On Delete Cascade
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.OnDeleteSetNull">
      <summary>
            On Delete Set Null
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.OnUpdateCascade">
      <summary>
            On Update Cascade
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.ParentTable">
      <summary>
            Parent table
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.PrimaryKey">
      <summary>
            Primary key?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IColumn.Unique">
      <summary>
            Unique?
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Column`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Column`1.#ctor(System.String,System.Data.DbType,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,`0,System.Boolean,System.Boolean,System.Boolean,Utilities.ORM.Manager.Schema.Interfaces.ITable)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name of the column</param>
      <param name="ColumnType">The data type</param>
      <param name="Length">The data length</param>
      <param name="Nullable">Is it nullable?</param>
      <param name="Identity">Is it an identity?</param>
      <param name="Index">Is it the index?</param>
      <param name="PrimaryKey">Is it the primary key?</param>
      <param name="Unique">Is it unique?</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
      <param name="DefaultValue">Default value</param>
      <param name="ParentTable">Parent table</param>
      <param name="OnDeleteCascade">Cascade on delete</param>
      <param name="OnDeleteSetNull">Set null on delete</param>
      <param name="OnUpdateCascade">Cascade on update</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Column`1.AddForeignKey(System.String,System.String)">
      <summary>
            Add foreign key
            </summary>
      <param name="ForeignKeyTable">Table of the foreign key</param>
      <param name="ForeignKeyColumn">Column of the foreign key</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Column`1.SetupForeignKeys">
      <summary>
            Sets up the foreign key list
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.AutoIncrement">
      <summary>
            Auto increment?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.DataType">
      <summary>
            Data type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.Default">
      <summary>
            Default value
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.ForeignKey">
      <summary>
            Foreign keys
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.Index">
      <summary>
            Index?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.Length">
      <summary>
            Data length
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.Nullable">
      <summary>
            Nullable?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.OnDeleteCascade">
      <summary>
            On Delete Cascade
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.OnDeleteSetNull">
      <summary>
            On Delete Set Null
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.OnUpdateCascade">
      <summary>
            On Update Cascade
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.ParentTable">
      <summary>
            Parent table
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.PrimaryKey">
      <summary>
            Primary key?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Column`1.Unique">
      <summary>
            Unique?
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Default.Database.Database">
      <summary>
            Database class
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Database.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name of the database</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Database.AddFunction(System.String,System.String)">
      <summary>
            Adds a function to the database
            </summary>
      <param name="Name">Function name</param>
      <param name="Definition">Function definition</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Database.AddStoredProcedure(System.String,System.String)">
      <summary>
            Adds a stored procedure to the database
            </summary>
      <param name="ProcedureName">Procedure name</param>
      <param name="Definition">Definition</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Database.AddTable(System.String)">
      <summary>
            Adds a table to the database
            </summary>
      <param name="TableName">Table name</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Database.AddView(System.String)">
      <summary>
            Adds a view to the database
            </summary>
      <param name="ViewName">View name</param>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Default.Database.Function">
      <summary>
            Function class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Interfaces.IFunction">
      <summary>
            Function class
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IFunction.Definition">
      <summary>
            Definition
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IFunction.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.IFunction.Source">
      <summary>
            Parent database
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Function.#ctor(System.String,System.String,Utilities.ORM.Manager.Schema.Interfaces.ISource)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
      <param name="Definition">Definition</param>
      <param name="Source">Source</param>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Function.Definition">
      <summary>
            Definition of the Function
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Function.Name">
      <summary>
            Name of the Function
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Function.Source">
      <summary>
            Source
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator">
      <summary>
            SQL Server schema generator
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator">
      <summary>
            Schema generator interface
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator.GenerateSchema(Utilities.ORM.Manager.Schema.Interfaces.ISource,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Generates a list of commands used to modify the source. If it does not exist prior, the
            commands will create the source from scratch. Otherwise the commands will only add new
            fields, tables, etc. It does not delete old fields.
            </summary>
      <param name="DesiredStructure">Desired source structure</param>
      <param name="Source">Source to use</param>
      <returns>List of commands generated</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator.GetSourceStructure(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Gets the structure of a source
            </summary>
      <param name="Source">Source information</param>
      <returns>The source structure</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator.SourceExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a source exists
            </summary>
      <param name="Source">Source to check</param>
      <param name="Info">Source info</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator.StoredProcedureExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a stored procedure exists
            </summary>
      <param name="StoredProcedure">Stored procedure to check</param>
      <param name="Source">Source information</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator.TableExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a table exists
            </summary>
      <param name="Table">Table to check</param>
      <param name="Source">Source information</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator.TriggerExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a trigger exists
            </summary>
      <param name="Trigger">Trigger to check</param>
      <param name="Source">Source information</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator.ViewExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a view exists
            </summary>
      <param name="View">View to check</param>
      <param name="Source">Source information</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator.Bootstrapper">
      <summary>
            IoC container
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ISchemaGenerator.ProviderName">
      <summary>
            Provider name associated with the schema generator
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GenerateSchema(Utilities.ORM.Manager.Schema.Interfaces.ISource,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Generates a list of commands used to modify the source. If it does not exist prior, the
            commands will create the source from scratch. Otherwise the commands will only add new
            fields, tables, etc. It does not delete old fields.
            </summary>
      <param name="DesiredStructure">Desired source structure</param>
      <param name="Source">Source to use</param>
      <returns>List of commands generated</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetSourceStructure(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Gets the structure of a source
            </summary>
      <param name="Source">Source to use</param>
      <returns>The source structure</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.SourceExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a source exists
            </summary>
      <param name="Source">Source to check</param>
      <param name="Info">Source info to use</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.StoredProcedureExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a stored procedure exists
            </summary>
      <param name="StoredProcedure">Stored procedure to check</param>
      <param name="Source">Source to use</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.TableExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a table exists
            </summary>
      <param name="Table">Table to check</param>
      <param name="Source">Source to use</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.TriggerExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a trigger exists
            </summary>
      <param name="Trigger">Trigger to check</param>
      <param name="Source">Source to use</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.ViewExists(System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Checks if a view exists
            </summary>
      <param name="View">View to check</param>
      <param name="Source">Source to use</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.Bootstrapper">
      <summary>
            IoC container
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.ProviderName">
      <summary>
            Provider name associated with the schema generator
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.Provider">
      <summary>
            Query provider object
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.SourceProvider">
      <summary>
            Source provider object
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Default.Database.StoredProcedure">
      <summary>
            StoredProcedure class
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.StoredProcedure.#ctor(System.String,System.String,Utilities.ORM.Manager.Schema.Interfaces.ISource)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
      <param name="Source">Source</param>
      <param name="Definition">Definition of the stored procedure</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.StoredProcedure.AddColumn``1(System.String,System.Data.DbType,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,``0,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Adds a column
            </summary>
      <param name="ColumnName">Column Name</param>
      <param name="ColumnType">Data type</param>
      <param name="Length">Data length</param>
      <param name="Nullable">Nullable?</param>
      <param name="Identity">Identity?</param>
      <param name="Index">Index?</param>
      <param name="PrimaryKey">Primary key?</param>
      <param name="Unique">Unique?</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
      <param name="DefaultValue">Default value</param>
      <param name="OnDeleteCascade">On Delete Cascade</param>
      <param name="OnUpdateCascade">On Update Cascade</param>
      <param name="OnDeleteSetNull">On Delete Set Null</param>
      <typeparam name="T">Column type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.StoredProcedure.AddForeignKey(System.String,System.String,System.String)">
      <summary>
            Adds a foreign key
            </summary>
      <param name="ColumnName">Column name</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.StoredProcedure.AddTrigger(System.String,System.String,Utilities.ORM.Manager.Schema.Enums.TriggerType)">
      <summary>
            Adds a trigger to the table
            </summary>
      <param name="Name">Name of the trigger</param>
      <param name="Definition">Definition of the trigger</param>
      <param name="Type">Trigger type</param>
      <returns>The trigger specified</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.StoredProcedure.Definition">
      <summary>
            Definition of the stored procedure
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Default.Database.Table">
      <summary>
            Table class
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Table.#ctor(System.String,Utilities.ORM.Manager.Schema.Interfaces.ISource)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
      <param name="Source">Source</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Table.AddColumn``1(System.String,System.Data.DbType,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,``0,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Adds a column
            </summary>
      <param name="ColumnName">Column Name</param>
      <param name="ColumnType">Data type</param>
      <param name="Length">Data length</param>
      <param name="Nullable">Nullable?</param>
      <param name="Identity">Identity?</param>
      <param name="Index">Index?</param>
      <param name="PrimaryKey">Primary key?</param>
      <param name="Unique">Unique?</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
      <param name="DefaultValue">Default value</param>
      <param name="OnDeleteCascade">On Delete Cascade</param>
      <param name="OnUpdateCascade">On Update Cascade</param>
      <param name="OnDeleteSetNull">On Delete Set Null</param>
      <typeparam name="T">Column type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Table.AddForeignKey(System.String,System.String,System.String)">
      <summary>
            Adds a foreign key
            </summary>
      <param name="ColumnName">Column name</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Table.AddTrigger(System.String,System.String,Utilities.ORM.Manager.Schema.Enums.TriggerType)">
      <summary>
            Adds a trigger to the table
            </summary>
      <param name="Name">Name of the trigger</param>
      <param name="Definition">Definition of the trigger</param>
      <param name="Type">Trigger type</param>
      <returns>The trigger specified</returns>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Default.Database.Trigger">
      <summary>
            Trigger class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Interfaces.ITrigger">
      <summary>
            Trigger interface
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ITrigger.Definition">
      <summary>
            Definition
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ITrigger.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ITrigger.ParentTable">
      <summary>
            Parent table
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Interfaces.ITrigger.Type">
      <summary>
            Trigger type
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.Trigger.#ctor(System.String,System.String,Utilities.ORM.Manager.Schema.Enums.TriggerType,Utilities.ORM.Manager.Schema.Interfaces.ITable)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
      <param name="Definition">Definition</param>
      <param name="Type">Type</param>
      <param name="ParentTable">Parent table</param>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Trigger.Definition">
      <summary>
            Definition of the trigger
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Trigger.Name">
      <summary>
            Name of the trigger
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Trigger.ParentTable">
      <summary>
            Parent table
            </summary>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.Trigger.Type">
      <summary>
            Trigger type
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Default.Database.View">
      <summary>
            View class
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.View.#ctor(System.String,Utilities.ORM.Manager.Schema.Interfaces.ISource)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
      <param name="Source">Source</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.View.AddColumn``1(System.String,System.Data.DbType,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,``0,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Adds a column
            </summary>
      <param name="ColumnName">Column Name</param>
      <param name="ColumnType">Data type</param>
      <param name="Length">Data length</param>
      <param name="Nullable">Nullable?</param>
      <param name="Identity">Identity?</param>
      <param name="Index">Index?</param>
      <param name="PrimaryKey">Primary key?</param>
      <param name="Unique">Unique?</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
      <param name="DefaultValue">Default value</param>
      <param name="OnDeleteCascade">On Delete Cascade</param>
      <param name="OnUpdateCascade">On Update Cascade</param>
      <param name="OnDeleteSetNull">On Delete Set Null</param>
      <typeparam name="T">Column type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.View.AddForeignKey(System.String,System.String,System.String)">
      <summary>
            Adds a foreign key
            </summary>
      <param name="ColumnName">Column name</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.View.AddTrigger(System.String,System.String,Utilities.ORM.Manager.Schema.Enums.TriggerType)">
      <summary>
            Adds a trigger to the table
            </summary>
      <param name="Name">Name of the trigger</param>
      <param name="Definition">Definition of the trigger</param>
      <param name="Type">Trigger type</param>
      <returns>The trigger specified</returns>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Default.Database.View.Definition">
      <summary>
            Definition of the view
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Enums.TriggerType">
      <summary>
            The type of trigger
            </summary>
    </member>
    <member name="F:Utilities.ORM.Manager.Schema.Enums.TriggerType.Insert">
      <summary>
            Insert
            </summary>
    </member>
    <member name="F:Utilities.ORM.Manager.Schema.Enums.TriggerType.Update">
      <summary>
            Update
            </summary>
    </member>
    <member name="F:Utilities.ORM.Manager.Schema.Enums.TriggerType.Delete">
      <summary>
            Delete
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Manager">
      <summary>
            Schema manager
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Manager.#ctor(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Manager.GenerateSchema(Utilities.ORM.Manager.Schema.Interfaces.ISource,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <summary>
            Generates a list of commands used to modify the source. If it does not exist prior, the
            commands will create the source from scratch. Otherwise the commands will only add new
            fields, tables, etc. It does not delete old fields.
            </summary>
      <param name="DesiredStructure">Desired source structure</param>
      <param name="Source">Source to use</param>
      <returns>List of commands generated</returns>
      <requires description="Source" exception="T:System.ArgumentNullException" csharp="Source != null" vb="Source &lt;&gt; Nothing">Source != null</requires>
      <exception cref="T:System.ArgumentNullException">Source == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Manager.ToString">
      <summary>
            Outputs the schema generator information as a string
            </summary>
      <returns>The schema generator information as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Manager.SchemaGenerators">
      <summary>
            Schema generators
            </summary>
    </member>
    <member name="T:Utilities.ORM.Manager.Schema.Module.SchemaModule">
      <summary>
            Schema module
            </summary>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Module.SchemaModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.ORM.Manager.Schema.Module.SchemaModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.ORM.Parameters.NotEqualParameter`1">
      <summary>
            Parameter class that checks for inequality
            </summary>
      <typeparam name="DataType">Type of the parameter</typeparam>
    </member>
    <member name="M:Utilities.ORM.Parameters.NotEqualParameter`1.#ctor(`0,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">
            What the database expects as the parameter starting string ("@" for SQL Server, ":" for
            Oracle, etc.)
            </param>
    </member>
    <member name="M:Utilities.ORM.Parameters.NotEqualParameter`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.NotEqualParameter`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Parameters.NotEqualParameter`1.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.ORM.Parameters.OrParameter">
      <summary>
            Parameter class that ORs two other parameters together
            </summary>
    </member>
    <member name="M:Utilities.ORM.Parameters.OrParameter.#ctor(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Parameters.OrParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.OrParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Parameters.OrParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Parameters.OrParameter.Left">
      <summary>
            Left parameter
            </summary>
    </member>
    <member name="P:Utilities.ORM.Parameters.OrParameter.Right">
      <summary>
            Right parameter
            </summary>
    </member>
    <member name="T:Utilities.ORM.Parameters.StringEqualParameter">
      <summary>
            Parameter class handling strings
            </summary>
    </member>
    <member name="M:Utilities.ORM.Parameters.StringEqualParameter.#ctor(System.String,System.String,System.Int32,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">
            What the database expects as the parameter starting string ("@" for SQL Server, ":" for
            Oracle, etc.)
            </param>
      <param name="Length">Max length allowed for the string</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.StringEqualParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.StringEqualParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Parameters.StringEqualParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Parameters.StringEqualParameter.Length">
      <summary>
            Max length of the string
            </summary>
    </member>
    <member name="T:Utilities.ORM.Parameters.StringNotEqualParameter">
      <summary>
            Parameter class handling strings, checking for inequality
            </summary>
    </member>
    <member name="M:Utilities.ORM.Parameters.StringNotEqualParameter.#ctor(System.String,System.String,System.Int32,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">
            What the database expects as the parameter starting string ("@" for SQL Server, ":" for
            Oracle, etc.)
            </param>
      <param name="Length">Max length allowed for the string</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.StringNotEqualParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.ORM.Parameters.StringNotEqualParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Parameters.StringNotEqualParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.ORM.Parameters.StringNotEqualParameter.Length">
      <summary>
            Max length of the string
            </summary>
    </member>
    <member name="T:Utilities.ORM.QueryProvider">
      <summary>
            Query provider
            </summary>
    </member>
    <member name="M:Utilities.ORM.QueryProvider.All``1(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Returns all objects based on the parameters provided
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Parameters">Parameters</param>
      <returns>The list of objects requested</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProvider.Any``1(Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Returns an object based on the parameters provided
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Parameters">Parameters</param>
      <returns>An object requested</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProvider.Batch(System.String)">
      <summary>
            Creates a batch object that can be used to run ad hoc queries
            </summary>
      <param name="ConnectionString">
            Connection string (can be the name of connection string in config file or the actual
            connection string)
            </param>
      <returns>An appropriate batch object</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProvider.Delete``1(``0)">
      <summary>
            Deletes an object
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Object">Object to delete</param>
    </member>
    <member name="M:Utilities.ORM.QueryProvider.PageCount``1(System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Gets the page count based on the page size specified
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameters</param>
      <returns>The number of pages</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProvider.Paged``1(System.Int32,System.Int32,Utilities.ORM.Manager.QueryProvider.Interfaces.IParameter[])">
      <summary>
            Gets a specific page of objects
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameters</param>
      <param name="CurrentPage">Current page (0 based)</param>
      <returns>The objects specified</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProvider.Save``2(``0)">
      <summary>
            Saves an object
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="PrimaryKeyType">Primary key type</typeparam>
      <param name="Object">Object</param>
    </member>
    <member name="P:Utilities.ORM.QueryProvider.QueryManager">
      <summary>
            Query manager
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProvider.SourceManager">
      <summary>
            Source manager
            </summary>
    </member>
    <member name="T:Utilities.Profiler.TimerExtensions">
      <summary>
            Holds timing/profiling related extensions
            </summary>
    </member>
    <member name="M:Utilities.Profiler.TimerExtensions.Time(System.Action,System.String)">
      <summary>
            Times an action and places
            </summary>
      <param name="ActionToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
    </member>
    <member name="M:Utilities.Profiler.TimerExtensions.Time``1(System.Action{``0},``0,System.String)">
      <summary>
            Times an action and places
            </summary>
      <typeparam name="T">Action input type</typeparam>
      <param name="ActionToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
    </member>
    <member name="M:Utilities.Profiler.TimerExtensions.Time``2(System.Action{``0,``1},``0,``1,System.String)">
      <summary>
            Times an action and places
            </summary>
      <typeparam name="T1">Action input type 1</typeparam>
      <typeparam name="T2">Action input type 2</typeparam>
      <param name="ActionToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <param name="Object2">Object 2</param>
    </member>
    <member name="M:Utilities.Profiler.TimerExtensions.Time``3(System.Action{``0,``1,``2},``0,``1,``2,System.String)">
      <summary>
            Times an action and places
            </summary>
      <typeparam name="T1">Action input type 1</typeparam>
      <typeparam name="T2">Action input type 2</typeparam>
      <typeparam name="T3">Action input type 3</typeparam>
      <param name="ActionToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <param name="Object2">Object 2</param>
      <param name="Object3">Object 3</param>
    </member>
    <member name="M:Utilities.Profiler.TimerExtensions.Time``1(System.Func{``0},System.String)">
      <summary>
            Times an action and places
            </summary>
      <param name="FuncToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <typeparam name="R">Type of the value to return</typeparam>
      <returns>The value returned by the Func</returns>
    </member>
    <member name="M:Utilities.Profiler.TimerExtensions.Time``2(System.Func{``0,``1},``0,System.String)">
      <summary>
            Times an action and places
            </summary>
      <param name="FuncToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <typeparam name="T1">Object type 1</typeparam>
      <typeparam name="R">Type of the value to return</typeparam>
      <returns>The value returned by the Func</returns>
    </member>
    <member name="M:Utilities.Profiler.TimerExtensions.Time``3(System.Func{``0,``1,``2},``0,``1,System.String)">
      <summary>
            Times an action and places
            </summary>
      <param name="FuncToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <param name="Object2">Object 2</param>
      <typeparam name="T1">Object type 1</typeparam>
      <typeparam name="T2">Object type 2</typeparam>
      <typeparam name="R">Type of the value to return</typeparam>
      <returns>The value returned by the Func</returns>
    </member>
    <member name="M:Utilities.Profiler.TimerExtensions.Time``4(System.Func{``0,``1,``2,``3},``0,``1,``2,System.String)">
      <summary>
            Times an action and places
            </summary>
      <param name="FuncToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <param name="Object2">Object 2</param>
      <param name="Object3">Object 3</param>
      <typeparam name="T1">Object type 1</typeparam>
      <typeparam name="T2">Object type 2</typeparam>
      <typeparam name="T3">Object type 3</typeparam>
      <typeparam name="R">Type of the value to return</typeparam>
      <returns>The value returned by the Func</returns>
    </member>
    <member name="T:Utilities.Profiler.Manager.Default.Profiler">
      <summary>
            Object class used to profile a function. Create at the beginning of a function in a using
            statement and it will automatically record the time. Note that this isn't exact and is based
            on when the object is destroyed
            </summary>
    </member>
    <member name="T:Utilities.Profiler.Manager.Interfaces.IProfiler">
      <summary>
            Profiler interface
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Interfaces.IProfiler.Profile(System.String)">
      <summary>
            Starts profiling, saving the information to the name specified
            </summary>
      <param name="Name">Name of the profiler</param>
      <returns>IDisposable that will stop the profiler when disposed of</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Interfaces.IProfiler.StartProfiling">
      <summary>
            Starts profiling
            </summary>
      <returns>Starts profiling</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Interfaces.IProfiler.StopProfiling">
      <summary>
            Stops profiling and returns the information captured
            </summary>
      <returns>The results from the profiling</returns>
    </member>
    <member name="T:Utilities.Profiler.Manager.Interfaces.IResult">
      <summary>
            Profiler results interface
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Interfaces.IResult.CalledFrom">
      <summary>
            Where the profiler was started at
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Interfaces.IResult.Children">
      <summary>
            Any child results (Key = Name/Identifier, Value = IResult object)
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Interfaces.IResult.Times">
      <summary>
            Total time that the profiler has taken (in milliseconds)
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FunctionName">Function/identifier</param>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.op_Inequality(Utilities.Profiler.Manager.Default.Profiler,Utilities.Profiler.Manager.Default.Profiler)">
      <summary>
            Compares the profilers and determines if they are not equal
            </summary>
      <param name="First">First</param>
      <param name="Second">Second</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.op_Equality(Utilities.Profiler.Manager.Default.Profiler,Utilities.Profiler.Manager.Default.Profiler)">
      <summary>
            Compares the profilers and determines if they are equal
            </summary>
      <param name="First">First</param>
      <param name="Second">Second</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.Dispose">
      <summary>
            Disposes the object
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.Equals(System.Object)">
      <summary>
            Equals
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.GetHashCode">
      <summary>
            Gets the hash code for the profiler
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.Profile(System.String)">
      <summary>
            Creates a profiler object and starts profiling
            </summary>
      <param name="Name">Function name</param>
      <returns>An IDisposable that is used to stop profiling</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.Start">
      <summary>
            Starts the timer
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.StartProfiling">
      <summary>
            Starts profiling
            </summary>
      <returns>The root profiler</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.Stop">
      <summary>
            Stops the timer and registers the information
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.StopProfiling">
      <summary>
            Stops profiling
            </summary>
      <returns>The root profiler</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.ToString">
      <summary>
            Outputs the information to a table
            </summary>
      <returns>an html string containing the information</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">
            True to dispose of all resources, false only disposes of native resources
            </param>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.Profiler.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.Current">
      <summary>
            Contains the current profiler
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.Root">
      <summary>
            Contains the root profiler
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.CalledFrom">
      <summary>
            Where the profiler was started at
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.Children">
      <summary>
            Children result items
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.Function">
      <summary>
            Function name
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.InternalChildren">
      <summary>
            Children profiler items
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.Times">
      <summary>
            Total time that the profiler has taken (in milliseconds)
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.Level">
      <summary>
            Level of the profiler
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.Parent">
      <summary>
            Parent profiler item
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.Running">
      <summary>
            Determines if it is running
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.Profiler.StopWatch">
      <summary>
            Stop watch
            </summary>
    </member>
    <member name="T:Utilities.Profiler.Manager.Default.StopWatch">
      <summary>
            Acts as a stop watch (records start and stop times)
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.StopWatch.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.StopWatch.Reset">
      <summary>
            Resets the watch
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.StopWatch.Start">
      <summary>
            Starts the stop watch
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Default.StopWatch.Stop">
      <summary>
            Stops the stop watch
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.StopWatch.ElapsedTime">
      <summary>
            Returns the elapsed time
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Manager.Default.StopWatch.Watch">
      <summary>
            Internal stop watch
            </summary>
    </member>
    <member name="T:Utilities.Profiler.Manager.Manager">
      <summary>
            Profiler manager
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Manager.Profile(System.String)">
      <summary>
            Starts the profiler and uses the name specified
            </summary>
      <param name="Name">Name of the entry</param>
      <returns>An IDisposable object that will stop the profiler when disposed of</returns>
    </member>
    <member name="M:Utilities.Profiler.Manager.Manager.ToString">
      <summary>
            Outputs the profiler information as a string
            </summary>
      <returns>The profiler information as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Profiler.Manager.Manager.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">
            Determines if all objects should be disposed or just managed objects
            </param>
    </member>
    <member name="P:Utilities.Profiler.Manager.Manager.Profiler">
      <summary>
            Root profiler object
            </summary>
    </member>
    <member name="T:Utilities.Profiler.Manager.Module.ProfilerModule">
      <summary>
            Profiler module
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Manager.Module.ProfilerModule.Load(Utilities.IoC.Interfaces.IBootstrapper)">
      <summary>
            Loads the module
            </summary>
      <param name="Bootstrapper">Bootstrapper to register with</param>
    </member>
    <member name="P:Utilities.Profiler.Manager.Module.ProfilerModule.Order">
      <summary>
            Order to run it in
            </summary>
    </member>
    <member name="T:Utilities.Profiler.Profiler">
      <summary>
            Profiler object
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Profiler.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FunctionName">Function name</param>
    </member>
    <member name="M:Utilities.Profiler.Profiler.ToString">
      <summary>
            ToString
            </summary>
      <returns>String equivalent of the info held by the profiler</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Profiler.Profiler.Dispose(System.Boolean)">
      <summary>
            Dispose function
            </summary>
      <param name="Managed">Is it managed or not</param>
    </member>
    <member name="P:Utilities.Profiler.Profiler.ProfilerObject">
      <summary>
            Profiler Object
            </summary>
    </member>
    <member name="T:Utilities.Random.BaseClasses.GeneratorAttributeBase">
      <summary>
            Attribute base class for generators
            </summary>
    </member>
    <member name="T:Utilities.Random.Interfaces.IGenerator">
      <summary>
            Generator interface
            </summary>
    </member>
    <member name="M:Utilities.Random.Interfaces.IGenerator.NextObj(System.Random)">
      <summary>
            Generates a random value and returns it as an object
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object</returns>
    </member>
    <member name="M:Utilities.Random.BaseClasses.GeneratorAttributeBase.#ctor(System.Object,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Minimum value</param>
      <param name="Max">Maximum value</param>
    </member>
    <member name="M:Utilities.Random.BaseClasses.GeneratorAttributeBase.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.BaseClasses.GeneratorAttributeBase.Max">
      <summary>
            Maximum allowed
            </summary>
    </member>
    <member name="P:Utilities.Random.BaseClasses.GeneratorAttributeBase.Min">
      <summary>
            Minimum allowed
            </summary>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.AddressGenerator">
      <summary>
            Generates a random address
            </summary>
    </member>
    <member name="T:Utilities.Random.Interfaces.IGenerator`1">
      <summary>
            Generator interface
            </summary>
      <typeparam name="T">Type it generates</typeparam>
    </member>
    <member name="M:Utilities.Random.Interfaces.IGenerator`1.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.Interfaces.IGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.AddressGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.AddressGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.AddressGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.AddressGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.CityGenerator">
      <summary>
            Generates a random city
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.CityGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.CityGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.CityGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.CityGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.DomainNameGenerator">
      <summary>
            Generates a random domain name
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.#ctor(System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="CommonEndings">
            Common endings to domain names should be used (.com,.org,.net,etc.)
            </param>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.CommonEndings">
      <summary>
            Should common domain name endings be used
            </summary>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator">
      <summary>
            Generates a random email address
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.#ctor(System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="CommonEndings">
            Common endings to domain names should be used (.com,.org,.net,etc.)
            </param>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.CommonEndings">
      <summary>
            Should common domain name endings be used?
            </summary>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.PhoneNumberGenerator">
      <summary>
            Generates a random phone number
            </summary>
    </member>
    <member name="T:Utilities.Random.StringGenerators.PatternGenerator">
      <summary>
            Randomly generates strings based on a pattern
            </summary>
    </member>
    <member name="M:Utilities.Random.StringGenerators.PatternGenerator.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Pattern">Pattern to use: # = Number @ = Alpha character</param>
    </member>
    <member name="M:Utilities.Random.StringGenerators.PatternGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.PatternGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.PatternGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.StringGenerators.PatternGenerator.Pattern">
      <summary>
            Pattern to use
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.PhoneNumberGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator">
      <summary>
            Generates a random state abbreviation
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.StateGenerator">
      <summary>
            Generates a random state
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator">
      <summary>
            Generates a random street address
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.ZipCodeGenerator">
      <summary>
            Generates a random zip code
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.ZipCodeGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.BoolGenerator">
      <summary>
            Randomly generates bools
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.BoolGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.BoolGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.BoolGenerator.Next(System.Random,System.Boolean,System.Boolean)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.BoolGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ClassGenerator`1">
      <summary>
            Randomly generates a class
            </summary>
      <typeparam name="T">Class type to generate</typeparam>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ClassGenerator`1.Next(System.Random)">
      <summary>
            Generates a random version of the class
            </summary>
      <param name="Rand">Random generator to use</param>
      <returns>The randomly generated class</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ClassGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random version of the class
            </summary>
      <param name="Rand">Random generator to use</param>
      <param name="Min">Min value (not used)</param>
      <param name="Max">Max value (not used)</param>
      <returns>The randomly generated class</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ClassGenerator`1.NextObj(System.Random)">
      <summary>
            Gets a random version of the class
            </summary>
      <param name="Rand">Random generator used</param>
      <returns>The randonly generated class</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ColorGenerator">
      <summary>
            Randomly generates Colors
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ColorGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ColorGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ColorGenerator.Next(System.Random,System.Drawing.Color,System.Drawing.Color)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ColorGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.DateTimeGenerator">
      <summary>
            Randomly generates DateTimes
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DateTimeGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DateTimeGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DateTimeGenerator.Next(System.Random,System.DateTime,System.DateTime)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DateTimeGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.DecimalGenerator`1">
      <summary>
            Randomly generates decimals
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator`1.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator`1.NextObj(System.Random)">
      <summary>
            Randomly generates an object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>A randomly generated object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.DecimalGenerator">
      <summary>
            Decimal generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator.#ctor(System.Decimal,System.Decimal)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.DoubleGenerator">
      <summary>
            Double generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DoubleGenerator.#ctor(System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DoubleGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DoubleGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.FloatGenerator">
      <summary>
            Float generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.FloatGenerator.#ctor(System.Single,System.Single)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.FloatGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.FloatGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.EnumGenerator`1">
      <summary>
            Randomly generates Enum
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.EnumGenerator`1.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.EnumGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.EnumGenerator`1.NextObj(System.Random)">
      <summary>
            Randomly generates an object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>A randomly generated object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.IntegerGenerator`1">
      <summary>
            Randomly generates ints
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntegerGenerator`1.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntegerGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntegerGenerator`1.NextObj(System.Random)">
      <summary>
            Randomly generates an object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>A randomly generated object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ByteGenerator">
      <summary>
            Byte generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ByteGenerator.#ctor(System.Byte,System.Byte)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ByteGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ByteGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.CharGenerator">
      <summary>
            Char generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.CharGenerator.#ctor(System.Char,System.Char)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.CharGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.CharGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.IntGenerator">
      <summary>
            Int generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntGenerator.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.LongGenerator">
      <summary>
            Long generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.LongGenerator.#ctor(System.Int64,System.Int64)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.LongGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.LongGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.SByteGenerator">
      <summary>
            sbyte generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.SByteGenerator.#ctor(System.SByte,System.SByte)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.SByteGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.SByteGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ShortGenerator">
      <summary>
            Short generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ShortGenerator.#ctor(System.Int16,System.Int16)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ShortGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ShortGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.UIntGenerator">
      <summary>
            uint generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UIntGenerator.#ctor(System.UInt32,System.UInt32)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UIntGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UIntGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ULongGenerator">
      <summary>
            ulong generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ULongGenerator.#ctor(System.UInt64,System.UInt64)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ULongGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ULongGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.UShortGenerator">
      <summary>
            ushort generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UShortGenerator.#ctor(System.UInt16,System.UInt16)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UShortGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UShortGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.StringGenerator">
      <summary>
            Randomly generates strings
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.NextString(System.Random,System.Int32,System.String,System.Int32)">
      <summary>
            Returns a randomly generated string of a specified length, containing only a set of
            characters, and at max a specified number of non alpha numeric characters.
            </summary>
      <param name="Length">Length of the string</param>
      <param name="AllowedCharacters">Characters allowed in the string</param>
      <param name="NumberOfNonAlphaNumericsAllowed">
            Number of non alpha numeric characters allowed.
            </param>
      <param name="Rand">Random number generator</param>
      <returns>
            A randomly generated string of a specified length, containing only a set of characters,
            and at max a specified number of non alpha numeric characters.
            </returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.TimeSpanGenerator">
      <summary>
            Randomly generates TimeSpans
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.TimeSpanGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.TimeSpanGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.TimeSpanGenerator.Next(System.Random,System.TimeSpan,System.TimeSpan)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.TimeSpanGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.RandomExtensions">
      <summary>
            Extension methods for the Random class
            </summary>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.Next``1(System.Random,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a value of the specified type
            </summary>
      <typeparam name="T">Type to generate</typeparam>
      <param name="Random">Random object</param>
      <param name="Generator">
            Generator to be used (if not included, default generator is used)
            </param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="Random != null" vb="Random &lt;&gt; Nothing">Random != null</requires>
      <exception cref="T:System.ArgumentNullException">Random == null</exception>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.Next``1(System.Random,``0,``0,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a value of the specified type
            </summary>
      <typeparam name="T">Type to generate</typeparam>
      <param name="Random">Random object</param>
      <param name="Max">Maximum value (inclusive)</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Generator">
            Generator to be used (if not included, default generator is used)
            </param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="Random != null" vb="Random &lt;&gt; Nothing">Random != null</requires>
      <exception cref="T:System.ArgumentNullException">Random == null</exception>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.Next``1(System.Random,System.Int32,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a list of values of the specified type
            </summary>
      <typeparam name="T">Type to the be generated</typeparam>
      <param name="Random">Random object</param>
      <param name="Amount">Number of items to generate</param>
      <param name="Generator">
            Generator to be used (if not included, default generator is used)
            </param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){&#xD;&#xA;    Random = Random, &#xD;&#xA;    Generator = Generator, &#xD;&#xA;}.Random != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt; local_0_prime = New Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass1(Of T)();&#xD;&#xA;    (local_0_prime.Random = Random)&#xD;&#xA;    (local_0_prime.Generator = Generator)&#xD;&#xA;    return local_0_prime; })().Random &lt;&gt; Nothing">new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random == null</exception>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.Next``1(System.Random,System.Int32,``0,``0,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a list of values of the specified type
            </summary>
      <typeparam name="T">Type to the be generated</typeparam>
      <param name="Random">Random object</param>
      <param name="Amount">Number of items to generate</param>
      <param name="Max">Maximum value (inclusive)</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Generator">
            Generator to be used (if not included, default generator is used)
            </param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){&#xD;&#xA;    Random = Random, &#xD;&#xA;    Min = Min, &#xD;&#xA;    Max = Max, &#xD;&#xA;    Generator = Generator, &#xD;&#xA;}.Random != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt; local_0_prime = New Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass4(Of T)();&#xD;&#xA;    (local_0_prime.Random = Random)&#xD;&#xA;    (local_0_prime.Min = Min)&#xD;&#xA;    (local_0_prime.Max = Max)&#xD;&#xA;    (local_0_prime.Generator = Generator)&#xD;&#xA;    return local_0_prime; })().Random &lt;&gt; Nothing">new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){
    Random = Random, 
    Min = Min, 
    Max = Max, 
    Generator = Generator, 
}.Random != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){
    Random = Random, 
    Min = Min, 
    Max = Max, 
    Generator = Generator, 
}.Random == null</exception>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.Next``1(System.Random,System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Picks a random item from the list
            </summary>
      <typeparam name="T">Type of object in the list</typeparam>
      <param name="Random">Random number generator</param>
      <param name="List">List to pick from</param>
      <returns>Item that is returned</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="Random != null" vb="Random &lt;&gt; Nothing">Random != null</requires>
      <exception cref="T:System.ArgumentNullException">Random == null</exception>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.NextClass``1(System.Random,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a value of the specified type
            </summary>
      <typeparam name="T">Type to generate</typeparam>
      <param name="Random">Random object</param>
      <param name="Generator">
            Generator to be used (if not included, default generator is used)
            </param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="Random != null" vb="Random &lt;&gt; Nothing">Random != null</requires>
      <exception cref="T:System.ArgumentNullException">Random == null</exception>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.NextClass``1(System.Random,System.Int32,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a list of values of the specified type
            </summary>
      <typeparam name="T">Type to the be generated</typeparam>
      <param name="Random">Random object</param>
      <param name="Amount">Number of items to generate</param>
      <param name="Generator">
            Generator to be used (if not included, default generator is used)
            </param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){&#xD;&#xA;    Random = Random, &#xD;&#xA;    Generator = Generator, &#xD;&#xA;}.Random != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt; local_0_prime = New Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass7(Of T)();&#xD;&#xA;    (local_0_prime.Random = Random)&#xD;&#xA;    (local_0_prime.Generator = Generator)&#xD;&#xA;    return local_0_prime; })().Random &lt;&gt; Nothing">new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random == null</exception>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.NextEnum``1(System.Random,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a value of the specified enum type
            </summary>
      <typeparam name="T">Type to generate</typeparam>
      <param name="Random">Random object</param>
      <param name="Generator">
            Generator to be used (if not included, default generator is used)
            </param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="Random != null" vb="Random &lt;&gt; Nothing">Random != null</requires>
      <exception cref="T:System.ArgumentNullException">Random == null</exception>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.NextEnum``1(System.Random,System.Int32,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a list of values of the specified enum type
            </summary>
      <typeparam name="T">Type to the be generated</typeparam>
      <param name="Random">Random object</param>
      <param name="Amount">Number of items to generate</param>
      <param name="Generator">
            Generator to be used (if not included, default generator is used)
            </param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt;(){&#xD;&#xA;    Random = Random, &#xD;&#xA;    Generator = Generator, &#xD;&#xA;}.Random != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt; local_0_prime = New Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClassa(Of T)();&#xD;&#xA;    (local_0_prime.Random = Random)&#xD;&#xA;    (local_0_prime.Generator = Generator)&#xD;&#xA;    return local_0_prime; })().Random &lt;&gt; Nothing">new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Random.RandomExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random == null</exception>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.RegisterGenerator``1(System.Random,Utilities.Random.Interfaces.IGenerator)">
      <summary>
            Registers a generator with a type
            </summary>
      <typeparam name="T">Type to associate with the generator</typeparam>
      <param name="Rand">Random number generator</param>
      <param name="Generator">Generator to associate with the type</param>
      <returns>The random number generator</returns>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.RegisterGenerator(System.Random,System.Type,Utilities.Random.Interfaces.IGenerator)">
      <summary>
            Registers a generator with a type
            </summary>
      <param name="Rand">Random number generator</param>
      <param name="Generator">Generator to associate with the type</param>
      <param name="Type">Type to associate with the generator</param>
      <returns>The random number generator</returns>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.ResetGenerators(System.Random)">
      <summary>
            Resets the generators to the defaults
            </summary>
      <param name="Random">Random object</param>
      <returns>The random object sent in</returns>
    </member>
    <member name="M:Utilities.Random.RandomExtensions.Shuffle``1(System.Random,System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Shuffles a list randomly
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Random">Random object</param>
      <param name="List">List of objects to shuffle</param>
      <returns>The shuffled list</returns>
    </member>
    <member name="T:Utilities.Random.Interfaces.IStringGenerator">
      <summary>
            String generator interface
            </summary>
    </member>
    <member name="M:Utilities.Random.Interfaces.IStringGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.CompanyGenerator">
      <summary>
            Company name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.CompanyGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.CompanyGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.CompanyGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.CompanyGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.FemaleFirstNameGenerator">
      <summary>
            Female first name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleFirstNameGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleFirstNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleFirstNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleFirstNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.FemaleNameGenerator">
      <summary>
            Female name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNameGenerator.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="Prefix">Should a prefix be generated</param>
      <param name="MiddleName">Should a middle name be generated</param>
      <param name="LastName">Should a last name be generated</param>
      <param name="Suffix">Should a suffix be generated</param>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.NameGenerators.FemaleNameGenerator.LastName">
      <summary>
            Should a last name be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.FemaleNameGenerator.MiddleName">
      <summary>
            Should a middle name be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.FemaleNameGenerator.Prefix">
      <summary>
            Should a prefix be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.FemaleNameGenerator.Suffix">
      <summary>
            Should a suffix be generated?
            </summary>
    </member>
    <member name="T:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator">
      <summary>
            Female name prefix generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.LastNameGenerator">
      <summary>
            Last name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.LastNameGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.LastNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.LastNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.LastNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.MaleFirstNameGenerator">
      <summary>
            Male first name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleFirstNameGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleFirstNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleFirstNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleFirstNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.MaleNameGenerator">
      <summary>
            Male name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNameGenerator.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="Prefix">Should a prefix be generated</param>
      <param name="MiddleName">Should a middle name be generated</param>
      <param name="LastName">Should a last name be generated</param>
      <param name="Suffix">Should a suffix be generated</param>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.NameGenerators.MaleNameGenerator.LastName">
      <summary>
            Should a last name be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.MaleNameGenerator.MiddleName">
      <summary>
            Should a middle name be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.MaleNameGenerator.Prefix">
      <summary>
            Should a prefix be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.MaleNameGenerator.Suffix">
      <summary>
            Should a suffix be generated?
            </summary>
    </member>
    <member name="T:Utilities.Random.NameGenerators.MaleNamePrefixGenerator">
      <summary>
            Male name prefix generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNamePrefixGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNamePrefixGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNamePrefixGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNamePrefixGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.NameGenerator">
      <summary>
            Name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameGenerator.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="Prefix">Should a prefix be generated</param>
      <param name="MiddleName">Should a middle name be generated</param>
      <param name="LastName">Should a last name be generated</param>
      <param name="Suffix">Should a suffix be generated</param>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.NameGenerators.NameGenerator.LastName">
      <summary>
            Should a last name be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.NameGenerator.MiddleName">
      <summary>
            Should a middle name be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.NameGenerator.Prefix">
      <summary>
            Should a prefix be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.NameGenerator.Suffix">
      <summary>
            Should a suffix be generated?
            </summary>
    </member>
    <member name="T:Utilities.Random.NameGenerators.NameSuffixGenerator">
      <summary>
            Name suffix generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameSuffixGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameSuffixGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameSuffixGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameSuffixGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.Random">
      <summary>
            Utility class for handling random information.
            </summary>
    </member>
    <member name="M:Utilities.Random.Random.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.Random.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Seed">Seed value</param>
    </member>
    <member name="M:Utilities.Random.Random.ThreadSafeNext(System.Int32,System.Int32)">
      <summary>
            A thread safe version of a random number generation
            </summary>
      <param name="Min">Minimum value</param>
      <param name="Max">Maximum value</param>
      <returns>A randomly generated value</returns>
      <requires exception="T:System.ArgumentException" csharp="Min &lt;= Max" vb="Min &lt;= Max">Min &lt;= Max</requires>
      <exception cref="T:System.ArgumentException">Min &gt; Max</exception>
    </member>
    <member name="T:Utilities.Random.StringGenerators.LoremIpsumGenerator">
      <summary>
            Lorem Ipsum Generator
            </summary>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="NumberOfParagraphs">Number of paragraphs</param>
      <param name="MaxSentenceLength">Maximum sentence length</param>
      <param name="MinSentenceLength">Minimum sentence length</param>
      <param name="NumberOfSentences">Number of sentences per paragraph</param>
      <param name="HTMLFormatting">Determines if this should use HTML formatting or not</param>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.NextSentence(System.Random,System.Int32)">
      <summary>
            Creates a Lorem Ipsum sentence.
            </summary>
      <param name="NumberOfWords">Number of words for the sentence</param>
      <param name="Rand">Random number generator using</param>
      <returns>A string containing Lorem Ipsum text</returns>
      <requires description="Rand" exception="T:System.ArgumentNullException" csharp="Rand != null" vb="Rand &lt;&gt; Nothing">Rand != null</requires>
      <exception cref="T:System.ArgumentNullException">Rand == null</exception>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.HTMLFormatting">
      <summary>
            Should the sentence use HTML formatting?
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.MaxSentenceLength">
      <summary>
            Maximum sentence length
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.MinSentenceLength">
      <summary>
            Minimum sentence length
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.NumberOfParagraphs">
      <summary>
            Number of paragraphs
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.NumberOfSentences">
      <summary>
            Number of sentences
            </summary>
    </member>
    <member name="T:Utilities.Random.StringGenerators.RegexStringGenerator">
      <summary>
            Randomly generates strings based on a Regex
            </summary>
    </member>
    <member name="M:Utilities.Random.StringGenerators.RegexStringGenerator.#ctor(System.Int32,System.String,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Length">Length of the string to generate</param>
      <param name="AllowedCharacters">Characters that are allowed</param>
      <param name="NumberOfNonAlphaNumericsAllowed">
            Number of non alphanumeric characters to allow
            </param>
    </member>
    <member name="M:Utilities.Random.StringGenerators.RegexStringGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.RegexStringGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.RegexStringGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.StringGenerators.RegexStringGenerator.AllowedCharacters">
      <summary>
            Characters allowed
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.RegexStringGenerator.Length">
      <summary>
            Length to generate
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.RegexStringGenerator.NumberOfNonAlphaNumericsAllowed">
      <summary>
            Number of non alpha numeric characters allowed
            </summary>
    </member>
    <member name="T:Utilities.Validation.ObjectExtensions">
      <summary>
            Object extensions
            </summary>
    </member>
    <member name="M:Utilities.Validation.ObjectExtensions.TryValidate``1(``0,System.Collections.Generic.ICollection{System.ComponentModel.DataAnnotations.ValidationResult})">
      <summary>
            Determines if the object is valid
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Object">Object to validate</param>
      <param name="Results">Results list</param>
      <returns>True if valid, false otherwise</returns>
    </member>
    <member name="M:Utilities.Validation.ObjectExtensions.Validate``1(``0)">
      <summary>
            Determines if the object is valid
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Object">Object to validate</param>
      <exception cref="T:System.ComponentModel.DataAnnotations.ValidationException" />
    </member>
    <member name="T:Utilities.Validation.BetweenAttribute">
      <summary>
            Between attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.BetweenAttribute.#ctor(System.Object,System.Object,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Max">Max value</param>
      <param name="Min">Min value</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.BetweenAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.BetweenAttribute.GetClientValidationRules(System.Web.Mvc.ModelMetadata,System.Web.Mvc.ControllerContext)">
      <summary>
            Gets the client side validation rules
            </summary>
      <param name="metadata">Model meta data</param>
      <param name="context">Controller context</param>
      <returns>The list of client side validation rules</returns>
    </member>
    <member name="M:Utilities.Validation.BetweenAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.BetweenAttribute.Max">
      <summary>
            Max value to compare to
            </summary>
    </member>
    <member name="P:Utilities.Validation.BetweenAttribute.Min">
      <summary>
            Min value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.CascadeAttribute">
      <summary>
            Cascade attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.CascadeAttribute.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.CascadeAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="T:Utilities.Validation.CompareAttribute">
      <summary>
            Compare attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.CompareAttribute.#ctor(System.Object,Utilities.Validation.ComparisonType,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to compare to</param>
      <param name="Type">Comparison type to use</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.CompareAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.CompareAttribute.GetClientValidationRules(System.Web.Mvc.ModelMetadata,System.Web.Mvc.ControllerContext)">
      <summary>
            Gets the client side validation rules
            </summary>
      <param name="metadata">Model meta data</param>
      <param name="context">Controller context</param>
      <returns>The list of client side validation rules</returns>
    </member>
    <member name="M:Utilities.Validation.CompareAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.CompareAttribute.Type">
      <summary>
            Comparison type
            </summary>
    </member>
    <member name="P:Utilities.Validation.CompareAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.CompareToAttribute">
      <summary>
            CompareTo attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.CompareToAttribute.#ctor(System.String,Utilities.Validation.ComparisonType,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="PropertyName">Property to compare to</param>
      <param name="Type">Comparison type to use</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.CompareToAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.CompareToAttribute.GetClientValidationRules(System.Web.Mvc.ModelMetadata,System.Web.Mvc.ControllerContext)">
      <summary>
            Gets the client side validation rules
            </summary>
      <param name="metadata">Model meta data</param>
      <param name="context">Controller context</param>
      <returns>The list of client side validation rules</returns>
    </member>
    <member name="M:Utilities.Validation.CompareToAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.CompareToAttribute.PropertyName">
      <summary>
            Property to compare to
            </summary>
    </member>
    <member name="P:Utilities.Validation.CompareToAttribute.Type">
      <summary>
            Comparison type
            </summary>
    </member>
    <member name="T:Utilities.Validation.ContainsAttribute">
      <summary>
            Contains attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.ContainsAttribute.#ctor(System.Object,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to check for</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.ContainsAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.ContainsAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.ContainsAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.DoesNotContainAttribute">
      <summary>
            Does not contain attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.DoesNotContainAttribute.#ctor(System.Object,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to check for</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.DoesNotContainAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.DoesNotContainAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.DoesNotContainAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.EmptyAttribute">
      <summary>
            Empty attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.EmptyAttribute.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.EmptyAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.EmptyAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="T:Utilities.Validation.ComparisonType">
      <summary>
            Comparison types
            </summary>
    </member>
    <member name="F:Utilities.Validation.ComparisonType.Equal">
      <summary>
            Equal
            </summary>
    </member>
    <member name="F:Utilities.Validation.ComparisonType.NotEqual">
      <summary>
            Not equal
            </summary>
    </member>
    <member name="F:Utilities.Validation.ComparisonType.GreaterThan">
      <summary>
            Greater than
            </summary>
    </member>
    <member name="F:Utilities.Validation.ComparisonType.GreaterThanOrEqual">
      <summary>
            Greater than or equal
            </summary>
    </member>
    <member name="F:Utilities.Validation.ComparisonType.LessThan">
      <summary>
            Less than
            </summary>
    </member>
    <member name="F:Utilities.Validation.ComparisonType.LessThanOrEqual">
      <summary>
            Less than or equal
            </summary>
    </member>
    <member name="T:Utilities.Validation.IsValid">
      <summary>
            IsValid types
            </summary>
    </member>
    <member name="F:Utilities.Validation.IsValid.CreditCard">
      <summary>
            Credit card
            </summary>
    </member>
    <member name="F:Utilities.Validation.IsValid.Decimal">
      <summary>
            Decimal
            </summary>
    </member>
    <member name="F:Utilities.Validation.IsValid.Domain">
      <summary>
            Domain
            </summary>
    </member>
    <member name="F:Utilities.Validation.IsValid.Integer">
      <summary>
            Integer
            </summary>
    </member>
    <member name="T:Utilities.Validation.IsAttribute">
      <summary>
            Is attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.IsAttribute.#ctor(Utilities.Validation.IsValid,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Type">Validation type enum</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.IsAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.IsAttribute.GetClientValidationRules(System.Web.Mvc.ModelMetadata,System.Web.Mvc.ControllerContext)">
      <summary>
            Gets the client side validation rules
            </summary>
      <param name="metadata">Model meta data</param>
      <param name="context">Controller context</param>
      <returns>The list of client side validation rules</returns>
    </member>
    <member name="M:Utilities.Validation.IsAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.IsAttribute.Type">
      <summary>
            Type of validation to do
            </summary>
    </member>
    <member name="T:Utilities.Validation.MaxLengthAttribute">
      <summary>
            Max length attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.MaxLengthAttribute.#ctor(System.Int64,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to check</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.MaxLengthAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.MaxLengthAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.MaxLengthAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.MinLengthAttribute">
      <summary>
            Min length attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.MinLengthAttribute.#ctor(System.Int64,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to check</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.MinLengthAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.MinLengthAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.MinLengthAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.NotEmptyAttribute">
      <summary>
            Not empty attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.NotEmptyAttribute.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.NotEmptyAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.NotEmptyAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="T:Utilities.Validation.NotInRangeAttribute">
      <summary>
            Not in range attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.NotInRangeAttribute.#ctor(System.Object,System.Object,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Max">Max value</param>
      <param name="Min">Min value</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.NotInRangeAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.NotInRangeAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.NotInRangeAttribute.Max">
      <summary>
            Max value to compare to
            </summary>
    </member>
    <member name="P:Utilities.Validation.NotInRangeAttribute.Min">
      <summary>
            Min value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Web.DictionaryExtensions">
      <summary>
            Extensions for Dictionary classes
            </summary>
    </member>
    <member name="M:Utilities.Web.DictionaryExtensions.ToQueryString(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Converts the IDictionary to a query string
            </summary>
      <param name="Input">Input</param>
      <returns>The IDictionary expressed as a string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="T:Utilities.Web.HTMLExtensions">
      <summary>
            Set of HTML related extensions (and HTTP related)
            </summary>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.AbsoluteRoot(System.Web.HttpContextBase)">
      <summary>
            Returns the absolute root
            </summary>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.AbsoluteRoot(System.Web.HttpContext)">
      <summary>
            Returns the absolute root
            </summary>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.AddScriptFile(System.Web.UI.Page,Utilities.IO.FileInfo)">
      <summary>
            Adds a script file to the header of the current page
            </summary>
      <param name="File">Script file</param>
      <param name="Page">Page to add it to</param>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != (Utilities.IO.FileInfo)null" vb="File &lt;&gt; ((Utilities.IO.FileInfo)Nothing) ">File != (Utilities.IO.FileInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!File != (Utilities.IO.FileInfo)null</exception>
      <requires description="File does not exist" exception="T:System.IO.FileNotFoundException" csharp="File.Exists" vb="File.Exists">File.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!File.Exists</exception>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.ContainsHTML(System.String)">
      <summary>
            Decides if the string contains HTML
            </summary>
      <param name="Input">Input string to check</param>
      <returns>false if it does not contain HTML, true otherwise</returns>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.ContainsHTML(Utilities.IO.FileInfo)">
      <summary>
            Decides if the file contains HTML
            </summary>
      <param name="Input">Input file to check</param>
      <returns>false if it does not contain HTML, true otherwise</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != (Utilities.IO.FileInfo)null" vb="Input &lt;&gt; ((Utilities.IO.FileInfo)Nothing) ">Input != (Utilities.IO.FileInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Input != (Utilities.IO.FileInfo)null</exception>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.HTTPCompress(System.Web.HttpContextBase,System.Boolean,Utilities.IO.MinificationType)">
      <summary>
            Adds HTTP compression to the current context
            </summary>
      <param name="Context">Current context</param>
      <param name="RemovePrettyPrinting">
            Sets the response filter to a special stream that removes pretty printing from content
            </param>
      <param name="Type">
            The minification type to use (defaults to HTML if RemovePrettyPrinting is set to true,
            but can also deal with CSS and Javascript)
            </param>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.HTTPCompress(System.Web.HttpContext,System.Boolean,Utilities.IO.MinificationType)">
      <summary>
            Adds HTTP compression to the current context
            </summary>
      <param name="Context">Current context</param>
      <param name="RemovePrettyPrinting">
            Sets the response filter to a special stream that removes pretty printing from content
            </param>
      <param name="Type">
            The minification type to use (defaults to HTML if RemovePrettyPrinting is set to true,
            but can also deal with CSS and Javascript)
            </param>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.IsEncodingAccepted(System.Web.HttpContextBase,System.String)">
      <summary>
            Checks the request headers to see if the specified encoding is accepted by the client.
            </summary>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.IsEncodingAccepted(System.Web.HttpContext,System.String)">
      <summary>
            Checks the request headers to see if the specified encoding is accepted by the client.
            </summary>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.RelativeRoot(System.Web.HttpContextBase)">
      <summary>
            Gets the relative root of the web site
            </summary>
      <param name="Context">Current context</param>
      <returns>The relative root of the web site</returns>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.RelativeRoot(System.Web.HttpContext)">
      <summary>
            Gets the relative root of the web site
            </summary>
      <param name="Context">Current context</param>
      <returns>The relative root of the web site</returns>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.RemoveURLIllegalCharacters(System.String)">
      <summary>
            Removes illegal characters (used in uri's, etc.)
            </summary>
      <param name="Input">string to be converted</param>
      <returns>A stripped string</returns>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.SetEncoding(System.Web.HttpContextBase,System.String)">
      <summary>
            Adds the specified encoding to the response headers.
            </summary>
      <param name="Encoding">Encoding to set</param>
      <param name="Context">Context to set the encoding on</param>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.SetEncoding(System.Web.HttpContext,System.String)">
      <summary>
            Adds the specified encoding to the response headers.
            </summary>
      <param name="Encoding">Encoding to set</param>
      <param name="Context">Context to set the encoding on</param>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.StripHTML(System.String)">
      <summary>
            Removes HTML elements from a string
            </summary>
      <param name="HTML">HTML laiden string</param>
      <returns>HTML-less string</returns>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.StripHTML(Utilities.IO.FileInfo)">
      <summary>
            Removes HTML elements from a string
            </summary>
      <param name="HTML">HTML laiden file</param>
      <returns>HTML-less string</returns>
      <requires description="HTML" exception="T:System.ArgumentNullException" csharp="HTML != (Utilities.IO.FileInfo)null" vb="HTML &lt;&gt; ((Utilities.IO.FileInfo)Nothing) ">HTML != (Utilities.IO.FileInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!HTML != (Utilities.IO.FileInfo)null</exception>
      <requires description="File does not exist" exception="T:System.IO.FileNotFoundException" csharp="HTML.Exists" vb="HTML.Exists">HTML.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!HTML.Exists</exception>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.URLDecode(System.String)">
      <summary>
            URL decodes a string
            </summary>
      <param name="Input">Input to decode</param>
      <returns>A decoded string</returns>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.URLEncode(System.String)">
      <summary>
            URL encodes a string
            </summary>
      <param name="Input">Input to encode</param>
      <returns>An encoded string</returns>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.RemoveDiacritics(System.String)">
      <summary>
            Removes special characters (Diacritics) from the string
            </summary>
      <param name="Input">String to strip</param>
      <returns>Stripped string</returns>
    </member>
    <member name="M:Utilities.Web.HTMLExtensions.RemoveExtraHyphen(System.String)">
      <summary>
            Removes extra hyphens from a string
            </summary>
      <param name="Input">string to be stripped</param>
      <returns>Stripped string</returns>
    </member>
    <member name="T:Utilities.Web.HTTPContextExtensions">
      <summary>
            HttpContext extensions
            </summary>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpAllInformation(System.Web.HttpContext,System.Boolean)">
      <summary>
            Dumps a lot of information about the request to a string (Request, Response, Session,
            Cookies, Cache, and Application state)
            </summary>
      <param name="Context">HttpContext</param>
      <param name="HTMLOutput">Determines if this should be HTML output or not</param>
      <returns>The exported data</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpApplicationState(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps the values found in the Application State
            </summary>
      <param name="Page">Page in which to dump</param>
      <param name="HTMLOutput">Should html output be used?</param>
      <returns>A string containing the application state information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpApplicationState(System.Web.HttpApplicationState,System.Boolean)">
      <summary>
            Dumps the values found in the application state
            </summary>
      <param name="Input">Application state variable</param>
      <param name="HTMLOutput">Should html output be used?</param>
      <returns>A string containing the application state information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpCache(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps the values found in the cache
            </summary>
      <param name="Page">Page in which to dump</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing the cache information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpCache(System.Web.Caching.Cache,System.Boolean)">
      <summary>
            Dumps the values found in the cache
            </summary>
      <param name="Input">Cache variable</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing the cache information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpCookies(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps the values found in the cookies sent by the user
            </summary>
      <param name="Page">Page in which to dump</param>
      <param name="HTMLOutput">Should html output be used</param>
      <returns>A string containing the cookie information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpCookies(System.Web.HttpCookieCollection,System.Boolean)">
      <summary>
            Dumps the values found in the cookies sent by the user
            </summary>
      <param name="Input">Cookies</param>
      <param name="HTMLOutput">Should html output be used</param>
      <returns>A string containing the cookie information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpRequestVariable(System.Web.HttpRequest,System.Boolean)">
      <summary>
            Dumps information about the request variable
            </summary>
      <param name="Request">Request to dump the information about</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing the information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpRequestVariable(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps information about the request variable
            </summary>
      <param name="Page">Page to dump the information about</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing the information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpResponseVariable(System.Web.HttpResponse,System.Boolean)">
      <summary>
            Dumps information about the response variable
            </summary>
      <param name="Response">Response to dump the information about</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing the information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpResponseVariable(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps information about the response variable
            </summary>
      <param name="Page">Page to dump the information about</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing the information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpServerVars(System.Web.HttpRequest,System.Boolean)">
      <summary>
            Gets the server variables and dumps them out
            </summary>
      <param name="Request">request to get server variables from</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing an HTML formatted list of the server variables</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpServerVars(System.Web.UI.Page,System.Boolean)">
      <summary>
            Gets the server variables and dumps them out
            </summary>
      <param name="Page">page to get server variables from</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing an HTML formatted list of the server variables</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpSession(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps the values found in the session
            </summary>
      <param name="Page">Page in which to dump</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing the session information</returns>
    </member>
    <member name="M:Utilities.Web.HTTPContextExtensions.DumpSession(System.Web.SessionState.HttpSessionState,System.Boolean)">
      <summary>
            Dumps the values found in the session
            </summary>
      <param name="Input">Session variable</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing the session information</returns>
    </member>
    <member name="T:Utilities.Web.HTTPRequestExtensions">
      <summary>
            Extensions for HttpRequest classes
            </summary>
    </member>
    <member name="M:Utilities.Web.HTTPRequestExtensions.UserIPAddress(System.Web.HttpRequestBase)">
      <summary>
            Gets the user's IP address if it exists, null is returned otherwise
            </summary>
      <param name="Request">Request</param>
      <returns>The IPAddress object if it exists, null otherwise</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.Web.HTTPRequestExtensions.UserIPAddress(System.Web.HttpRequest)">
      <summary>
            Gets the user's IP address if it exists, null is returned otherwise
            </summary>
      <param name="Request">Request</param>
      <returns>The IPAddress object if it exists, null otherwise</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.Web.HTTPRequestExtensions.IfModifiedSince(System.Web.HttpRequestBase)">
      <summary>
            Converts the If-Modified-Since header value to a DateTime object
            </summary>
      <param name="Request">Request</param>
      <returns>The If-Modified-Since header value expressed as a DateTime object</returns>
    </member>
    <member name="M:Utilities.Web.HTTPRequestExtensions.IfModifiedSince(System.Web.HttpRequest)">
      <summary>
            Converts the If-Modified-Since header value to a DateTime object
            </summary>
      <param name="Request">Request</param>
      <returns>The If-Modified-Since header value expressed as a DateTime object</returns>
    </member>
    <member name="M:Utilities.Web.HTTPRequestExtensions.IsMobile(System.Web.HttpRequestBase)">
      <summary>
            Detects if a browser is on a mobile device or not (does a more thorough job than simply Request.Browser.IsMobileDevice)
            </summary>
      <param name="Request">Request object</param>
      <returns>True if it is, false otherwise</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
      <requires description="Browser" exception="T:System.ArgumentNullException" csharp="Request.Browser != null" vb="Request.Browser &lt;&gt; Nothing">Request.Browser != null</requires>
      <exception cref="T:System.ArgumentNullException">Request.Browser == null</exception>
    </member>
    <member name="M:Utilities.Web.HTTPRequestExtensions.IsMobile(System.Web.HttpRequest)">
      <summary>
            Detects if a browser is on a mobile device or not (does a more thorough job than simply Request.Browser.IsMobileDevice)
            </summary>
      <param name="Request">Request object</param>
      <returns>True if it is, false otherwise</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
      <requires description="Browser" exception="T:System.ArgumentNullException" csharp="Request.Browser != null" vb="Request.Browser &lt;&gt; Nothing">Request.Browser != null</requires>
      <exception cref="T:System.ArgumentNullException">Request.Browser == null</exception>
    </member>
    <member name="T:Utilities.Web.IPAddressExtensions">
      <summary>
            Extensions related to IP addresses
            </summary>
    </member>
    <member name="M:Utilities.Web.IPAddressExtensions.GetHostName(System.Net.IPAddress)">
      <summary>
            Gets the host name based off of an IP address
            </summary>
      <param name="IP">IP address</param>
      <returns>the host name associated with the IP</returns>
    </member>
    <member name="M:Utilities.Web.IPAddressExtensions.GetHostName(System.String)">
      <summary>
            Gets the host name based off of an IP address
            </summary>
      <param name="IP">IP address</param>
      <returns>the host name associated with the IP</returns>
    </member>
    <member name="T:Utilities.Web.NameValueCollectionExtensions">
      <summary>
            Extensions for NameValueCollection
            </summary>
    </member>
    <member name="M:Utilities.Web.NameValueCollectionExtensions.ToQueryString(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Converts the NameValueCollection to a query string
            </summary>
      <param name="Input">Input</param>
      <returns>The NameValueCollection expressed as a string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="T:Utilities.Web.Streams.UglyStream">
      <summary>
            Removes "pretty printing" from HTML
            </summary>
    </member>
    <member name="M:Utilities.Web.Streams.UglyStream.#ctor(System.IO.Stream,Utilities.IO.CompressionType,Utilities.IO.MinificationType)">
      <summary>
            Constructor
            </summary>
      <param name="StreamUsing">The stream for the page</param>
      <param name="Compression">The compression we're using (gzip or deflate)</param>
      <param name="Type">Minification type to use (defaults to HTML)</param>
    </member>
    <member name="F:Utilities.Web.Streams.UglyStream.Compression">
      <summary>
            Compression using
            </summary>
    </member>
    <member name="F:Utilities.Web.Streams.UglyStream.FinalString">
      <summary>
            Final output string
            </summary>
    </member>
    <member name="F:Utilities.Web.Streams.UglyStream.StreamUsing">
      <summary>
            Stream using
            </summary>
    </member>
    <member name="M:Utilities.Web.Streams.UglyStream.Flush">
      <summary>
            Nothing to flush
            </summary>
    </member>
    <member name="M:Utilities.Web.Streams.UglyStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Don't worry about
            </summary>
      <param name="buffer" />
      <param name="offset" />
      <param name="count" />
      <returns />
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="result &lt;= count" vb="result &lt;= count">result &lt;= count</ensures>
    </member>
    <member name="M:Utilities.Web.Streams.UglyStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Once again not implemented
            </summary>
      <param name="offset" />
      <param name="origin" />
      <returns />
    </member>
    <member name="M:Utilities.Web.Streams.UglyStream.SetLength(System.Int64)">
      <summary>
            Don't worry about
            </summary>
      <param name="value" />
      <requires inheritedFrom="M:System.IO.Stream.SetLength(System.Int64)" inheritedFromTypeName="Stream" csharp="value &gt;= (long)0" vb="value &gt;= ((Long )0)">value &gt;= (long)0</requires>
    </member>
    <member name="M:Utilities.Web.Streams.UglyStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Actually writes out the data
            </summary>
      <param name="buffer">the page's data in byte form</param>
      <param name="offset">offset of the data</param>
      <param name="count">the amount of data</param>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
    </member>
    <member name="M:Utilities.Web.Streams.UglyStream.Evaluate(System.Text.RegularExpressions.Match)">
      <summary>
            Evaluates whether the text has spaces, page breaks, etc. and removes them.
            </summary>
      <param name="Matcher">Match found</param>
      <returns>The string minus any extra white space</returns>
    </member>
    <member name="P:Utilities.Web.Streams.UglyStream.CanRead">
      <summary>
            Doesn't deal with reading
            </summary>
    </member>
    <member name="P:Utilities.Web.Streams.UglyStream.CanSeek">
      <summary>
            No seeking
            </summary>
    </member>
    <member name="P:Utilities.Web.Streams.UglyStream.CanWrite">
      <summary>
            Can write out though
            </summary>
    </member>
    <member name="P:Utilities.Web.Streams.UglyStream.Length">
      <summary>
            Don't worry about
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Length" inheritedFromTypeName="Stream" csharp="result &gt;= (long)0" vb="result &gt;= ((Long )0)">result &gt;= (long)0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.Web.Streams.UglyStream.Position">
      <summary>
            No position to take care of
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Position" inheritedFromTypeName="Stream" csharp="result &gt;= (long)0" vb="result &gt;= ((Long )0)">result &gt;= (long)0</ensures>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.IO.Stream.set_Position(System.Int64)" inheritedFromTypeName="Stream" csharp="value &gt;= (long)0" vb="value &gt;= ((Long )0)">value &gt;= (long)0</requires>
      </setter>
    </member>
    <member name="M:Utilities.Random.Dynamic.Randomization.Randomize(Utilities.DataTypes.Dynamo)">
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.GetHeight(System.Int32,System.Int32,System.Drawing.Imaging.BitmapData,System.Int32)">
      <requires description="BlackAndWhiteData" exception="T:System.ArgumentNullException" csharp="BlackAndWhiteData != null" vb="BlackAndWhiteData &lt;&gt; Nothing">BlackAndWhiteData != null</requires>
      <exception cref="T:System.ArgumentNullException">BlackAndWhiteData == null</exception>
    </member>
    <member name="M:Utilities.Media.BitmapExtensions.GetMinMaxPixel(System.Drawing.Color@,System.Drawing.Color@,System.Drawing.Imaging.BitmapData,System.Int32)">
      <requires description="ImageData" exception="T:System.ArgumentNullException" csharp="ImageData != null" vb="ImageData &lt;&gt; Nothing">ImageData != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageData == null</exception>
    </member>
    <member name="M:Utilities.Media.Procedural.MidpointDisplacement.GenerateLines(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <requires exception="T:System.ArgumentException" csharp="NumberOfCracks &gt;= 0 &amp;&amp; !(Width &lt; 0)" vb="NumberOfCracks &gt;= 0 AndAlso Not Width &lt; 0">NumberOfCracks &gt;= 0 &amp;&amp; !(Width &lt; 0)</requires>
      <exception cref="T:System.ArgumentException">NumberOfCracks &lt; 0 ? !false : Width &lt; 0</exception>
    </member>
    <member name="M:Utilities.Media.Procedural.PerlinNoise.GetValue(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Single[0:,0:])">
      <requires description="Octaves should be greater than or equal to 0" exception="T:System.ArgumentException" csharp="Octaves &gt;= 0" vb="Octaves &gt;= 0">Octaves &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">Octaves &lt; 0</exception>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupIEnumerableProperty(System.String,Utilities.ORM.Manager.Mapper.Interfaces.IProperty)">
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != null" vb="Property &lt;&gt; Nothing">Property != null</requires>
      <exception cref="T:System.ArgumentNullException">Property == null</exception>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupListProperty(System.String,Utilities.ORM.Manager.Mapper.Interfaces.IProperty)">
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != null" vb="Property &lt;&gt; Nothing">Property != null</requires>
      <exception cref="T:System.ArgumentNullException">Property == null</exception>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupSingleProperty(System.String,Utilities.ORM.Manager.Mapper.Interfaces.IProperty)">
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != null" vb="Property &lt;&gt; Nothing">Property != null</requires>
      <exception cref="T:System.ArgumentNullException">Property == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetAlterFunctionCommand(Utilities.ORM.Manager.Schema.Default.Database.Function,Utilities.ORM.Manager.Schema.Default.Database.Function)">
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
      <requires description="CurrentFunction" exception="T:System.ArgumentNullException" csharp="CurrentFunction != null" vb="CurrentFunction &lt;&gt; Nothing">CurrentFunction != null</requires>
      <exception cref="T:System.ArgumentNullException">CurrentFunction == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetAlterStoredProcedure(Utilities.ORM.Manager.Schema.Default.Database.StoredProcedure,Utilities.ORM.Manager.Schema.Default.Database.StoredProcedure)">
      <requires description="StoredProcedure" exception="T:System.ArgumentNullException" csharp="StoredProcedure != null" vb="StoredProcedure &lt;&gt; Nothing">StoredProcedure != null</requires>
      <exception cref="T:System.ArgumentNullException">StoredProcedure == null</exception>
      <requires description="CurrentStoredProcedure" exception="T:System.ArgumentNullException" csharp="CurrentStoredProcedure != null" vb="CurrentStoredProcedure &lt;&gt; Nothing">CurrentStoredProcedure != null</requires>
      <exception cref="T:System.ArgumentNullException">CurrentStoredProcedure == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetAlterTableCommand(Utilities.ORM.Manager.Schema.Default.Database.Table,Utilities.ORM.Manager.Schema.Interfaces.ITable)">
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetAlterTriggerCommand(Utilities.ORM.Manager.Schema.Default.Database.Table,Utilities.ORM.Manager.Schema.Interfaces.ITable)">
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetAlterViewCommand(Utilities.ORM.Manager.Schema.Default.Database.View,Utilities.ORM.Manager.Schema.Default.Database.View)">
      <requires description="View" exception="T:System.ArgumentNullException" csharp="View != null" vb="View &lt;&gt; Nothing">View != null</requires>
      <exception cref="T:System.ArgumentNullException">View == null</exception>
      <requires description="CurrentView" exception="T:System.ArgumentNullException" csharp="CurrentView != null" vb="CurrentView &lt;&gt; Nothing">CurrentView != null</requires>
      <exception cref="T:System.ArgumentNullException">CurrentView == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetForeignKeyCommand(Utilities.ORM.Manager.Schema.Default.Database.Table)">
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetFunctionCommand(Utilities.ORM.Manager.Schema.Default.Database.Function)">
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetStoredProcedure(Utilities.ORM.Manager.Schema.Default.Database.StoredProcedure)">
      <requires description="StoredProcedure" exception="T:System.ArgumentNullException" csharp="StoredProcedure != null" vb="StoredProcedure &lt;&gt; Nothing">StoredProcedure != null</requires>
      <exception cref="T:System.ArgumentNullException">StoredProcedure == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetTableCommand(Utilities.ORM.Manager.Schema.Default.Database.Table)">
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetTriggerCommand(Utilities.ORM.Manager.Schema.Default.Database.Table)">
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetViewCommand(Utilities.ORM.Manager.Schema.Default.Database.View)">
      <requires description="View" exception="T:System.ArgumentNullException" csharp="View != null" vb="View &lt;&gt; Nothing">View != null</requires>
      <exception cref="T:System.ArgumentNullException">View == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.SetupColumns(Utilities.ORM.Manager.Schema.Default.Database.Table,System.Collections.Generic.IEnumerable{System.Object})">
      <requires description="Values" exception="T:System.ArgumentNullException" csharp="Values != null" vb="Values &lt;&gt; Nothing">Values != null</requires>
      <exception cref="T:System.ArgumentNullException">Values == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.Exists(System.String,System.String,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo)">
      <requires description="Source" exception="T:System.ArgumentNullException" csharp="Source != null" vb="Source &lt;&gt; Nothing">Source != null</requires>
      <exception cref="T:System.ArgumentNullException">Source == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.GetTables(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Schema.Default.Database.Database)">
      <requires description="Source" exception="T:System.ArgumentNullException" csharp="Source != null" vb="Source &lt;&gt; Nothing">Source != null</requires>
      <exception cref="T:System.ArgumentNullException">Source == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.SetupFunctions(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Schema.Default.Database.Database)">
      <requires description="Source" exception="T:System.ArgumentNullException" csharp="Source != null" vb="Source &lt;&gt; Nothing">Source != null</requires>
      <exception cref="T:System.ArgumentNullException">Source == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.SetupStoredProcedures(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Schema.Default.Database.Database)">
      <requires description="Source" exception="T:System.ArgumentNullException" csharp="Source != null" vb="Source &lt;&gt; Nothing">Source != null</requires>
      <exception cref="T:System.ArgumentNullException">Source == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.SetupTables(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Schema.Default.Database.Database)">
      <requires description="Temp" exception="T:System.ArgumentNullException" csharp="Temp != null" vb="Temp &lt;&gt; Nothing">Temp != null</requires>
      <exception cref="T:System.ArgumentNullException">Temp == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.SetupTriggers(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Schema.Default.Database.Table,System.Collections.Generic.IEnumerable{System.Object})">
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
      <requires description="Source" exception="T:System.ArgumentNullException" csharp="Source != null" vb="Source &lt;&gt; Nothing">Source != null</requires>
      <exception cref="T:System.ArgumentNullException">Source == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Schema.Default.Database.SQLServer.SQLServerSchemaGenerator.SetupViews(Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Schema.Default.Database.Database)">
      <requires description="Temp" exception="T:System.ArgumentNullException" csharp="Temp != null" vb="Temp &lt;&gt; Nothing">Temp != null</requires>
      <exception cref="T:System.ArgumentNullException">Temp == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.GetColumns(Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupAllSelect(Utilities.ORM.Manager.Mapper.Interfaces.IMapping{`0})">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupAnySelect(Utilities.ORM.Manager.Mapper.Interfaces.IMapping{`0})">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupDelete(Utilities.ORM.Manager.Mapper.Interfaces.IMapping{`0})">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupInsert(Utilities.ORM.Manager.Mapper.Interfaces.IMapping{`0})">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.SQLServer.SQLServerGenerator`1.SetupUpdate(Utilities.ORM.Manager.Mapper.Interfaces.IMapping{`0})">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.QueryProvider.Default.DatabaseBatch.GetValues(System.Data.Common.DbDataReader)">
      <requires description="TempReader" exception="T:System.ArgumentNullException" csharp="TempReader != null" vb="TempReader &lt;&gt; Nothing">TempReader != null</requires>
      <exception cref="T:System.ArgumentNullException">TempReader == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.CascadeDelete``1(``0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Interfaces.IMapping,Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch,System.Collections.Generic.List{System.Object})">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.CascadeSave``1(``0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Interfaces.IMapping,Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch,System.Collections.Generic.List{System.Object})">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.JoinsDelete``1(``0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Interfaces.IMapping,Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch,System.Collections.Generic.List{System.Object})">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.Session.JoinsSave``1(``0,Utilities.ORM.Manager.SourceProvider.Interfaces.ISourceInfo,Utilities.ORM.Manager.Mapper.Interfaces.IMapping,Utilities.ORM.Manager.QueryProvider.Interfaces.IBatch,System.Collections.Generic.List{System.Object})">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.ORMManager.SetupAuditTables(Utilities.ORM.Manager.Schema.Interfaces.ITable)">
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.ORMManager.SetupAuditTables(Utilities.ORM.Interfaces.IDatabase,Utilities.ORM.Manager.Schema.Default.Database.Database)">
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="Key != null" vb="Key &lt;&gt; Nothing">Key != null</requires>
      <exception cref="T:System.ArgumentNullException">Key == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.ORMManager.SetupDeleteTrigger(Utilities.ORM.Manager.Schema.Interfaces.ITable)">
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.ORMManager.SetupInsertUpdateTrigger(Utilities.ORM.Manager.Schema.Interfaces.ITable)">
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.ORMManager.SetupProperties(Utilities.ORM.Manager.Schema.Interfaces.ITable,Utilities.ORM.Manager.Mapper.Interfaces.IMapping)">
      <requires description="Mapping" exception="T:System.ArgumentNullException" csharp="Mapping != null" vb="Mapping &lt;&gt; Nothing">Mapping != null</requires>
      <exception cref="T:System.ArgumentNullException">Mapping == null</exception>
      <requires description="Table" exception="T:System.ArgumentNullException" csharp="Table != null" vb="Table &lt;&gt; Nothing">Table != null</requires>
      <exception cref="T:System.ArgumentNullException">Table == null</exception>
    </member>
    <member name="M:Utilities.ORM.Manager.ORMManager.SetupJoiningTablesEnumerable(Utilities.ORM.Manager.Mapper.Interfaces.IMapping,Utilities.ORM.Manager.Mapper.Interfaces.IProperty,Utilities.ORM.Interfaces.IDatabase,Utilities.ORM.Manager.Schema.Default.Database.Database)">
      <requires description="TempDatabase" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.ORM.Manager.ORMManager.&lt;&gt;c__DisplayClass8().Property = Property;&#xD;&#xA;    }&#xD;&#xA;    return TempDatabase != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.ORM.Manager.ORMManager.&lt;&gt;c__DisplayClass8().Property = Property&#xD;&#xA;    return TempDatabase &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.ORM.Manager.ORMManager.&lt;&gt;c__DisplayClass8().Property = Property;
    }
    return TempDatabase != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.ORM.Manager.ORMManager.&lt;&gt;c__DisplayClass8().Property = Property);
    }
    return (TempDatabase != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.AddLeftIDictionaryMapping(System.Type,System.Type)">
      <requires description="RightType" exception="T:System.ArgumentNullException" csharp="RightType != (System.Type)null" vb="RightType &lt;&gt; ((System.Type)Nothing) ">RightType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!RightType != (System.Type)null</exception>
      <requires description="LeftType" exception="T:System.ArgumentNullException" csharp="LeftType != (System.Type)null" vb="LeftType &lt;&gt; ((System.Type)Nothing) ">LeftType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!LeftType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.DataMapper.BaseClasses.TypeMappingBase`2.AddRightIDictionaryMapping(System.Type,System.Type)">
      <requires description="RightType" exception="T:System.ArgumentNullException" csharp="RightType != (System.Type)null" vb="RightType &lt;&gt; ((System.Type)Nothing) ">RightType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!RightType != (System.Type)null</exception>
      <requires description="LeftType" exception="T:System.ArgumentNullException" csharp="LeftType != (System.Type)null" vb="LeftType &lt;&gt; ((System.Type)Nothing) ">LeftType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!LeftType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.IO.FileFormats.RSS.Document.Load(System.Xml.XPath.IXPathNavigable)">
      <requires description="Document" exception="T:System.ArgumentNullException" csharp="Document != null" vb="Document &lt;&gt; Nothing">Document != null</requires>
      <exception cref="T:System.ArgumentNullException">Document == null</exception>
    </member>
    <member name="M:Utilities.IO.HTMLExtensions.Evaluate(System.Text.RegularExpressions.Match)">
      <requires description="Matcher" exception="T:System.ArgumentNullException" csharp="Matcher != null" vb="Matcher &lt;&gt; Nothing">Matcher != null</requires>
      <exception cref="T:System.ArgumentNullException">Matcher == null</exception>
    </member>
  </members>
</doc>